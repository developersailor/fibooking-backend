
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Hotel
 * Represents a Hotel entity.
 */
export type Hotel = $Result.DefaultSelection<Prisma.$HotelPayload>
/**
 * Model Address
 * Represents a structured physical address. [1, 4, 6, 7]
 */
export type Address = $Result.DefaultSelection<Prisma.$AddressPayload>
/**
 * Model Image
 * Represents an image associated with a Hotel or RoomType. [8, 9]
 */
export type Image = $Result.DefaultSelection<Prisma.$ImagePayload>
/**
 * Model Amenity
 * Represents a facility or service offered (e.g., Pool, WiFi). [5, 3]
 */
export type Amenity = $Result.DefaultSelection<Prisma.$AmenityPayload>
/**
 * Model HotelAmenity
 * Join table for Hotel-Amenity many-to-many relationship. [5]
 */
export type HotelAmenity = $Result.DefaultSelection<Prisma.$HotelAmenityPayload>
/**
 * Model RoomType
 * Represents a category or type of room within a hotel (e.g., "Standard Double"). [11, 12]
 */
export type RoomType = $Result.DefaultSelection<Prisma.$RoomTypePayload>
/**
 * Model RoomTypeAmenity
 * Join table for RoomType-Amenity many-to-many relationship.
 */
export type RoomTypeAmenity = $Result.DefaultSelection<Prisma.$RoomTypeAmenityPayload>
/**
 * Model Room
 * Represents an individual physical room instance. [12, 13]
 */
export type Room = $Result.DefaultSelection<Prisma.$RoomPayload>
/**
 * Model RoomInventory
 * Tracks daily inventory counts per RoomType. Essential for availability checks. [18, 41]
 */
export type RoomInventory = $Result.DefaultSelection<Prisma.$RoomInventoryPayload>
/**
 * Model RoomPrice
 * Stores the price for a specific RoomType on a specific date. Enables dynamic pricing. [15, 18]
 */
export type RoomPrice = $Result.DefaultSelection<Prisma.$RoomPricePayload>
/**
 * Model User
 * Represents a registered user of the application.
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Role
 * Defines user roles within the system.
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model Booking
 * Represents a customer booking reservation.
 */
export type Booking = $Result.DefaultSelection<Prisma.$BookingPayload>
/**
 * Model Payment
 * Represents a payment attempt/record for a booking. [14, 15, 28]
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Transaction
 * Detailed ledger of financial operations related to a Payment. [28, 30, 31]
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model Review
 * Centralized model for user reviews, linked to a Booking. [16, 26]
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model Promotion
 * Defines promotional offers and discounts. [37, 38, 39]
 */
export type Promotion = $Result.DefaultSelection<Prisma.$PromotionPayload>
/**
 * Model CancellationPolicy
 * Defines cancellation policies. [15, 27, 33, 40]
 */
export type CancellationPolicy = $Result.DefaultSelection<Prisma.$CancellationPolicyPayload>
/**
 * Model Cancellation
 * Optional: Records details of a specific booking cancellation event. [16]
 */
export type Cancellation = $Result.DefaultSelection<Prisma.$CancellationPayload>
/**
 * Model PromotionHotel
 * 
 */
export type PromotionHotel = $Result.DefaultSelection<Prisma.$PromotionHotelPayload>
/**
 * Model PromotionRoomType
 * 
 */
export type PromotionRoomType = $Result.DefaultSelection<Prisma.$PromotionRoomTypePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const RoomStatus: {
  AVAILABLE: 'AVAILABLE',
  OCCUPIED: 'OCCUPIED',
  MAINTENANCE: 'MAINTENANCE',
  CLEANING: 'CLEANING'
};

export type RoomStatus = (typeof RoomStatus)[keyof typeof RoomStatus]


export const PriceType: {
  STANDARD: 'STANDARD',
  DISCOUNTED: 'DISCOUNTED',
  PEAK_SEASON: 'PEAK_SEASON',
  EVENT: 'EVENT',
  PROMOTIONAL: 'PROMOTIONAL'
};

export type PriceType = (typeof PriceType)[keyof typeof PriceType]


export const CurrencyCode: {
  USD: 'USD',
  EUR: 'EUR',
  TRY: 'TRY'
};

export type CurrencyCode = (typeof CurrencyCode)[keyof typeof CurrencyCode]


export const BookingStatus: {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  CANCELLED: 'CANCELLED',
  CHECKED_IN: 'CHECKED_IN',
  CHECKED_OUT: 'CHECKED_OUT',
  NO_SHOW: 'NO_SHOW',
  REJECTED: 'REJECTED'
};

export type BookingStatus = (typeof BookingStatus)[keyof typeof BookingStatus]


export const PaymentMethod: {
  CREDIT_CARD: 'CREDIT_CARD',
  DEBIT_CARD: 'DEBIT_CARD',
  PAYPAL: 'PAYPAL',
  BANK_TRANSFER: 'BANK_TRANSFER',
  OTHER: 'OTHER'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const PaymentStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  REFUNDED: 'REFUNDED',
  PARTIAL_REFUND: 'PARTIAL_REFUND'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const TransactionType: {
  AUTHORIZATION: 'AUTHORIZATION',
  CHARGE: 'CHARGE',
  REFUND: 'REFUND',
  VOID: 'VOID'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]


export const TransactionStatus: {
  PENDING: 'PENDING',
  SUCCESS: 'SUCCESS',
  FAILURE: 'FAILURE'
};

export type TransactionStatus = (typeof TransactionStatus)[keyof typeof TransactionStatus]


export const DiscountType: {
  PERCENTAGE: 'PERCENTAGE',
  FIXED_AMOUNT: 'FIXED_AMOUNT'
};

export type DiscountType = (typeof DiscountType)[keyof typeof DiscountType]

}

export type RoomStatus = $Enums.RoomStatus

export const RoomStatus: typeof $Enums.RoomStatus

export type PriceType = $Enums.PriceType

export const PriceType: typeof $Enums.PriceType

export type CurrencyCode = $Enums.CurrencyCode

export const CurrencyCode: typeof $Enums.CurrencyCode

export type BookingStatus = $Enums.BookingStatus

export const BookingStatus: typeof $Enums.BookingStatus

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

export type TransactionStatus = $Enums.TransactionStatus

export const TransactionStatus: typeof $Enums.TransactionStatus

export type DiscountType = $Enums.DiscountType

export const DiscountType: typeof $Enums.DiscountType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Hotels
 * const hotels = await prisma.hotel.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Hotels
   * const hotels = await prisma.hotel.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.hotel`: Exposes CRUD operations for the **Hotel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hotels
    * const hotels = await prisma.hotel.findMany()
    * ```
    */
  get hotel(): Prisma.HotelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.AddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.image`: Exposes CRUD operations for the **Image** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Images
    * const images = await prisma.image.findMany()
    * ```
    */
  get image(): Prisma.ImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.amenity`: Exposes CRUD operations for the **Amenity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Amenities
    * const amenities = await prisma.amenity.findMany()
    * ```
    */
  get amenity(): Prisma.AmenityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hotelAmenity`: Exposes CRUD operations for the **HotelAmenity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HotelAmenities
    * const hotelAmenities = await prisma.hotelAmenity.findMany()
    * ```
    */
  get hotelAmenity(): Prisma.HotelAmenityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roomType`: Exposes CRUD operations for the **RoomType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoomTypes
    * const roomTypes = await prisma.roomType.findMany()
    * ```
    */
  get roomType(): Prisma.RoomTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roomTypeAmenity`: Exposes CRUD operations for the **RoomTypeAmenity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoomTypeAmenities
    * const roomTypeAmenities = await prisma.roomTypeAmenity.findMany()
    * ```
    */
  get roomTypeAmenity(): Prisma.RoomTypeAmenityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.room`: Exposes CRUD operations for the **Room** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rooms
    * const rooms = await prisma.room.findMany()
    * ```
    */
  get room(): Prisma.RoomDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roomInventory`: Exposes CRUD operations for the **RoomInventory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoomInventories
    * const roomInventories = await prisma.roomInventory.findMany()
    * ```
    */
  get roomInventory(): Prisma.RoomInventoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roomPrice`: Exposes CRUD operations for the **RoomPrice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoomPrices
    * const roomPrices = await prisma.roomPrice.findMany()
    * ```
    */
  get roomPrice(): Prisma.RoomPriceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.booking`: Exposes CRUD operations for the **Booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): Prisma.BookingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.promotion`: Exposes CRUD operations for the **Promotion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Promotions
    * const promotions = await prisma.promotion.findMany()
    * ```
    */
  get promotion(): Prisma.PromotionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cancellationPolicy`: Exposes CRUD operations for the **CancellationPolicy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CancellationPolicies
    * const cancellationPolicies = await prisma.cancellationPolicy.findMany()
    * ```
    */
  get cancellationPolicy(): Prisma.CancellationPolicyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cancellation`: Exposes CRUD operations for the **Cancellation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cancellations
    * const cancellations = await prisma.cancellation.findMany()
    * ```
    */
  get cancellation(): Prisma.CancellationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.promotionHotel`: Exposes CRUD operations for the **PromotionHotel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PromotionHotels
    * const promotionHotels = await prisma.promotionHotel.findMany()
    * ```
    */
  get promotionHotel(): Prisma.PromotionHotelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.promotionRoomType`: Exposes CRUD operations for the **PromotionRoomType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PromotionRoomTypes
    * const promotionRoomTypes = await prisma.promotionRoomType.findMany()
    * ```
    */
  get promotionRoomType(): Prisma.PromotionRoomTypeDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Hotel: 'Hotel',
    Address: 'Address',
    Image: 'Image',
    Amenity: 'Amenity',
    HotelAmenity: 'HotelAmenity',
    RoomType: 'RoomType',
    RoomTypeAmenity: 'RoomTypeAmenity',
    Room: 'Room',
    RoomInventory: 'RoomInventory',
    RoomPrice: 'RoomPrice',
    User: 'User',
    Role: 'Role',
    Booking: 'Booking',
    Payment: 'Payment',
    Transaction: 'Transaction',
    Review: 'Review',
    Promotion: 'Promotion',
    CancellationPolicy: 'CancellationPolicy',
    Cancellation: 'Cancellation',
    PromotionHotel: 'PromotionHotel',
    PromotionRoomType: 'PromotionRoomType'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "hotel" | "address" | "image" | "amenity" | "hotelAmenity" | "roomType" | "roomTypeAmenity" | "room" | "roomInventory" | "roomPrice" | "user" | "role" | "booking" | "payment" | "transaction" | "review" | "promotion" | "cancellationPolicy" | "cancellation" | "promotionHotel" | "promotionRoomType"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Hotel: {
        payload: Prisma.$HotelPayload<ExtArgs>
        fields: Prisma.HotelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          findFirst: {
            args: Prisma.HotelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          findMany: {
            args: Prisma.HotelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>[]
          }
          create: {
            args: Prisma.HotelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          createMany: {
            args: Prisma.HotelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HotelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>[]
          }
          delete: {
            args: Prisma.HotelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          update: {
            args: Prisma.HotelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          deleteMany: {
            args: Prisma.HotelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HotelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>[]
          }
          upsert: {
            args: Prisma.HotelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          aggregate: {
            args: Prisma.HotelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotel>
          }
          groupBy: {
            args: Prisma.HotelGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotelGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotelCountArgs<ExtArgs>
            result: $Utils.Optional<HotelCountAggregateOutputType> | number
          }
        }
      }
      Address: {
        payload: Prisma.$AddressPayload<ExtArgs>
        fields: Prisma.AddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findFirst: {
            args: Prisma.AddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findMany: {
            args: Prisma.AddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          create: {
            args: Prisma.AddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          createMany: {
            args: Prisma.AddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          delete: {
            args: Prisma.AddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          update: {
            args: Prisma.AddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          deleteMany: {
            args: Prisma.AddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AddressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          upsert: {
            args: Prisma.AddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          aggregate: {
            args: Prisma.AddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddress>
          }
          groupBy: {
            args: Prisma.AddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddressCountArgs<ExtArgs>
            result: $Utils.Optional<AddressCountAggregateOutputType> | number
          }
        }
      }
      Image: {
        payload: Prisma.$ImagePayload<ExtArgs>
        fields: Prisma.ImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          findFirst: {
            args: Prisma.ImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          findMany: {
            args: Prisma.ImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>[]
          }
          create: {
            args: Prisma.ImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          createMany: {
            args: Prisma.ImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>[]
          }
          delete: {
            args: Prisma.ImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          update: {
            args: Prisma.ImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          deleteMany: {
            args: Prisma.ImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>[]
          }
          upsert: {
            args: Prisma.ImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          aggregate: {
            args: Prisma.ImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImage>
          }
          groupBy: {
            args: Prisma.ImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImageCountArgs<ExtArgs>
            result: $Utils.Optional<ImageCountAggregateOutputType> | number
          }
        }
      }
      Amenity: {
        payload: Prisma.$AmenityPayload<ExtArgs>
        fields: Prisma.AmenityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AmenityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AmenityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          findFirst: {
            args: Prisma.AmenityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AmenityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          findMany: {
            args: Prisma.AmenityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>[]
          }
          create: {
            args: Prisma.AmenityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          createMany: {
            args: Prisma.AmenityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AmenityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>[]
          }
          delete: {
            args: Prisma.AmenityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          update: {
            args: Prisma.AmenityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          deleteMany: {
            args: Prisma.AmenityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AmenityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AmenityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>[]
          }
          upsert: {
            args: Prisma.AmenityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          aggregate: {
            args: Prisma.AmenityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAmenity>
          }
          groupBy: {
            args: Prisma.AmenityGroupByArgs<ExtArgs>
            result: $Utils.Optional<AmenityGroupByOutputType>[]
          }
          count: {
            args: Prisma.AmenityCountArgs<ExtArgs>
            result: $Utils.Optional<AmenityCountAggregateOutputType> | number
          }
        }
      }
      HotelAmenity: {
        payload: Prisma.$HotelAmenityPayload<ExtArgs>
        fields: Prisma.HotelAmenityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotelAmenityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelAmenityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotelAmenityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelAmenityPayload>
          }
          findFirst: {
            args: Prisma.HotelAmenityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelAmenityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotelAmenityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelAmenityPayload>
          }
          findMany: {
            args: Prisma.HotelAmenityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelAmenityPayload>[]
          }
          create: {
            args: Prisma.HotelAmenityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelAmenityPayload>
          }
          createMany: {
            args: Prisma.HotelAmenityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HotelAmenityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelAmenityPayload>[]
          }
          delete: {
            args: Prisma.HotelAmenityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelAmenityPayload>
          }
          update: {
            args: Prisma.HotelAmenityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelAmenityPayload>
          }
          deleteMany: {
            args: Prisma.HotelAmenityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotelAmenityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HotelAmenityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelAmenityPayload>[]
          }
          upsert: {
            args: Prisma.HotelAmenityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelAmenityPayload>
          }
          aggregate: {
            args: Prisma.HotelAmenityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotelAmenity>
          }
          groupBy: {
            args: Prisma.HotelAmenityGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotelAmenityGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotelAmenityCountArgs<ExtArgs>
            result: $Utils.Optional<HotelAmenityCountAggregateOutputType> | number
          }
        }
      }
      RoomType: {
        payload: Prisma.$RoomTypePayload<ExtArgs>
        fields: Prisma.RoomTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTypePayload>
          }
          findFirst: {
            args: Prisma.RoomTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTypePayload>
          }
          findMany: {
            args: Prisma.RoomTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTypePayload>[]
          }
          create: {
            args: Prisma.RoomTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTypePayload>
          }
          createMany: {
            args: Prisma.RoomTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoomTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTypePayload>[]
          }
          delete: {
            args: Prisma.RoomTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTypePayload>
          }
          update: {
            args: Prisma.RoomTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTypePayload>
          }
          deleteMany: {
            args: Prisma.RoomTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoomTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoomTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTypePayload>[]
          }
          upsert: {
            args: Prisma.RoomTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTypePayload>
          }
          aggregate: {
            args: Prisma.RoomTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoomType>
          }
          groupBy: {
            args: Prisma.RoomTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoomTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomTypeCountArgs<ExtArgs>
            result: $Utils.Optional<RoomTypeCountAggregateOutputType> | number
          }
        }
      }
      RoomTypeAmenity: {
        payload: Prisma.$RoomTypeAmenityPayload<ExtArgs>
        fields: Prisma.RoomTypeAmenityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomTypeAmenityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTypeAmenityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomTypeAmenityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTypeAmenityPayload>
          }
          findFirst: {
            args: Prisma.RoomTypeAmenityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTypeAmenityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomTypeAmenityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTypeAmenityPayload>
          }
          findMany: {
            args: Prisma.RoomTypeAmenityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTypeAmenityPayload>[]
          }
          create: {
            args: Prisma.RoomTypeAmenityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTypeAmenityPayload>
          }
          createMany: {
            args: Prisma.RoomTypeAmenityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoomTypeAmenityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTypeAmenityPayload>[]
          }
          delete: {
            args: Prisma.RoomTypeAmenityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTypeAmenityPayload>
          }
          update: {
            args: Prisma.RoomTypeAmenityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTypeAmenityPayload>
          }
          deleteMany: {
            args: Prisma.RoomTypeAmenityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoomTypeAmenityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoomTypeAmenityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTypeAmenityPayload>[]
          }
          upsert: {
            args: Prisma.RoomTypeAmenityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomTypeAmenityPayload>
          }
          aggregate: {
            args: Prisma.RoomTypeAmenityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoomTypeAmenity>
          }
          groupBy: {
            args: Prisma.RoomTypeAmenityGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoomTypeAmenityGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomTypeAmenityCountArgs<ExtArgs>
            result: $Utils.Optional<RoomTypeAmenityCountAggregateOutputType> | number
          }
        }
      }
      Room: {
        payload: Prisma.$RoomPayload<ExtArgs>
        fields: Prisma.RoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findFirst: {
            args: Prisma.RoomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findMany: {
            args: Prisma.RoomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          create: {
            args: Prisma.RoomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          createMany: {
            args: Prisma.RoomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          delete: {
            args: Prisma.RoomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          update: {
            args: Prisma.RoomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          deleteMany: {
            args: Prisma.RoomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoomUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          upsert: {
            args: Prisma.RoomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          aggregate: {
            args: Prisma.RoomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoom>
          }
          groupBy: {
            args: Prisma.RoomGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomCountArgs<ExtArgs>
            result: $Utils.Optional<RoomCountAggregateOutputType> | number
          }
        }
      }
      RoomInventory: {
        payload: Prisma.$RoomInventoryPayload<ExtArgs>
        fields: Prisma.RoomInventoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomInventoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomInventoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomInventoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomInventoryPayload>
          }
          findFirst: {
            args: Prisma.RoomInventoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomInventoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomInventoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomInventoryPayload>
          }
          findMany: {
            args: Prisma.RoomInventoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomInventoryPayload>[]
          }
          create: {
            args: Prisma.RoomInventoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomInventoryPayload>
          }
          createMany: {
            args: Prisma.RoomInventoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoomInventoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomInventoryPayload>[]
          }
          delete: {
            args: Prisma.RoomInventoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomInventoryPayload>
          }
          update: {
            args: Prisma.RoomInventoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomInventoryPayload>
          }
          deleteMany: {
            args: Prisma.RoomInventoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoomInventoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoomInventoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomInventoryPayload>[]
          }
          upsert: {
            args: Prisma.RoomInventoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomInventoryPayload>
          }
          aggregate: {
            args: Prisma.RoomInventoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoomInventory>
          }
          groupBy: {
            args: Prisma.RoomInventoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoomInventoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomInventoryCountArgs<ExtArgs>
            result: $Utils.Optional<RoomInventoryCountAggregateOutputType> | number
          }
        }
      }
      RoomPrice: {
        payload: Prisma.$RoomPricePayload<ExtArgs>
        fields: Prisma.RoomPriceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomPriceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPricePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomPriceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPricePayload>
          }
          findFirst: {
            args: Prisma.RoomPriceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPricePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomPriceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPricePayload>
          }
          findMany: {
            args: Prisma.RoomPriceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPricePayload>[]
          }
          create: {
            args: Prisma.RoomPriceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPricePayload>
          }
          createMany: {
            args: Prisma.RoomPriceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoomPriceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPricePayload>[]
          }
          delete: {
            args: Prisma.RoomPriceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPricePayload>
          }
          update: {
            args: Prisma.RoomPriceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPricePayload>
          }
          deleteMany: {
            args: Prisma.RoomPriceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoomPriceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoomPriceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPricePayload>[]
          }
          upsert: {
            args: Prisma.RoomPriceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPricePayload>
          }
          aggregate: {
            args: Prisma.RoomPriceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoomPrice>
          }
          groupBy: {
            args: Prisma.RoomPriceGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoomPriceGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomPriceCountArgs<ExtArgs>
            result: $Utils.Optional<RoomPriceCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      Booking: {
        payload: Prisma.$BookingPayload<ExtArgs>
        fields: Prisma.BookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findFirst: {
            args: Prisma.BookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findMany: {
            args: Prisma.BookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          create: {
            args: Prisma.BookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          createMany: {
            args: Prisma.BookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          delete: {
            args: Prisma.BookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          update: {
            args: Prisma.BookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          deleteMany: {
            args: Prisma.BookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          upsert: {
            args: Prisma.BookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          aggregate: {
            args: Prisma.BookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking>
          }
          groupBy: {
            args: Prisma.BookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingCountArgs<ExtArgs>
            result: $Utils.Optional<BookingCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      Promotion: {
        payload: Prisma.$PromotionPayload<ExtArgs>
        fields: Prisma.PromotionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromotionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromotionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          findFirst: {
            args: Prisma.PromotionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromotionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          findMany: {
            args: Prisma.PromotionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>[]
          }
          create: {
            args: Prisma.PromotionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          createMany: {
            args: Prisma.PromotionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PromotionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>[]
          }
          delete: {
            args: Prisma.PromotionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          update: {
            args: Prisma.PromotionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          deleteMany: {
            args: Prisma.PromotionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromotionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PromotionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>[]
          }
          upsert: {
            args: Prisma.PromotionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionPayload>
          }
          aggregate: {
            args: Prisma.PromotionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromotion>
          }
          groupBy: {
            args: Prisma.PromotionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromotionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromotionCountArgs<ExtArgs>
            result: $Utils.Optional<PromotionCountAggregateOutputType> | number
          }
        }
      }
      CancellationPolicy: {
        payload: Prisma.$CancellationPolicyPayload<ExtArgs>
        fields: Prisma.CancellationPolicyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CancellationPolicyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPolicyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CancellationPolicyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPolicyPayload>
          }
          findFirst: {
            args: Prisma.CancellationPolicyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPolicyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CancellationPolicyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPolicyPayload>
          }
          findMany: {
            args: Prisma.CancellationPolicyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPolicyPayload>[]
          }
          create: {
            args: Prisma.CancellationPolicyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPolicyPayload>
          }
          createMany: {
            args: Prisma.CancellationPolicyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CancellationPolicyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPolicyPayload>[]
          }
          delete: {
            args: Prisma.CancellationPolicyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPolicyPayload>
          }
          update: {
            args: Prisma.CancellationPolicyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPolicyPayload>
          }
          deleteMany: {
            args: Prisma.CancellationPolicyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CancellationPolicyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CancellationPolicyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPolicyPayload>[]
          }
          upsert: {
            args: Prisma.CancellationPolicyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPolicyPayload>
          }
          aggregate: {
            args: Prisma.CancellationPolicyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCancellationPolicy>
          }
          groupBy: {
            args: Prisma.CancellationPolicyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CancellationPolicyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CancellationPolicyCountArgs<ExtArgs>
            result: $Utils.Optional<CancellationPolicyCountAggregateOutputType> | number
          }
        }
      }
      Cancellation: {
        payload: Prisma.$CancellationPayload<ExtArgs>
        fields: Prisma.CancellationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CancellationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CancellationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPayload>
          }
          findFirst: {
            args: Prisma.CancellationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CancellationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPayload>
          }
          findMany: {
            args: Prisma.CancellationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPayload>[]
          }
          create: {
            args: Prisma.CancellationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPayload>
          }
          createMany: {
            args: Prisma.CancellationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CancellationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPayload>[]
          }
          delete: {
            args: Prisma.CancellationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPayload>
          }
          update: {
            args: Prisma.CancellationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPayload>
          }
          deleteMany: {
            args: Prisma.CancellationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CancellationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CancellationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPayload>[]
          }
          upsert: {
            args: Prisma.CancellationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPayload>
          }
          aggregate: {
            args: Prisma.CancellationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCancellation>
          }
          groupBy: {
            args: Prisma.CancellationGroupByArgs<ExtArgs>
            result: $Utils.Optional<CancellationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CancellationCountArgs<ExtArgs>
            result: $Utils.Optional<CancellationCountAggregateOutputType> | number
          }
        }
      }
      PromotionHotel: {
        payload: Prisma.$PromotionHotelPayload<ExtArgs>
        fields: Prisma.PromotionHotelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromotionHotelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionHotelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromotionHotelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionHotelPayload>
          }
          findFirst: {
            args: Prisma.PromotionHotelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionHotelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromotionHotelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionHotelPayload>
          }
          findMany: {
            args: Prisma.PromotionHotelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionHotelPayload>[]
          }
          create: {
            args: Prisma.PromotionHotelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionHotelPayload>
          }
          createMany: {
            args: Prisma.PromotionHotelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PromotionHotelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionHotelPayload>[]
          }
          delete: {
            args: Prisma.PromotionHotelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionHotelPayload>
          }
          update: {
            args: Prisma.PromotionHotelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionHotelPayload>
          }
          deleteMany: {
            args: Prisma.PromotionHotelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromotionHotelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PromotionHotelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionHotelPayload>[]
          }
          upsert: {
            args: Prisma.PromotionHotelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionHotelPayload>
          }
          aggregate: {
            args: Prisma.PromotionHotelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromotionHotel>
          }
          groupBy: {
            args: Prisma.PromotionHotelGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromotionHotelGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromotionHotelCountArgs<ExtArgs>
            result: $Utils.Optional<PromotionHotelCountAggregateOutputType> | number
          }
        }
      }
      PromotionRoomType: {
        payload: Prisma.$PromotionRoomTypePayload<ExtArgs>
        fields: Prisma.PromotionRoomTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromotionRoomTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRoomTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromotionRoomTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRoomTypePayload>
          }
          findFirst: {
            args: Prisma.PromotionRoomTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRoomTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromotionRoomTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRoomTypePayload>
          }
          findMany: {
            args: Prisma.PromotionRoomTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRoomTypePayload>[]
          }
          create: {
            args: Prisma.PromotionRoomTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRoomTypePayload>
          }
          createMany: {
            args: Prisma.PromotionRoomTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PromotionRoomTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRoomTypePayload>[]
          }
          delete: {
            args: Prisma.PromotionRoomTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRoomTypePayload>
          }
          update: {
            args: Prisma.PromotionRoomTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRoomTypePayload>
          }
          deleteMany: {
            args: Prisma.PromotionRoomTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromotionRoomTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PromotionRoomTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRoomTypePayload>[]
          }
          upsert: {
            args: Prisma.PromotionRoomTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromotionRoomTypePayload>
          }
          aggregate: {
            args: Prisma.PromotionRoomTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromotionRoomType>
          }
          groupBy: {
            args: Prisma.PromotionRoomTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromotionRoomTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromotionRoomTypeCountArgs<ExtArgs>
            result: $Utils.Optional<PromotionRoomTypeCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    hotel?: HotelOmit
    address?: AddressOmit
    image?: ImageOmit
    amenity?: AmenityOmit
    hotelAmenity?: HotelAmenityOmit
    roomType?: RoomTypeOmit
    roomTypeAmenity?: RoomTypeAmenityOmit
    room?: RoomOmit
    roomInventory?: RoomInventoryOmit
    roomPrice?: RoomPriceOmit
    user?: UserOmit
    role?: RoleOmit
    booking?: BookingOmit
    payment?: PaymentOmit
    transaction?: TransactionOmit
    review?: ReviewOmit
    promotion?: PromotionOmit
    cancellationPolicy?: CancellationPolicyOmit
    cancellation?: CancellationOmit
    promotionHotel?: PromotionHotelOmit
    promotionRoomType?: PromotionRoomTypeOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type HotelCountOutputType
   */

  export type HotelCountOutputType = {
    images: number
    amenities: number
    roomTypes: number
    rooms: number
    bookings: number
    reviews: number
    inventory: number
    prices: number
    policies: number
    PromotionHotel: number
  }

  export type HotelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | HotelCountOutputTypeCountImagesArgs
    amenities?: boolean | HotelCountOutputTypeCountAmenitiesArgs
    roomTypes?: boolean | HotelCountOutputTypeCountRoomTypesArgs
    rooms?: boolean | HotelCountOutputTypeCountRoomsArgs
    bookings?: boolean | HotelCountOutputTypeCountBookingsArgs
    reviews?: boolean | HotelCountOutputTypeCountReviewsArgs
    inventory?: boolean | HotelCountOutputTypeCountInventoryArgs
    prices?: boolean | HotelCountOutputTypeCountPricesArgs
    policies?: boolean | HotelCountOutputTypeCountPoliciesArgs
    PromotionHotel?: boolean | HotelCountOutputTypeCountPromotionHotelArgs
  }

  // Custom InputTypes
  /**
   * HotelCountOutputType without action
   */
  export type HotelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCountOutputType
     */
    select?: HotelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HotelCountOutputType without action
   */
  export type HotelCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageWhereInput
  }

  /**
   * HotelCountOutputType without action
   */
  export type HotelCountOutputTypeCountAmenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelAmenityWhereInput
  }

  /**
   * HotelCountOutputType without action
   */
  export type HotelCountOutputTypeCountRoomTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomTypeWhereInput
  }

  /**
   * HotelCountOutputType without action
   */
  export type HotelCountOutputTypeCountRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
  }

  /**
   * HotelCountOutputType without action
   */
  export type HotelCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * HotelCountOutputType without action
   */
  export type HotelCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * HotelCountOutputType without action
   */
  export type HotelCountOutputTypeCountInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomInventoryWhereInput
  }

  /**
   * HotelCountOutputType without action
   */
  export type HotelCountOutputTypeCountPricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomPriceWhereInput
  }

  /**
   * HotelCountOutputType without action
   */
  export type HotelCountOutputTypeCountPoliciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CancellationPolicyWhereInput
  }

  /**
   * HotelCountOutputType without action
   */
  export type HotelCountOutputTypeCountPromotionHotelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionHotelWhereInput
  }


  /**
   * Count Type AmenityCountOutputType
   */

  export type AmenityCountOutputType = {
    hotels: number
    roomTypes: number
  }

  export type AmenityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotels?: boolean | AmenityCountOutputTypeCountHotelsArgs
    roomTypes?: boolean | AmenityCountOutputTypeCountRoomTypesArgs
  }

  // Custom InputTypes
  /**
   * AmenityCountOutputType without action
   */
  export type AmenityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityCountOutputType
     */
    select?: AmenityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AmenityCountOutputType without action
   */
  export type AmenityCountOutputTypeCountHotelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelAmenityWhereInput
  }

  /**
   * AmenityCountOutputType without action
   */
  export type AmenityCountOutputTypeCountRoomTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomTypeAmenityWhereInput
  }


  /**
   * Count Type RoomTypeCountOutputType
   */

  export type RoomTypeCountOutputType = {
    images: number
    amenities: number
    rooms: number
    inventory: number
    prices: number
    bookings: number
    PromotionRoomType: number
  }

  export type RoomTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | RoomTypeCountOutputTypeCountImagesArgs
    amenities?: boolean | RoomTypeCountOutputTypeCountAmenitiesArgs
    rooms?: boolean | RoomTypeCountOutputTypeCountRoomsArgs
    inventory?: boolean | RoomTypeCountOutputTypeCountInventoryArgs
    prices?: boolean | RoomTypeCountOutputTypeCountPricesArgs
    bookings?: boolean | RoomTypeCountOutputTypeCountBookingsArgs
    PromotionRoomType?: boolean | RoomTypeCountOutputTypeCountPromotionRoomTypeArgs
  }

  // Custom InputTypes
  /**
   * RoomTypeCountOutputType without action
   */
  export type RoomTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTypeCountOutputType
     */
    select?: RoomTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoomTypeCountOutputType without action
   */
  export type RoomTypeCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageWhereInput
  }

  /**
   * RoomTypeCountOutputType without action
   */
  export type RoomTypeCountOutputTypeCountAmenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomTypeAmenityWhereInput
  }

  /**
   * RoomTypeCountOutputType without action
   */
  export type RoomTypeCountOutputTypeCountRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
  }

  /**
   * RoomTypeCountOutputType without action
   */
  export type RoomTypeCountOutputTypeCountInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomInventoryWhereInput
  }

  /**
   * RoomTypeCountOutputType without action
   */
  export type RoomTypeCountOutputTypeCountPricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomPriceWhereInput
  }

  /**
   * RoomTypeCountOutputType without action
   */
  export type RoomTypeCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * RoomTypeCountOutputType without action
   */
  export type RoomTypeCountOutputTypeCountPromotionRoomTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionRoomTypeWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    bookings: number
    reviews: number
    cancellations: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | UserCountOutputTypeCountBookingsArgs
    reviews?: boolean | UserCountOutputTypeCountReviewsArgs
    cancellations?: boolean | UserCountOutputTypeCountCancellationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCancellationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CancellationWhereInput
  }


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    users: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | RoleCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type PaymentCountOutputType
   */

  export type PaymentCountOutputType = {
    transactions: number
  }

  export type PaymentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | PaymentCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentCountOutputType
     */
    select?: PaymentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type PromotionCountOutputType
   */

  export type PromotionCountOutputType = {
    bookings: number
    PromotionHotel: number
    PromotionRoomType: number
  }

  export type PromotionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | PromotionCountOutputTypeCountBookingsArgs
    PromotionHotel?: boolean | PromotionCountOutputTypeCountPromotionHotelArgs
    PromotionRoomType?: boolean | PromotionCountOutputTypeCountPromotionRoomTypeArgs
  }

  // Custom InputTypes
  /**
   * PromotionCountOutputType without action
   */
  export type PromotionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionCountOutputType
     */
    select?: PromotionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PromotionCountOutputType without action
   */
  export type PromotionCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * PromotionCountOutputType without action
   */
  export type PromotionCountOutputTypeCountPromotionHotelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionHotelWhereInput
  }

  /**
   * PromotionCountOutputType without action
   */
  export type PromotionCountOutputTypeCountPromotionRoomTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionRoomTypeWhereInput
  }


  /**
   * Count Type CancellationPolicyCountOutputType
   */

  export type CancellationPolicyCountOutputType = {
    bookings: number
  }

  export type CancellationPolicyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | CancellationPolicyCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * CancellationPolicyCountOutputType without action
   */
  export type CancellationPolicyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationPolicyCountOutputType
     */
    select?: CancellationPolicyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CancellationPolicyCountOutputType without action
   */
  export type CancellationPolicyCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Hotel
   */

  export type AggregateHotel = {
    _count: HotelCountAggregateOutputType | null
    _avg: HotelAvgAggregateOutputType | null
    _sum: HotelSumAggregateOutputType | null
    _min: HotelMinAggregateOutputType | null
    _max: HotelMaxAggregateOutputType | null
  }

  export type HotelAvgAggregateOutputType = {
    id: number | null
    addressId: number | null
  }

  export type HotelSumAggregateOutputType = {
    id: number | null
    addressId: number | null
  }

  export type HotelMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    addressId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HotelMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    addressId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HotelCountAggregateOutputType = {
    id: number
    name: number
    description: number
    addressId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HotelAvgAggregateInputType = {
    id?: true
    addressId?: true
  }

  export type HotelSumAggregateInputType = {
    id?: true
    addressId?: true
  }

  export type HotelMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    addressId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HotelMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    addressId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HotelCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    addressId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HotelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hotel to aggregate.
     */
    where?: HotelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hotels to fetch.
     */
    orderBy?: HotelOrderByWithRelationInput | HotelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hotels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hotels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Hotels
    **/
    _count?: true | HotelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotelMaxAggregateInputType
  }

  export type GetHotelAggregateType<T extends HotelAggregateArgs> = {
        [P in keyof T & keyof AggregateHotel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotel[P]>
      : GetScalarType<T[P], AggregateHotel[P]>
  }




  export type HotelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelWhereInput
    orderBy?: HotelOrderByWithAggregationInput | HotelOrderByWithAggregationInput[]
    by: HotelScalarFieldEnum[] | HotelScalarFieldEnum
    having?: HotelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotelCountAggregateInputType | true
    _avg?: HotelAvgAggregateInputType
    _sum?: HotelSumAggregateInputType
    _min?: HotelMinAggregateInputType
    _max?: HotelMaxAggregateInputType
  }

  export type HotelGroupByOutputType = {
    id: number
    name: string
    description: string | null
    addressId: number | null
    createdAt: Date
    updatedAt: Date
    _count: HotelCountAggregateOutputType | null
    _avg: HotelAvgAggregateOutputType | null
    _sum: HotelSumAggregateOutputType | null
    _min: HotelMinAggregateOutputType | null
    _max: HotelMaxAggregateOutputType | null
  }

  type GetHotelGroupByPayload<T extends HotelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotelGroupByOutputType[P]>
            : GetScalarType<T[P], HotelGroupByOutputType[P]>
        }
      >
    >


  export type HotelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    addressId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Address?: boolean | Hotel$AddressArgs<ExtArgs>
    images?: boolean | Hotel$imagesArgs<ExtArgs>
    amenities?: boolean | Hotel$amenitiesArgs<ExtArgs>
    roomTypes?: boolean | Hotel$roomTypesArgs<ExtArgs>
    rooms?: boolean | Hotel$roomsArgs<ExtArgs>
    bookings?: boolean | Hotel$bookingsArgs<ExtArgs>
    reviews?: boolean | Hotel$reviewsArgs<ExtArgs>
    inventory?: boolean | Hotel$inventoryArgs<ExtArgs>
    prices?: boolean | Hotel$pricesArgs<ExtArgs>
    policies?: boolean | Hotel$policiesArgs<ExtArgs>
    PromotionHotel?: boolean | Hotel$PromotionHotelArgs<ExtArgs>
    _count?: boolean | HotelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotel"]>

  export type HotelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    addressId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Address?: boolean | Hotel$AddressArgs<ExtArgs>
  }, ExtArgs["result"]["hotel"]>

  export type HotelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    addressId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Address?: boolean | Hotel$AddressArgs<ExtArgs>
  }, ExtArgs["result"]["hotel"]>

  export type HotelSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    addressId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HotelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "addressId" | "createdAt" | "updatedAt", ExtArgs["result"]["hotel"]>
  export type HotelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Address?: boolean | Hotel$AddressArgs<ExtArgs>
    images?: boolean | Hotel$imagesArgs<ExtArgs>
    amenities?: boolean | Hotel$amenitiesArgs<ExtArgs>
    roomTypes?: boolean | Hotel$roomTypesArgs<ExtArgs>
    rooms?: boolean | Hotel$roomsArgs<ExtArgs>
    bookings?: boolean | Hotel$bookingsArgs<ExtArgs>
    reviews?: boolean | Hotel$reviewsArgs<ExtArgs>
    inventory?: boolean | Hotel$inventoryArgs<ExtArgs>
    prices?: boolean | Hotel$pricesArgs<ExtArgs>
    policies?: boolean | Hotel$policiesArgs<ExtArgs>
    PromotionHotel?: boolean | Hotel$PromotionHotelArgs<ExtArgs>
    _count?: boolean | HotelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HotelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Address?: boolean | Hotel$AddressArgs<ExtArgs>
  }
  export type HotelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Address?: boolean | Hotel$AddressArgs<ExtArgs>
  }

  export type $HotelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Hotel"
    objects: {
      Address: Prisma.$AddressPayload<ExtArgs> | null
      images: Prisma.$ImagePayload<ExtArgs>[]
      amenities: Prisma.$HotelAmenityPayload<ExtArgs>[]
      roomTypes: Prisma.$RoomTypePayload<ExtArgs>[]
      rooms: Prisma.$RoomPayload<ExtArgs>[]
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      inventory: Prisma.$RoomInventoryPayload<ExtArgs>[]
      prices: Prisma.$RoomPricePayload<ExtArgs>[]
      policies: Prisma.$CancellationPolicyPayload<ExtArgs>[]
      PromotionHotel: Prisma.$PromotionHotelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      addressId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["hotel"]>
    composites: {}
  }

  type HotelGetPayload<S extends boolean | null | undefined | HotelDefaultArgs> = $Result.GetResult<Prisma.$HotelPayload, S>

  type HotelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HotelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HotelCountAggregateInputType | true
    }

  export interface HotelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Hotel'], meta: { name: 'Hotel' } }
    /**
     * Find zero or one Hotel that matches the filter.
     * @param {HotelFindUniqueArgs} args - Arguments to find a Hotel
     * @example
     * // Get one Hotel
     * const hotel = await prisma.hotel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotelFindUniqueArgs>(args: SelectSubset<T, HotelFindUniqueArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Hotel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HotelFindUniqueOrThrowArgs} args - Arguments to find a Hotel
     * @example
     * // Get one Hotel
     * const hotel = await prisma.hotel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotelFindUniqueOrThrowArgs>(args: SelectSubset<T, HotelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hotel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelFindFirstArgs} args - Arguments to find a Hotel
     * @example
     * // Get one Hotel
     * const hotel = await prisma.hotel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotelFindFirstArgs>(args?: SelectSubset<T, HotelFindFirstArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hotel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelFindFirstOrThrowArgs} args - Arguments to find a Hotel
     * @example
     * // Get one Hotel
     * const hotel = await prisma.hotel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotelFindFirstOrThrowArgs>(args?: SelectSubset<T, HotelFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Hotels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hotels
     * const hotels = await prisma.hotel.findMany()
     * 
     * // Get first 10 Hotels
     * const hotels = await prisma.hotel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hotelWithIdOnly = await prisma.hotel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HotelFindManyArgs>(args?: SelectSubset<T, HotelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Hotel.
     * @param {HotelCreateArgs} args - Arguments to create a Hotel.
     * @example
     * // Create one Hotel
     * const Hotel = await prisma.hotel.create({
     *   data: {
     *     // ... data to create a Hotel
     *   }
     * })
     * 
     */
    create<T extends HotelCreateArgs>(args: SelectSubset<T, HotelCreateArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Hotels.
     * @param {HotelCreateManyArgs} args - Arguments to create many Hotels.
     * @example
     * // Create many Hotels
     * const hotel = await prisma.hotel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotelCreateManyArgs>(args?: SelectSubset<T, HotelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Hotels and returns the data saved in the database.
     * @param {HotelCreateManyAndReturnArgs} args - Arguments to create many Hotels.
     * @example
     * // Create many Hotels
     * const hotel = await prisma.hotel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Hotels and only return the `id`
     * const hotelWithIdOnly = await prisma.hotel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HotelCreateManyAndReturnArgs>(args?: SelectSubset<T, HotelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Hotel.
     * @param {HotelDeleteArgs} args - Arguments to delete one Hotel.
     * @example
     * // Delete one Hotel
     * const Hotel = await prisma.hotel.delete({
     *   where: {
     *     // ... filter to delete one Hotel
     *   }
     * })
     * 
     */
    delete<T extends HotelDeleteArgs>(args: SelectSubset<T, HotelDeleteArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Hotel.
     * @param {HotelUpdateArgs} args - Arguments to update one Hotel.
     * @example
     * // Update one Hotel
     * const hotel = await prisma.hotel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotelUpdateArgs>(args: SelectSubset<T, HotelUpdateArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Hotels.
     * @param {HotelDeleteManyArgs} args - Arguments to filter Hotels to delete.
     * @example
     * // Delete a few Hotels
     * const { count } = await prisma.hotel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotelDeleteManyArgs>(args?: SelectSubset<T, HotelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hotels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hotels
     * const hotel = await prisma.hotel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotelUpdateManyArgs>(args: SelectSubset<T, HotelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hotels and returns the data updated in the database.
     * @param {HotelUpdateManyAndReturnArgs} args - Arguments to update many Hotels.
     * @example
     * // Update many Hotels
     * const hotel = await prisma.hotel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Hotels and only return the `id`
     * const hotelWithIdOnly = await prisma.hotel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HotelUpdateManyAndReturnArgs>(args: SelectSubset<T, HotelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Hotel.
     * @param {HotelUpsertArgs} args - Arguments to update or create a Hotel.
     * @example
     * // Update or create a Hotel
     * const hotel = await prisma.hotel.upsert({
     *   create: {
     *     // ... data to create a Hotel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hotel we want to update
     *   }
     * })
     */
    upsert<T extends HotelUpsertArgs>(args: SelectSubset<T, HotelUpsertArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Hotels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCountArgs} args - Arguments to filter Hotels to count.
     * @example
     * // Count the number of Hotels
     * const count = await prisma.hotel.count({
     *   where: {
     *     // ... the filter for the Hotels we want to count
     *   }
     * })
    **/
    count<T extends HotelCountArgs>(
      args?: Subset<T, HotelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hotel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotelAggregateArgs>(args: Subset<T, HotelAggregateArgs>): Prisma.PrismaPromise<GetHotelAggregateType<T>>

    /**
     * Group by Hotel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotelGroupByArgs['orderBy'] }
        : { orderBy?: HotelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Hotel model
   */
  readonly fields: HotelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Hotel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Address<T extends Hotel$AddressArgs<ExtArgs> = {}>(args?: Subset<T, Hotel$AddressArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    images<T extends Hotel$imagesArgs<ExtArgs> = {}>(args?: Subset<T, Hotel$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    amenities<T extends Hotel$amenitiesArgs<ExtArgs> = {}>(args?: Subset<T, Hotel$amenitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelAmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roomTypes<T extends Hotel$roomTypesArgs<ExtArgs> = {}>(args?: Subset<T, Hotel$roomTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rooms<T extends Hotel$roomsArgs<ExtArgs> = {}>(args?: Subset<T, Hotel$roomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookings<T extends Hotel$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Hotel$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends Hotel$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Hotel$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventory<T extends Hotel$inventoryArgs<ExtArgs> = {}>(args?: Subset<T, Hotel$inventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomInventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    prices<T extends Hotel$pricesArgs<ExtArgs> = {}>(args?: Subset<T, Hotel$pricesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPricePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    policies<T extends Hotel$policiesArgs<ExtArgs> = {}>(args?: Subset<T, Hotel$policiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CancellationPolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PromotionHotel<T extends Hotel$PromotionHotelArgs<ExtArgs> = {}>(args?: Subset<T, Hotel$PromotionHotelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionHotelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Hotel model
   */
  interface HotelFieldRefs {
    readonly id: FieldRef<"Hotel", 'Int'>
    readonly name: FieldRef<"Hotel", 'String'>
    readonly description: FieldRef<"Hotel", 'String'>
    readonly addressId: FieldRef<"Hotel", 'Int'>
    readonly createdAt: FieldRef<"Hotel", 'DateTime'>
    readonly updatedAt: FieldRef<"Hotel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Hotel findUnique
   */
  export type HotelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter, which Hotel to fetch.
     */
    where: HotelWhereUniqueInput
  }

  /**
   * Hotel findUniqueOrThrow
   */
  export type HotelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter, which Hotel to fetch.
     */
    where: HotelWhereUniqueInput
  }

  /**
   * Hotel findFirst
   */
  export type HotelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter, which Hotel to fetch.
     */
    where?: HotelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hotels to fetch.
     */
    orderBy?: HotelOrderByWithRelationInput | HotelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hotels.
     */
    cursor?: HotelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hotels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hotels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hotels.
     */
    distinct?: HotelScalarFieldEnum | HotelScalarFieldEnum[]
  }

  /**
   * Hotel findFirstOrThrow
   */
  export type HotelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter, which Hotel to fetch.
     */
    where?: HotelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hotels to fetch.
     */
    orderBy?: HotelOrderByWithRelationInput | HotelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hotels.
     */
    cursor?: HotelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hotels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hotels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hotels.
     */
    distinct?: HotelScalarFieldEnum | HotelScalarFieldEnum[]
  }

  /**
   * Hotel findMany
   */
  export type HotelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter, which Hotels to fetch.
     */
    where?: HotelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hotels to fetch.
     */
    orderBy?: HotelOrderByWithRelationInput | HotelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Hotels.
     */
    cursor?: HotelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hotels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hotels.
     */
    skip?: number
    distinct?: HotelScalarFieldEnum | HotelScalarFieldEnum[]
  }

  /**
   * Hotel create
   */
  export type HotelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * The data needed to create a Hotel.
     */
    data: XOR<HotelCreateInput, HotelUncheckedCreateInput>
  }

  /**
   * Hotel createMany
   */
  export type HotelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Hotels.
     */
    data: HotelCreateManyInput | HotelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Hotel createManyAndReturn
   */
  export type HotelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * The data used to create many Hotels.
     */
    data: HotelCreateManyInput | HotelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Hotel update
   */
  export type HotelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * The data needed to update a Hotel.
     */
    data: XOR<HotelUpdateInput, HotelUncheckedUpdateInput>
    /**
     * Choose, which Hotel to update.
     */
    where: HotelWhereUniqueInput
  }

  /**
   * Hotel updateMany
   */
  export type HotelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Hotels.
     */
    data: XOR<HotelUpdateManyMutationInput, HotelUncheckedUpdateManyInput>
    /**
     * Filter which Hotels to update
     */
    where?: HotelWhereInput
    /**
     * Limit how many Hotels to update.
     */
    limit?: number
  }

  /**
   * Hotel updateManyAndReturn
   */
  export type HotelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * The data used to update Hotels.
     */
    data: XOR<HotelUpdateManyMutationInput, HotelUncheckedUpdateManyInput>
    /**
     * Filter which Hotels to update
     */
    where?: HotelWhereInput
    /**
     * Limit how many Hotels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Hotel upsert
   */
  export type HotelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * The filter to search for the Hotel to update in case it exists.
     */
    where: HotelWhereUniqueInput
    /**
     * In case the Hotel found by the `where` argument doesn't exist, create a new Hotel with this data.
     */
    create: XOR<HotelCreateInput, HotelUncheckedCreateInput>
    /**
     * In case the Hotel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotelUpdateInput, HotelUncheckedUpdateInput>
  }

  /**
   * Hotel delete
   */
  export type HotelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter which Hotel to delete.
     */
    where: HotelWhereUniqueInput
  }

  /**
   * Hotel deleteMany
   */
  export type HotelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hotels to delete
     */
    where?: HotelWhereInput
    /**
     * Limit how many Hotels to delete.
     */
    limit?: number
  }

  /**
   * Hotel.Address
   */
  export type Hotel$AddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
  }

  /**
   * Hotel.images
   */
  export type Hotel$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    where?: ImageWhereInput
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    cursor?: ImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Hotel.amenities
   */
  export type Hotel$amenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenity
     */
    select?: HotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenity
     */
    omit?: HotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenityInclude<ExtArgs> | null
    where?: HotelAmenityWhereInput
    orderBy?: HotelAmenityOrderByWithRelationInput | HotelAmenityOrderByWithRelationInput[]
    cursor?: HotelAmenityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelAmenityScalarFieldEnum | HotelAmenityScalarFieldEnum[]
  }

  /**
   * Hotel.roomTypes
   */
  export type Hotel$roomTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomType
     */
    omit?: RoomTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
    where?: RoomTypeWhereInput
    orderBy?: RoomTypeOrderByWithRelationInput | RoomTypeOrderByWithRelationInput[]
    cursor?: RoomTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomTypeScalarFieldEnum | RoomTypeScalarFieldEnum[]
  }

  /**
   * Hotel.rooms
   */
  export type Hotel$roomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    cursor?: RoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Hotel.bookings
   */
  export type Hotel$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Hotel.reviews
   */
  export type Hotel$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Hotel.inventory
   */
  export type Hotel$inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomInventory
     */
    select?: RoomInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomInventory
     */
    omit?: RoomInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInventoryInclude<ExtArgs> | null
    where?: RoomInventoryWhereInput
    orderBy?: RoomInventoryOrderByWithRelationInput | RoomInventoryOrderByWithRelationInput[]
    cursor?: RoomInventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomInventoryScalarFieldEnum | RoomInventoryScalarFieldEnum[]
  }

  /**
   * Hotel.prices
   */
  export type Hotel$pricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomPrice
     */
    select?: RoomPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomPrice
     */
    omit?: RoomPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomPriceInclude<ExtArgs> | null
    where?: RoomPriceWhereInput
    orderBy?: RoomPriceOrderByWithRelationInput | RoomPriceOrderByWithRelationInput[]
    cursor?: RoomPriceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomPriceScalarFieldEnum | RoomPriceScalarFieldEnum[]
  }

  /**
   * Hotel.policies
   */
  export type Hotel$policiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationPolicy
     */
    select?: CancellationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CancellationPolicy
     */
    omit?: CancellationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationPolicyInclude<ExtArgs> | null
    where?: CancellationPolicyWhereInput
    orderBy?: CancellationPolicyOrderByWithRelationInput | CancellationPolicyOrderByWithRelationInput[]
    cursor?: CancellationPolicyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CancellationPolicyScalarFieldEnum | CancellationPolicyScalarFieldEnum[]
  }

  /**
   * Hotel.PromotionHotel
   */
  export type Hotel$PromotionHotelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionHotel
     */
    select?: PromotionHotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionHotel
     */
    omit?: PromotionHotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionHotelInclude<ExtArgs> | null
    where?: PromotionHotelWhereInput
    orderBy?: PromotionHotelOrderByWithRelationInput | PromotionHotelOrderByWithRelationInput[]
    cursor?: PromotionHotelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromotionHotelScalarFieldEnum | PromotionHotelScalarFieldEnum[]
  }

  /**
   * Hotel without action
   */
  export type HotelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
  }


  /**
   * Model Address
   */

  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null
    _avg: AddressAvgAggregateOutputType | null
    _sum: AddressSumAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  export type AddressAvgAggregateOutputType = {
    id: number | null
    latitude: number | null
    longitude: number | null
  }

  export type AddressSumAggregateOutputType = {
    id: number | null
    latitude: number | null
    longitude: number | null
  }

  export type AddressMinAggregateOutputType = {
    id: number | null
    streetAddress: string | null
    city: string | null
    stateProvince: string | null
    postalCode: string | null
    countryCode: string | null
    latitude: number | null
    longitude: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddressMaxAggregateOutputType = {
    id: number | null
    streetAddress: string | null
    city: string | null
    stateProvince: string | null
    postalCode: string | null
    countryCode: string | null
    latitude: number | null
    longitude: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddressCountAggregateOutputType = {
    id: number
    streetAddress: number
    city: number
    stateProvince: number
    postalCode: number
    countryCode: number
    latitude: number
    longitude: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AddressAvgAggregateInputType = {
    id?: true
    latitude?: true
    longitude?: true
  }

  export type AddressSumAggregateInputType = {
    id?: true
    latitude?: true
    longitude?: true
  }

  export type AddressMinAggregateInputType = {
    id?: true
    streetAddress?: true
    city?: true
    stateProvince?: true
    postalCode?: true
    countryCode?: true
    latitude?: true
    longitude?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddressMaxAggregateInputType = {
    id?: true
    streetAddress?: true
    city?: true
    stateProvince?: true
    postalCode?: true
    countryCode?: true
    latitude?: true
    longitude?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddressCountAggregateInputType = {
    id?: true
    streetAddress?: true
    city?: true
    stateProvince?: true
    postalCode?: true
    countryCode?: true
    latitude?: true
    longitude?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Address to aggregate.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    _count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AddressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AddressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }




  export type AddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithAggregationInput | AddressOrderByWithAggregationInput[]
    by: AddressScalarFieldEnum[] | AddressScalarFieldEnum
    having?: AddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCountAggregateInputType | true
    _avg?: AddressAvgAggregateInputType
    _sum?: AddressSumAggregateInputType
    _min?: AddressMinAggregateInputType
    _max?: AddressMaxAggregateInputType
  }

  export type AddressGroupByOutputType = {
    id: number
    streetAddress: string
    city: string
    stateProvince: string | null
    postalCode: string
    countryCode: string
    latitude: number | null
    longitude: number | null
    createdAt: Date
    updatedAt: Date
    _count: AddressCountAggregateOutputType | null
    _avg: AddressAvgAggregateOutputType | null
    _sum: AddressSumAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
        }
      >
    >


  export type AddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    streetAddress?: boolean
    city?: boolean
    stateProvince?: boolean
    postalCode?: boolean
    countryCode?: boolean
    latitude?: boolean
    longitude?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotel?: boolean | Address$hotelArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    streetAddress?: boolean
    city?: boolean
    stateProvince?: boolean
    postalCode?: boolean
    countryCode?: boolean
    latitude?: boolean
    longitude?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["address"]>

  export type AddressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    streetAddress?: boolean
    city?: boolean
    stateProvince?: boolean
    postalCode?: boolean
    countryCode?: boolean
    latitude?: boolean
    longitude?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["address"]>

  export type AddressSelectScalar = {
    id?: boolean
    streetAddress?: boolean
    city?: boolean
    stateProvince?: boolean
    postalCode?: boolean
    countryCode?: boolean
    latitude?: boolean
    longitude?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "streetAddress" | "city" | "stateProvince" | "postalCode" | "countryCode" | "latitude" | "longitude" | "createdAt" | "updatedAt", ExtArgs["result"]["address"]>
  export type AddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotel?: boolean | Address$hotelArgs<ExtArgs>
  }
  export type AddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AddressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Address"
    objects: {
      hotel: Prisma.$HotelPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      streetAddress: string
      city: string
      stateProvince: string | null
      postalCode: string
      countryCode: string
      latitude: number | null
      longitude: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["address"]>
    composites: {}
  }

  type AddressGetPayload<S extends boolean | null | undefined | AddressDefaultArgs> = $Result.GetResult<Prisma.$AddressPayload, S>

  type AddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddressCountAggregateInputType | true
    }

  export interface AddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Address'], meta: { name: 'Address' } }
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddressFindUniqueArgs>(args: SelectSubset<T, AddressFindUniqueArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Address that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddressFindUniqueOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddressFindUniqueOrThrowArgs>(args: SelectSubset<T, AddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddressFindFirstArgs>(args?: SelectSubset<T, AddressFindFirstArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Address that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddressFindFirstOrThrowArgs>(args?: SelectSubset<T, AddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddressFindManyArgs>(args?: SelectSubset<T, AddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
     */
    create<T extends AddressCreateArgs>(args: SelectSubset<T, AddressCreateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Addresses.
     * @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddressCreateManyArgs>(args?: SelectSubset<T, AddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Addresses and returns the data saved in the database.
     * @param {AddressCreateManyAndReturnArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AddressCreateManyAndReturnArgs>(args?: SelectSubset<T, AddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
     */
    delete<T extends AddressDeleteArgs>(args: SelectSubset<T, AddressDeleteArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddressUpdateArgs>(args: SelectSubset<T, AddressUpdateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddressDeleteManyArgs>(args?: SelectSubset<T, AddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddressUpdateManyArgs>(args: SelectSubset<T, AddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses and returns the data updated in the database.
     * @param {AddressUpdateManyAndReturnArgs} args - Arguments to update many Addresses.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AddressUpdateManyAndReturnArgs>(args: SelectSubset<T, AddressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
     */
    upsert<T extends AddressUpsertArgs>(args: SelectSubset<T, AddressUpsertArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): Prisma.PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Address model
   */
  readonly fields: AddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hotel<T extends Address$hotelArgs<ExtArgs> = {}>(args?: Subset<T, Address$hotelArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Address model
   */
  interface AddressFieldRefs {
    readonly id: FieldRef<"Address", 'Int'>
    readonly streetAddress: FieldRef<"Address", 'String'>
    readonly city: FieldRef<"Address", 'String'>
    readonly stateProvince: FieldRef<"Address", 'String'>
    readonly postalCode: FieldRef<"Address", 'String'>
    readonly countryCode: FieldRef<"Address", 'String'>
    readonly latitude: FieldRef<"Address", 'Float'>
    readonly longitude: FieldRef<"Address", 'Float'>
    readonly createdAt: FieldRef<"Address", 'DateTime'>
    readonly updatedAt: FieldRef<"Address", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Address findUnique
   */
  export type AddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findUniqueOrThrow
   */
  export type AddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findFirst
   */
  export type AddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findFirstOrThrow
   */
  export type AddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findMany
   */
  export type AddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address create
   */
  export type AddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to create a Address.
     */
    data: XOR<AddressCreateInput, AddressUncheckedCreateInput>
  }

  /**
   * Address createMany
   */
  export type AddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Address createManyAndReturn
   */
  export type AddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Address update
   */
  export type AddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to update a Address.
     */
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
    /**
     * Choose, which Address to update.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
  }

  /**
   * Address updateManyAndReturn
   */
  export type AddressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
  }

  /**
   * Address upsert
   */
  export type AddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The filter to search for the Address to update in case it exists.
     */
    where: AddressWhereUniqueInput
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
     */
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
  }

  /**
   * Address delete
   */
  export type AddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter which Address to delete.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Addresses to delete
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to delete.
     */
    limit?: number
  }

  /**
   * Address.hotel
   */
  export type Address$hotelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    where?: HotelWhereInput
  }

  /**
   * Address without action
   */
  export type AddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
  }


  /**
   * Model Image
   */

  export type AggregateImage = {
    _count: ImageCountAggregateOutputType | null
    _avg: ImageAvgAggregateOutputType | null
    _sum: ImageSumAggregateOutputType | null
    _min: ImageMinAggregateOutputType | null
    _max: ImageMaxAggregateOutputType | null
  }

  export type ImageAvgAggregateOutputType = {
    id: number | null
    order: number | null
    hotelId: number | null
    roomTypeId: number | null
  }

  export type ImageSumAggregateOutputType = {
    id: number | null
    order: number | null
    hotelId: number | null
    roomTypeId: number | null
  }

  export type ImageMinAggregateOutputType = {
    id: number | null
    url: string | null
    altText: string | null
    order: number | null
    hotelId: number | null
    roomTypeId: number | null
    createdAt: Date | null
  }

  export type ImageMaxAggregateOutputType = {
    id: number | null
    url: string | null
    altText: string | null
    order: number | null
    hotelId: number | null
    roomTypeId: number | null
    createdAt: Date | null
  }

  export type ImageCountAggregateOutputType = {
    id: number
    url: number
    altText: number
    order: number
    hotelId: number
    roomTypeId: number
    createdAt: number
    _all: number
  }


  export type ImageAvgAggregateInputType = {
    id?: true
    order?: true
    hotelId?: true
    roomTypeId?: true
  }

  export type ImageSumAggregateInputType = {
    id?: true
    order?: true
    hotelId?: true
    roomTypeId?: true
  }

  export type ImageMinAggregateInputType = {
    id?: true
    url?: true
    altText?: true
    order?: true
    hotelId?: true
    roomTypeId?: true
    createdAt?: true
  }

  export type ImageMaxAggregateInputType = {
    id?: true
    url?: true
    altText?: true
    order?: true
    hotelId?: true
    roomTypeId?: true
    createdAt?: true
  }

  export type ImageCountAggregateInputType = {
    id?: true
    url?: true
    altText?: true
    order?: true
    hotelId?: true
    roomTypeId?: true
    createdAt?: true
    _all?: true
  }

  export type ImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Image to aggregate.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Images
    **/
    _count?: true | ImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImageMaxAggregateInputType
  }

  export type GetImageAggregateType<T extends ImageAggregateArgs> = {
        [P in keyof T & keyof AggregateImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImage[P]>
      : GetScalarType<T[P], AggregateImage[P]>
  }




  export type ImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageWhereInput
    orderBy?: ImageOrderByWithAggregationInput | ImageOrderByWithAggregationInput[]
    by: ImageScalarFieldEnum[] | ImageScalarFieldEnum
    having?: ImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImageCountAggregateInputType | true
    _avg?: ImageAvgAggregateInputType
    _sum?: ImageSumAggregateInputType
    _min?: ImageMinAggregateInputType
    _max?: ImageMaxAggregateInputType
  }

  export type ImageGroupByOutputType = {
    id: number
    url: string
    altText: string | null
    order: number | null
    hotelId: number | null
    roomTypeId: number | null
    createdAt: Date
    _count: ImageCountAggregateOutputType | null
    _avg: ImageAvgAggregateOutputType | null
    _sum: ImageSumAggregateOutputType | null
    _min: ImageMinAggregateOutputType | null
    _max: ImageMaxAggregateOutputType | null
  }

  type GetImageGroupByPayload<T extends ImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImageGroupByOutputType[P]>
            : GetScalarType<T[P], ImageGroupByOutputType[P]>
        }
      >
    >


  export type ImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    altText?: boolean
    order?: boolean
    hotelId?: boolean
    roomTypeId?: boolean
    createdAt?: boolean
    Hotel?: boolean | Image$HotelArgs<ExtArgs>
    RoomType?: boolean | Image$RoomTypeArgs<ExtArgs>
  }, ExtArgs["result"]["image"]>

  export type ImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    altText?: boolean
    order?: boolean
    hotelId?: boolean
    roomTypeId?: boolean
    createdAt?: boolean
    Hotel?: boolean | Image$HotelArgs<ExtArgs>
    RoomType?: boolean | Image$RoomTypeArgs<ExtArgs>
  }, ExtArgs["result"]["image"]>

  export type ImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    altText?: boolean
    order?: boolean
    hotelId?: boolean
    roomTypeId?: boolean
    createdAt?: boolean
    Hotel?: boolean | Image$HotelArgs<ExtArgs>
    RoomType?: boolean | Image$RoomTypeArgs<ExtArgs>
  }, ExtArgs["result"]["image"]>

  export type ImageSelectScalar = {
    id?: boolean
    url?: boolean
    altText?: boolean
    order?: boolean
    hotelId?: boolean
    roomTypeId?: boolean
    createdAt?: boolean
  }

  export type ImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "altText" | "order" | "hotelId" | "roomTypeId" | "createdAt", ExtArgs["result"]["image"]>
  export type ImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Hotel?: boolean | Image$HotelArgs<ExtArgs>
    RoomType?: boolean | Image$RoomTypeArgs<ExtArgs>
  }
  export type ImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Hotel?: boolean | Image$HotelArgs<ExtArgs>
    RoomType?: boolean | Image$RoomTypeArgs<ExtArgs>
  }
  export type ImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Hotel?: boolean | Image$HotelArgs<ExtArgs>
    RoomType?: boolean | Image$RoomTypeArgs<ExtArgs>
  }

  export type $ImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Image"
    objects: {
      Hotel: Prisma.$HotelPayload<ExtArgs> | null
      RoomType: Prisma.$RoomTypePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      url: string
      altText: string | null
      order: number | null
      hotelId: number | null
      roomTypeId: number | null
      createdAt: Date
    }, ExtArgs["result"]["image"]>
    composites: {}
  }

  type ImageGetPayload<S extends boolean | null | undefined | ImageDefaultArgs> = $Result.GetResult<Prisma.$ImagePayload, S>

  type ImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ImageCountAggregateInputType | true
    }

  export interface ImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Image'], meta: { name: 'Image' } }
    /**
     * Find zero or one Image that matches the filter.
     * @param {ImageFindUniqueArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImageFindUniqueArgs>(args: SelectSubset<T, ImageFindUniqueArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Image that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ImageFindUniqueOrThrowArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImageFindUniqueOrThrowArgs>(args: SelectSubset<T, ImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Image that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindFirstArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImageFindFirstArgs>(args?: SelectSubset<T, ImageFindFirstArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Image that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindFirstOrThrowArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImageFindFirstOrThrowArgs>(args?: SelectSubset<T, ImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Images
     * const images = await prisma.image.findMany()
     * 
     * // Get first 10 Images
     * const images = await prisma.image.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const imageWithIdOnly = await prisma.image.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImageFindManyArgs>(args?: SelectSubset<T, ImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Image.
     * @param {ImageCreateArgs} args - Arguments to create a Image.
     * @example
     * // Create one Image
     * const Image = await prisma.image.create({
     *   data: {
     *     // ... data to create a Image
     *   }
     * })
     * 
     */
    create<T extends ImageCreateArgs>(args: SelectSubset<T, ImageCreateArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Images.
     * @param {ImageCreateManyArgs} args - Arguments to create many Images.
     * @example
     * // Create many Images
     * const image = await prisma.image.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImageCreateManyArgs>(args?: SelectSubset<T, ImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Images and returns the data saved in the database.
     * @param {ImageCreateManyAndReturnArgs} args - Arguments to create many Images.
     * @example
     * // Create many Images
     * const image = await prisma.image.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Images and only return the `id`
     * const imageWithIdOnly = await prisma.image.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ImageCreateManyAndReturnArgs>(args?: SelectSubset<T, ImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Image.
     * @param {ImageDeleteArgs} args - Arguments to delete one Image.
     * @example
     * // Delete one Image
     * const Image = await prisma.image.delete({
     *   where: {
     *     // ... filter to delete one Image
     *   }
     * })
     * 
     */
    delete<T extends ImageDeleteArgs>(args: SelectSubset<T, ImageDeleteArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Image.
     * @param {ImageUpdateArgs} args - Arguments to update one Image.
     * @example
     * // Update one Image
     * const image = await prisma.image.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImageUpdateArgs>(args: SelectSubset<T, ImageUpdateArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Images.
     * @param {ImageDeleteManyArgs} args - Arguments to filter Images to delete.
     * @example
     * // Delete a few Images
     * const { count } = await prisma.image.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImageDeleteManyArgs>(args?: SelectSubset<T, ImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Images
     * const image = await prisma.image.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImageUpdateManyArgs>(args: SelectSubset<T, ImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Images and returns the data updated in the database.
     * @param {ImageUpdateManyAndReturnArgs} args - Arguments to update many Images.
     * @example
     * // Update many Images
     * const image = await prisma.image.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Images and only return the `id`
     * const imageWithIdOnly = await prisma.image.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ImageUpdateManyAndReturnArgs>(args: SelectSubset<T, ImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Image.
     * @param {ImageUpsertArgs} args - Arguments to update or create a Image.
     * @example
     * // Update or create a Image
     * const image = await prisma.image.upsert({
     *   create: {
     *     // ... data to create a Image
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Image we want to update
     *   }
     * })
     */
    upsert<T extends ImageUpsertArgs>(args: SelectSubset<T, ImageUpsertArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageCountArgs} args - Arguments to filter Images to count.
     * @example
     * // Count the number of Images
     * const count = await prisma.image.count({
     *   where: {
     *     // ... the filter for the Images we want to count
     *   }
     * })
    **/
    count<T extends ImageCountArgs>(
      args?: Subset<T, ImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImageAggregateArgs>(args: Subset<T, ImageAggregateArgs>): Prisma.PrismaPromise<GetImageAggregateType<T>>

    /**
     * Group by Image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImageGroupByArgs['orderBy'] }
        : { orderBy?: ImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Image model
   */
  readonly fields: ImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Image.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Hotel<T extends Image$HotelArgs<ExtArgs> = {}>(args?: Subset<T, Image$HotelArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    RoomType<T extends Image$RoomTypeArgs<ExtArgs> = {}>(args?: Subset<T, Image$RoomTypeArgs<ExtArgs>>): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Image model
   */
  interface ImageFieldRefs {
    readonly id: FieldRef<"Image", 'Int'>
    readonly url: FieldRef<"Image", 'String'>
    readonly altText: FieldRef<"Image", 'String'>
    readonly order: FieldRef<"Image", 'Int'>
    readonly hotelId: FieldRef<"Image", 'Int'>
    readonly roomTypeId: FieldRef<"Image", 'Int'>
    readonly createdAt: FieldRef<"Image", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Image findUnique
   */
  export type ImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image findUniqueOrThrow
   */
  export type ImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image findFirst
   */
  export type ImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Images.
     */
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Image findFirstOrThrow
   */
  export type ImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Images.
     */
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Image findMany
   */
  export type ImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Images to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Image create
   */
  export type ImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * The data needed to create a Image.
     */
    data: XOR<ImageCreateInput, ImageUncheckedCreateInput>
  }

  /**
   * Image createMany
   */
  export type ImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Images.
     */
    data: ImageCreateManyInput | ImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Image createManyAndReturn
   */
  export type ImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * The data used to create many Images.
     */
    data: ImageCreateManyInput | ImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Image update
   */
  export type ImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * The data needed to update a Image.
     */
    data: XOR<ImageUpdateInput, ImageUncheckedUpdateInput>
    /**
     * Choose, which Image to update.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image updateMany
   */
  export type ImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Images.
     */
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyInput>
    /**
     * Filter which Images to update
     */
    where?: ImageWhereInput
    /**
     * Limit how many Images to update.
     */
    limit?: number
  }

  /**
   * Image updateManyAndReturn
   */
  export type ImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * The data used to update Images.
     */
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyInput>
    /**
     * Filter which Images to update
     */
    where?: ImageWhereInput
    /**
     * Limit how many Images to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Image upsert
   */
  export type ImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * The filter to search for the Image to update in case it exists.
     */
    where: ImageWhereUniqueInput
    /**
     * In case the Image found by the `where` argument doesn't exist, create a new Image with this data.
     */
    create: XOR<ImageCreateInput, ImageUncheckedCreateInput>
    /**
     * In case the Image was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImageUpdateInput, ImageUncheckedUpdateInput>
  }

  /**
   * Image delete
   */
  export type ImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter which Image to delete.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image deleteMany
   */
  export type ImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Images to delete
     */
    where?: ImageWhereInput
    /**
     * Limit how many Images to delete.
     */
    limit?: number
  }

  /**
   * Image.Hotel
   */
  export type Image$HotelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    where?: HotelWhereInput
  }

  /**
   * Image.RoomType
   */
  export type Image$RoomTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomType
     */
    omit?: RoomTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
    where?: RoomTypeWhereInput
  }

  /**
   * Image without action
   */
  export type ImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
  }


  /**
   * Model Amenity
   */

  export type AggregateAmenity = {
    _count: AmenityCountAggregateOutputType | null
    _avg: AmenityAvgAggregateOutputType | null
    _sum: AmenitySumAggregateOutputType | null
    _min: AmenityMinAggregateOutputType | null
    _max: AmenityMaxAggregateOutputType | null
  }

  export type AmenityAvgAggregateOutputType = {
    id: number | null
  }

  export type AmenitySumAggregateOutputType = {
    id: number | null
  }

  export type AmenityMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    category: string | null
    createdAt: Date | null
  }

  export type AmenityMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    category: string | null
    createdAt: Date | null
  }

  export type AmenityCountAggregateOutputType = {
    id: number
    name: number
    description: number
    category: number
    createdAt: number
    _all: number
  }


  export type AmenityAvgAggregateInputType = {
    id?: true
  }

  export type AmenitySumAggregateInputType = {
    id?: true
  }

  export type AmenityMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    createdAt?: true
  }

  export type AmenityMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    createdAt?: true
  }

  export type AmenityCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    createdAt?: true
    _all?: true
  }

  export type AmenityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Amenity to aggregate.
     */
    where?: AmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenityOrderByWithRelationInput | AmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Amenities
    **/
    _count?: true | AmenityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AmenityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AmenitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AmenityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AmenityMaxAggregateInputType
  }

  export type GetAmenityAggregateType<T extends AmenityAggregateArgs> = {
        [P in keyof T & keyof AggregateAmenity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAmenity[P]>
      : GetScalarType<T[P], AggregateAmenity[P]>
  }




  export type AmenityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmenityWhereInput
    orderBy?: AmenityOrderByWithAggregationInput | AmenityOrderByWithAggregationInput[]
    by: AmenityScalarFieldEnum[] | AmenityScalarFieldEnum
    having?: AmenityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AmenityCountAggregateInputType | true
    _avg?: AmenityAvgAggregateInputType
    _sum?: AmenitySumAggregateInputType
    _min?: AmenityMinAggregateInputType
    _max?: AmenityMaxAggregateInputType
  }

  export type AmenityGroupByOutputType = {
    id: number
    name: string
    description: string | null
    category: string | null
    createdAt: Date
    _count: AmenityCountAggregateOutputType | null
    _avg: AmenityAvgAggregateOutputType | null
    _sum: AmenitySumAggregateOutputType | null
    _min: AmenityMinAggregateOutputType | null
    _max: AmenityMaxAggregateOutputType | null
  }

  type GetAmenityGroupByPayload<T extends AmenityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AmenityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AmenityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AmenityGroupByOutputType[P]>
            : GetScalarType<T[P], AmenityGroupByOutputType[P]>
        }
      >
    >


  export type AmenitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    hotels?: boolean | Amenity$hotelsArgs<ExtArgs>
    roomTypes?: boolean | Amenity$roomTypesArgs<ExtArgs>
    _count?: boolean | AmenityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["amenity"]>

  export type AmenitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["amenity"]>

  export type AmenitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["amenity"]>

  export type AmenitySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
  }

  export type AmenityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "category" | "createdAt", ExtArgs["result"]["amenity"]>
  export type AmenityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotels?: boolean | Amenity$hotelsArgs<ExtArgs>
    roomTypes?: boolean | Amenity$roomTypesArgs<ExtArgs>
    _count?: boolean | AmenityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AmenityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AmenityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AmenityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Amenity"
    objects: {
      hotels: Prisma.$HotelAmenityPayload<ExtArgs>[]
      roomTypes: Prisma.$RoomTypeAmenityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      category: string | null
      createdAt: Date
    }, ExtArgs["result"]["amenity"]>
    composites: {}
  }

  type AmenityGetPayload<S extends boolean | null | undefined | AmenityDefaultArgs> = $Result.GetResult<Prisma.$AmenityPayload, S>

  type AmenityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AmenityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AmenityCountAggregateInputType | true
    }

  export interface AmenityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Amenity'], meta: { name: 'Amenity' } }
    /**
     * Find zero or one Amenity that matches the filter.
     * @param {AmenityFindUniqueArgs} args - Arguments to find a Amenity
     * @example
     * // Get one Amenity
     * const amenity = await prisma.amenity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AmenityFindUniqueArgs>(args: SelectSubset<T, AmenityFindUniqueArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Amenity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AmenityFindUniqueOrThrowArgs} args - Arguments to find a Amenity
     * @example
     * // Get one Amenity
     * const amenity = await prisma.amenity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AmenityFindUniqueOrThrowArgs>(args: SelectSubset<T, AmenityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Amenity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityFindFirstArgs} args - Arguments to find a Amenity
     * @example
     * // Get one Amenity
     * const amenity = await prisma.amenity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AmenityFindFirstArgs>(args?: SelectSubset<T, AmenityFindFirstArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Amenity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityFindFirstOrThrowArgs} args - Arguments to find a Amenity
     * @example
     * // Get one Amenity
     * const amenity = await prisma.amenity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AmenityFindFirstOrThrowArgs>(args?: SelectSubset<T, AmenityFindFirstOrThrowArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Amenities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Amenities
     * const amenities = await prisma.amenity.findMany()
     * 
     * // Get first 10 Amenities
     * const amenities = await prisma.amenity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const amenityWithIdOnly = await prisma.amenity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AmenityFindManyArgs>(args?: SelectSubset<T, AmenityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Amenity.
     * @param {AmenityCreateArgs} args - Arguments to create a Amenity.
     * @example
     * // Create one Amenity
     * const Amenity = await prisma.amenity.create({
     *   data: {
     *     // ... data to create a Amenity
     *   }
     * })
     * 
     */
    create<T extends AmenityCreateArgs>(args: SelectSubset<T, AmenityCreateArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Amenities.
     * @param {AmenityCreateManyArgs} args - Arguments to create many Amenities.
     * @example
     * // Create many Amenities
     * const amenity = await prisma.amenity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AmenityCreateManyArgs>(args?: SelectSubset<T, AmenityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Amenities and returns the data saved in the database.
     * @param {AmenityCreateManyAndReturnArgs} args - Arguments to create many Amenities.
     * @example
     * // Create many Amenities
     * const amenity = await prisma.amenity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Amenities and only return the `id`
     * const amenityWithIdOnly = await prisma.amenity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AmenityCreateManyAndReturnArgs>(args?: SelectSubset<T, AmenityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Amenity.
     * @param {AmenityDeleteArgs} args - Arguments to delete one Amenity.
     * @example
     * // Delete one Amenity
     * const Amenity = await prisma.amenity.delete({
     *   where: {
     *     // ... filter to delete one Amenity
     *   }
     * })
     * 
     */
    delete<T extends AmenityDeleteArgs>(args: SelectSubset<T, AmenityDeleteArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Amenity.
     * @param {AmenityUpdateArgs} args - Arguments to update one Amenity.
     * @example
     * // Update one Amenity
     * const amenity = await prisma.amenity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AmenityUpdateArgs>(args: SelectSubset<T, AmenityUpdateArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Amenities.
     * @param {AmenityDeleteManyArgs} args - Arguments to filter Amenities to delete.
     * @example
     * // Delete a few Amenities
     * const { count } = await prisma.amenity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AmenityDeleteManyArgs>(args?: SelectSubset<T, AmenityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Amenities
     * const amenity = await prisma.amenity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AmenityUpdateManyArgs>(args: SelectSubset<T, AmenityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Amenities and returns the data updated in the database.
     * @param {AmenityUpdateManyAndReturnArgs} args - Arguments to update many Amenities.
     * @example
     * // Update many Amenities
     * const amenity = await prisma.amenity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Amenities and only return the `id`
     * const amenityWithIdOnly = await prisma.amenity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AmenityUpdateManyAndReturnArgs>(args: SelectSubset<T, AmenityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Amenity.
     * @param {AmenityUpsertArgs} args - Arguments to update or create a Amenity.
     * @example
     * // Update or create a Amenity
     * const amenity = await prisma.amenity.upsert({
     *   create: {
     *     // ... data to create a Amenity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Amenity we want to update
     *   }
     * })
     */
    upsert<T extends AmenityUpsertArgs>(args: SelectSubset<T, AmenityUpsertArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityCountArgs} args - Arguments to filter Amenities to count.
     * @example
     * // Count the number of Amenities
     * const count = await prisma.amenity.count({
     *   where: {
     *     // ... the filter for the Amenities we want to count
     *   }
     * })
    **/
    count<T extends AmenityCountArgs>(
      args?: Subset<T, AmenityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AmenityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Amenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AmenityAggregateArgs>(args: Subset<T, AmenityAggregateArgs>): Prisma.PrismaPromise<GetAmenityAggregateType<T>>

    /**
     * Group by Amenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AmenityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AmenityGroupByArgs['orderBy'] }
        : { orderBy?: AmenityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AmenityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAmenityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Amenity model
   */
  readonly fields: AmenityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Amenity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AmenityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hotels<T extends Amenity$hotelsArgs<ExtArgs> = {}>(args?: Subset<T, Amenity$hotelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelAmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roomTypes<T extends Amenity$roomTypesArgs<ExtArgs> = {}>(args?: Subset<T, Amenity$roomTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomTypeAmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Amenity model
   */
  interface AmenityFieldRefs {
    readonly id: FieldRef<"Amenity", 'Int'>
    readonly name: FieldRef<"Amenity", 'String'>
    readonly description: FieldRef<"Amenity", 'String'>
    readonly category: FieldRef<"Amenity", 'String'>
    readonly createdAt: FieldRef<"Amenity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Amenity findUnique
   */
  export type AmenityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter, which Amenity to fetch.
     */
    where: AmenityWhereUniqueInput
  }

  /**
   * Amenity findUniqueOrThrow
   */
  export type AmenityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter, which Amenity to fetch.
     */
    where: AmenityWhereUniqueInput
  }

  /**
   * Amenity findFirst
   */
  export type AmenityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter, which Amenity to fetch.
     */
    where?: AmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenityOrderByWithRelationInput | AmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Amenities.
     */
    cursor?: AmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Amenities.
     */
    distinct?: AmenityScalarFieldEnum | AmenityScalarFieldEnum[]
  }

  /**
   * Amenity findFirstOrThrow
   */
  export type AmenityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter, which Amenity to fetch.
     */
    where?: AmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenityOrderByWithRelationInput | AmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Amenities.
     */
    cursor?: AmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Amenities.
     */
    distinct?: AmenityScalarFieldEnum | AmenityScalarFieldEnum[]
  }

  /**
   * Amenity findMany
   */
  export type AmenityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter, which Amenities to fetch.
     */
    where?: AmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenityOrderByWithRelationInput | AmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Amenities.
     */
    cursor?: AmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    distinct?: AmenityScalarFieldEnum | AmenityScalarFieldEnum[]
  }

  /**
   * Amenity create
   */
  export type AmenityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * The data needed to create a Amenity.
     */
    data: XOR<AmenityCreateInput, AmenityUncheckedCreateInput>
  }

  /**
   * Amenity createMany
   */
  export type AmenityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Amenities.
     */
    data: AmenityCreateManyInput | AmenityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Amenity createManyAndReturn
   */
  export type AmenityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * The data used to create many Amenities.
     */
    data: AmenityCreateManyInput | AmenityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Amenity update
   */
  export type AmenityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * The data needed to update a Amenity.
     */
    data: XOR<AmenityUpdateInput, AmenityUncheckedUpdateInput>
    /**
     * Choose, which Amenity to update.
     */
    where: AmenityWhereUniqueInput
  }

  /**
   * Amenity updateMany
   */
  export type AmenityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Amenities.
     */
    data: XOR<AmenityUpdateManyMutationInput, AmenityUncheckedUpdateManyInput>
    /**
     * Filter which Amenities to update
     */
    where?: AmenityWhereInput
    /**
     * Limit how many Amenities to update.
     */
    limit?: number
  }

  /**
   * Amenity updateManyAndReturn
   */
  export type AmenityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * The data used to update Amenities.
     */
    data: XOR<AmenityUpdateManyMutationInput, AmenityUncheckedUpdateManyInput>
    /**
     * Filter which Amenities to update
     */
    where?: AmenityWhereInput
    /**
     * Limit how many Amenities to update.
     */
    limit?: number
  }

  /**
   * Amenity upsert
   */
  export type AmenityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * The filter to search for the Amenity to update in case it exists.
     */
    where: AmenityWhereUniqueInput
    /**
     * In case the Amenity found by the `where` argument doesn't exist, create a new Amenity with this data.
     */
    create: XOR<AmenityCreateInput, AmenityUncheckedCreateInput>
    /**
     * In case the Amenity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AmenityUpdateInput, AmenityUncheckedUpdateInput>
  }

  /**
   * Amenity delete
   */
  export type AmenityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter which Amenity to delete.
     */
    where: AmenityWhereUniqueInput
  }

  /**
   * Amenity deleteMany
   */
  export type AmenityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Amenities to delete
     */
    where?: AmenityWhereInput
    /**
     * Limit how many Amenities to delete.
     */
    limit?: number
  }

  /**
   * Amenity.hotels
   */
  export type Amenity$hotelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenity
     */
    select?: HotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenity
     */
    omit?: HotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenityInclude<ExtArgs> | null
    where?: HotelAmenityWhereInput
    orderBy?: HotelAmenityOrderByWithRelationInput | HotelAmenityOrderByWithRelationInput[]
    cursor?: HotelAmenityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HotelAmenityScalarFieldEnum | HotelAmenityScalarFieldEnum[]
  }

  /**
   * Amenity.roomTypes
   */
  export type Amenity$roomTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTypeAmenity
     */
    select?: RoomTypeAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomTypeAmenity
     */
    omit?: RoomTypeAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeAmenityInclude<ExtArgs> | null
    where?: RoomTypeAmenityWhereInput
    orderBy?: RoomTypeAmenityOrderByWithRelationInput | RoomTypeAmenityOrderByWithRelationInput[]
    cursor?: RoomTypeAmenityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomTypeAmenityScalarFieldEnum | RoomTypeAmenityScalarFieldEnum[]
  }

  /**
   * Amenity without action
   */
  export type AmenityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
  }


  /**
   * Model HotelAmenity
   */

  export type AggregateHotelAmenity = {
    _count: HotelAmenityCountAggregateOutputType | null
    _avg: HotelAmenityAvgAggregateOutputType | null
    _sum: HotelAmenitySumAggregateOutputType | null
    _min: HotelAmenityMinAggregateOutputType | null
    _max: HotelAmenityMaxAggregateOutputType | null
  }

  export type HotelAmenityAvgAggregateOutputType = {
    hotelId: number | null
    amenityId: number | null
  }

  export type HotelAmenitySumAggregateOutputType = {
    hotelId: number | null
    amenityId: number | null
  }

  export type HotelAmenityMinAggregateOutputType = {
    hotelId: number | null
    amenityId: number | null
    createdAt: Date | null
  }

  export type HotelAmenityMaxAggregateOutputType = {
    hotelId: number | null
    amenityId: number | null
    createdAt: Date | null
  }

  export type HotelAmenityCountAggregateOutputType = {
    hotelId: number
    amenityId: number
    details: number
    createdAt: number
    _all: number
  }


  export type HotelAmenityAvgAggregateInputType = {
    hotelId?: true
    amenityId?: true
  }

  export type HotelAmenitySumAggregateInputType = {
    hotelId?: true
    amenityId?: true
  }

  export type HotelAmenityMinAggregateInputType = {
    hotelId?: true
    amenityId?: true
    createdAt?: true
  }

  export type HotelAmenityMaxAggregateInputType = {
    hotelId?: true
    amenityId?: true
    createdAt?: true
  }

  export type HotelAmenityCountAggregateInputType = {
    hotelId?: true
    amenityId?: true
    details?: true
    createdAt?: true
    _all?: true
  }

  export type HotelAmenityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelAmenity to aggregate.
     */
    where?: HotelAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelAmenities to fetch.
     */
    orderBy?: HotelAmenityOrderByWithRelationInput | HotelAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotelAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelAmenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HotelAmenities
    **/
    _count?: true | HotelAmenityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotelAmenityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotelAmenitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotelAmenityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotelAmenityMaxAggregateInputType
  }

  export type GetHotelAmenityAggregateType<T extends HotelAmenityAggregateArgs> = {
        [P in keyof T & keyof AggregateHotelAmenity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotelAmenity[P]>
      : GetScalarType<T[P], AggregateHotelAmenity[P]>
  }




  export type HotelAmenityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelAmenityWhereInput
    orderBy?: HotelAmenityOrderByWithAggregationInput | HotelAmenityOrderByWithAggregationInput[]
    by: HotelAmenityScalarFieldEnum[] | HotelAmenityScalarFieldEnum
    having?: HotelAmenityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotelAmenityCountAggregateInputType | true
    _avg?: HotelAmenityAvgAggregateInputType
    _sum?: HotelAmenitySumAggregateInputType
    _min?: HotelAmenityMinAggregateInputType
    _max?: HotelAmenityMaxAggregateInputType
  }

  export type HotelAmenityGroupByOutputType = {
    hotelId: number
    amenityId: number
    details: JsonValue | null
    createdAt: Date
    _count: HotelAmenityCountAggregateOutputType | null
    _avg: HotelAmenityAvgAggregateOutputType | null
    _sum: HotelAmenitySumAggregateOutputType | null
    _min: HotelAmenityMinAggregateOutputType | null
    _max: HotelAmenityMaxAggregateOutputType | null
  }

  type GetHotelAmenityGroupByPayload<T extends HotelAmenityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotelAmenityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotelAmenityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotelAmenityGroupByOutputType[P]>
            : GetScalarType<T[P], HotelAmenityGroupByOutputType[P]>
        }
      >
    >


  export type HotelAmenitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    hotelId?: boolean
    amenityId?: boolean
    details?: boolean
    createdAt?: boolean
    Hotel?: boolean | HotelDefaultArgs<ExtArgs>
    Amenity?: boolean | AmenityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotelAmenity"]>

  export type HotelAmenitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    hotelId?: boolean
    amenityId?: boolean
    details?: boolean
    createdAt?: boolean
    Hotel?: boolean | HotelDefaultArgs<ExtArgs>
    Amenity?: boolean | AmenityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotelAmenity"]>

  export type HotelAmenitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    hotelId?: boolean
    amenityId?: boolean
    details?: boolean
    createdAt?: boolean
    Hotel?: boolean | HotelDefaultArgs<ExtArgs>
    Amenity?: boolean | AmenityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotelAmenity"]>

  export type HotelAmenitySelectScalar = {
    hotelId?: boolean
    amenityId?: boolean
    details?: boolean
    createdAt?: boolean
  }

  export type HotelAmenityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"hotelId" | "amenityId" | "details" | "createdAt", ExtArgs["result"]["hotelAmenity"]>
  export type HotelAmenityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Hotel?: boolean | HotelDefaultArgs<ExtArgs>
    Amenity?: boolean | AmenityDefaultArgs<ExtArgs>
  }
  export type HotelAmenityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Hotel?: boolean | HotelDefaultArgs<ExtArgs>
    Amenity?: boolean | AmenityDefaultArgs<ExtArgs>
  }
  export type HotelAmenityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Hotel?: boolean | HotelDefaultArgs<ExtArgs>
    Amenity?: boolean | AmenityDefaultArgs<ExtArgs>
  }

  export type $HotelAmenityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HotelAmenity"
    objects: {
      Hotel: Prisma.$HotelPayload<ExtArgs>
      Amenity: Prisma.$AmenityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      hotelId: number
      amenityId: number
      details: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["hotelAmenity"]>
    composites: {}
  }

  type HotelAmenityGetPayload<S extends boolean | null | undefined | HotelAmenityDefaultArgs> = $Result.GetResult<Prisma.$HotelAmenityPayload, S>

  type HotelAmenityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HotelAmenityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HotelAmenityCountAggregateInputType | true
    }

  export interface HotelAmenityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HotelAmenity'], meta: { name: 'HotelAmenity' } }
    /**
     * Find zero or one HotelAmenity that matches the filter.
     * @param {HotelAmenityFindUniqueArgs} args - Arguments to find a HotelAmenity
     * @example
     * // Get one HotelAmenity
     * const hotelAmenity = await prisma.hotelAmenity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotelAmenityFindUniqueArgs>(args: SelectSubset<T, HotelAmenityFindUniqueArgs<ExtArgs>>): Prisma__HotelAmenityClient<$Result.GetResult<Prisma.$HotelAmenityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HotelAmenity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HotelAmenityFindUniqueOrThrowArgs} args - Arguments to find a HotelAmenity
     * @example
     * // Get one HotelAmenity
     * const hotelAmenity = await prisma.hotelAmenity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotelAmenityFindUniqueOrThrowArgs>(args: SelectSubset<T, HotelAmenityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotelAmenityClient<$Result.GetResult<Prisma.$HotelAmenityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HotelAmenity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelAmenityFindFirstArgs} args - Arguments to find a HotelAmenity
     * @example
     * // Get one HotelAmenity
     * const hotelAmenity = await prisma.hotelAmenity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotelAmenityFindFirstArgs>(args?: SelectSubset<T, HotelAmenityFindFirstArgs<ExtArgs>>): Prisma__HotelAmenityClient<$Result.GetResult<Prisma.$HotelAmenityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HotelAmenity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelAmenityFindFirstOrThrowArgs} args - Arguments to find a HotelAmenity
     * @example
     * // Get one HotelAmenity
     * const hotelAmenity = await prisma.hotelAmenity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotelAmenityFindFirstOrThrowArgs>(args?: SelectSubset<T, HotelAmenityFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotelAmenityClient<$Result.GetResult<Prisma.$HotelAmenityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HotelAmenities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelAmenityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HotelAmenities
     * const hotelAmenities = await prisma.hotelAmenity.findMany()
     * 
     * // Get first 10 HotelAmenities
     * const hotelAmenities = await prisma.hotelAmenity.findMany({ take: 10 })
     * 
     * // Only select the `hotelId`
     * const hotelAmenityWithHotelIdOnly = await prisma.hotelAmenity.findMany({ select: { hotelId: true } })
     * 
     */
    findMany<T extends HotelAmenityFindManyArgs>(args?: SelectSubset<T, HotelAmenityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelAmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HotelAmenity.
     * @param {HotelAmenityCreateArgs} args - Arguments to create a HotelAmenity.
     * @example
     * // Create one HotelAmenity
     * const HotelAmenity = await prisma.hotelAmenity.create({
     *   data: {
     *     // ... data to create a HotelAmenity
     *   }
     * })
     * 
     */
    create<T extends HotelAmenityCreateArgs>(args: SelectSubset<T, HotelAmenityCreateArgs<ExtArgs>>): Prisma__HotelAmenityClient<$Result.GetResult<Prisma.$HotelAmenityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HotelAmenities.
     * @param {HotelAmenityCreateManyArgs} args - Arguments to create many HotelAmenities.
     * @example
     * // Create many HotelAmenities
     * const hotelAmenity = await prisma.hotelAmenity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotelAmenityCreateManyArgs>(args?: SelectSubset<T, HotelAmenityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HotelAmenities and returns the data saved in the database.
     * @param {HotelAmenityCreateManyAndReturnArgs} args - Arguments to create many HotelAmenities.
     * @example
     * // Create many HotelAmenities
     * const hotelAmenity = await prisma.hotelAmenity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HotelAmenities and only return the `hotelId`
     * const hotelAmenityWithHotelIdOnly = await prisma.hotelAmenity.createManyAndReturn({
     *   select: { hotelId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HotelAmenityCreateManyAndReturnArgs>(args?: SelectSubset<T, HotelAmenityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelAmenityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HotelAmenity.
     * @param {HotelAmenityDeleteArgs} args - Arguments to delete one HotelAmenity.
     * @example
     * // Delete one HotelAmenity
     * const HotelAmenity = await prisma.hotelAmenity.delete({
     *   where: {
     *     // ... filter to delete one HotelAmenity
     *   }
     * })
     * 
     */
    delete<T extends HotelAmenityDeleteArgs>(args: SelectSubset<T, HotelAmenityDeleteArgs<ExtArgs>>): Prisma__HotelAmenityClient<$Result.GetResult<Prisma.$HotelAmenityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HotelAmenity.
     * @param {HotelAmenityUpdateArgs} args - Arguments to update one HotelAmenity.
     * @example
     * // Update one HotelAmenity
     * const hotelAmenity = await prisma.hotelAmenity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotelAmenityUpdateArgs>(args: SelectSubset<T, HotelAmenityUpdateArgs<ExtArgs>>): Prisma__HotelAmenityClient<$Result.GetResult<Prisma.$HotelAmenityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HotelAmenities.
     * @param {HotelAmenityDeleteManyArgs} args - Arguments to filter HotelAmenities to delete.
     * @example
     * // Delete a few HotelAmenities
     * const { count } = await prisma.hotelAmenity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotelAmenityDeleteManyArgs>(args?: SelectSubset<T, HotelAmenityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotelAmenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelAmenityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HotelAmenities
     * const hotelAmenity = await prisma.hotelAmenity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotelAmenityUpdateManyArgs>(args: SelectSubset<T, HotelAmenityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HotelAmenities and returns the data updated in the database.
     * @param {HotelAmenityUpdateManyAndReturnArgs} args - Arguments to update many HotelAmenities.
     * @example
     * // Update many HotelAmenities
     * const hotelAmenity = await prisma.hotelAmenity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HotelAmenities and only return the `hotelId`
     * const hotelAmenityWithHotelIdOnly = await prisma.hotelAmenity.updateManyAndReturn({
     *   select: { hotelId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HotelAmenityUpdateManyAndReturnArgs>(args: SelectSubset<T, HotelAmenityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelAmenityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HotelAmenity.
     * @param {HotelAmenityUpsertArgs} args - Arguments to update or create a HotelAmenity.
     * @example
     * // Update or create a HotelAmenity
     * const hotelAmenity = await prisma.hotelAmenity.upsert({
     *   create: {
     *     // ... data to create a HotelAmenity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HotelAmenity we want to update
     *   }
     * })
     */
    upsert<T extends HotelAmenityUpsertArgs>(args: SelectSubset<T, HotelAmenityUpsertArgs<ExtArgs>>): Prisma__HotelAmenityClient<$Result.GetResult<Prisma.$HotelAmenityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HotelAmenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelAmenityCountArgs} args - Arguments to filter HotelAmenities to count.
     * @example
     * // Count the number of HotelAmenities
     * const count = await prisma.hotelAmenity.count({
     *   where: {
     *     // ... the filter for the HotelAmenities we want to count
     *   }
     * })
    **/
    count<T extends HotelAmenityCountArgs>(
      args?: Subset<T, HotelAmenityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotelAmenityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HotelAmenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelAmenityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotelAmenityAggregateArgs>(args: Subset<T, HotelAmenityAggregateArgs>): Prisma.PrismaPromise<GetHotelAmenityAggregateType<T>>

    /**
     * Group by HotelAmenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelAmenityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotelAmenityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotelAmenityGroupByArgs['orderBy'] }
        : { orderBy?: HotelAmenityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotelAmenityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotelAmenityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HotelAmenity model
   */
  readonly fields: HotelAmenityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HotelAmenity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotelAmenityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Hotel<T extends HotelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HotelDefaultArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Amenity<T extends AmenityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AmenityDefaultArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HotelAmenity model
   */
  interface HotelAmenityFieldRefs {
    readonly hotelId: FieldRef<"HotelAmenity", 'Int'>
    readonly amenityId: FieldRef<"HotelAmenity", 'Int'>
    readonly details: FieldRef<"HotelAmenity", 'Json'>
    readonly createdAt: FieldRef<"HotelAmenity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HotelAmenity findUnique
   */
  export type HotelAmenityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenity
     */
    select?: HotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenity
     */
    omit?: HotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenityInclude<ExtArgs> | null
    /**
     * Filter, which HotelAmenity to fetch.
     */
    where: HotelAmenityWhereUniqueInput
  }

  /**
   * HotelAmenity findUniqueOrThrow
   */
  export type HotelAmenityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenity
     */
    select?: HotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenity
     */
    omit?: HotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenityInclude<ExtArgs> | null
    /**
     * Filter, which HotelAmenity to fetch.
     */
    where: HotelAmenityWhereUniqueInput
  }

  /**
   * HotelAmenity findFirst
   */
  export type HotelAmenityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenity
     */
    select?: HotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenity
     */
    omit?: HotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenityInclude<ExtArgs> | null
    /**
     * Filter, which HotelAmenity to fetch.
     */
    where?: HotelAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelAmenities to fetch.
     */
    orderBy?: HotelAmenityOrderByWithRelationInput | HotelAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelAmenities.
     */
    cursor?: HotelAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelAmenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelAmenities.
     */
    distinct?: HotelAmenityScalarFieldEnum | HotelAmenityScalarFieldEnum[]
  }

  /**
   * HotelAmenity findFirstOrThrow
   */
  export type HotelAmenityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenity
     */
    select?: HotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenity
     */
    omit?: HotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenityInclude<ExtArgs> | null
    /**
     * Filter, which HotelAmenity to fetch.
     */
    where?: HotelAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelAmenities to fetch.
     */
    orderBy?: HotelAmenityOrderByWithRelationInput | HotelAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HotelAmenities.
     */
    cursor?: HotelAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelAmenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HotelAmenities.
     */
    distinct?: HotelAmenityScalarFieldEnum | HotelAmenityScalarFieldEnum[]
  }

  /**
   * HotelAmenity findMany
   */
  export type HotelAmenityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenity
     */
    select?: HotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenity
     */
    omit?: HotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenityInclude<ExtArgs> | null
    /**
     * Filter, which HotelAmenities to fetch.
     */
    where?: HotelAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HotelAmenities to fetch.
     */
    orderBy?: HotelAmenityOrderByWithRelationInput | HotelAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HotelAmenities.
     */
    cursor?: HotelAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HotelAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HotelAmenities.
     */
    skip?: number
    distinct?: HotelAmenityScalarFieldEnum | HotelAmenityScalarFieldEnum[]
  }

  /**
   * HotelAmenity create
   */
  export type HotelAmenityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenity
     */
    select?: HotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenity
     */
    omit?: HotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenityInclude<ExtArgs> | null
    /**
     * The data needed to create a HotelAmenity.
     */
    data: XOR<HotelAmenityCreateInput, HotelAmenityUncheckedCreateInput>
  }

  /**
   * HotelAmenity createMany
   */
  export type HotelAmenityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HotelAmenities.
     */
    data: HotelAmenityCreateManyInput | HotelAmenityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HotelAmenity createManyAndReturn
   */
  export type HotelAmenityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenity
     */
    select?: HotelAmenitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenity
     */
    omit?: HotelAmenityOmit<ExtArgs> | null
    /**
     * The data used to create many HotelAmenities.
     */
    data: HotelAmenityCreateManyInput | HotelAmenityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HotelAmenity update
   */
  export type HotelAmenityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenity
     */
    select?: HotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenity
     */
    omit?: HotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenityInclude<ExtArgs> | null
    /**
     * The data needed to update a HotelAmenity.
     */
    data: XOR<HotelAmenityUpdateInput, HotelAmenityUncheckedUpdateInput>
    /**
     * Choose, which HotelAmenity to update.
     */
    where: HotelAmenityWhereUniqueInput
  }

  /**
   * HotelAmenity updateMany
   */
  export type HotelAmenityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HotelAmenities.
     */
    data: XOR<HotelAmenityUpdateManyMutationInput, HotelAmenityUncheckedUpdateManyInput>
    /**
     * Filter which HotelAmenities to update
     */
    where?: HotelAmenityWhereInput
    /**
     * Limit how many HotelAmenities to update.
     */
    limit?: number
  }

  /**
   * HotelAmenity updateManyAndReturn
   */
  export type HotelAmenityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenity
     */
    select?: HotelAmenitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenity
     */
    omit?: HotelAmenityOmit<ExtArgs> | null
    /**
     * The data used to update HotelAmenities.
     */
    data: XOR<HotelAmenityUpdateManyMutationInput, HotelAmenityUncheckedUpdateManyInput>
    /**
     * Filter which HotelAmenities to update
     */
    where?: HotelAmenityWhereInput
    /**
     * Limit how many HotelAmenities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * HotelAmenity upsert
   */
  export type HotelAmenityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenity
     */
    select?: HotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenity
     */
    omit?: HotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenityInclude<ExtArgs> | null
    /**
     * The filter to search for the HotelAmenity to update in case it exists.
     */
    where: HotelAmenityWhereUniqueInput
    /**
     * In case the HotelAmenity found by the `where` argument doesn't exist, create a new HotelAmenity with this data.
     */
    create: XOR<HotelAmenityCreateInput, HotelAmenityUncheckedCreateInput>
    /**
     * In case the HotelAmenity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotelAmenityUpdateInput, HotelAmenityUncheckedUpdateInput>
  }

  /**
   * HotelAmenity delete
   */
  export type HotelAmenityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenity
     */
    select?: HotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenity
     */
    omit?: HotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenityInclude<ExtArgs> | null
    /**
     * Filter which HotelAmenity to delete.
     */
    where: HotelAmenityWhereUniqueInput
  }

  /**
   * HotelAmenity deleteMany
   */
  export type HotelAmenityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HotelAmenities to delete
     */
    where?: HotelAmenityWhereInput
    /**
     * Limit how many HotelAmenities to delete.
     */
    limit?: number
  }

  /**
   * HotelAmenity without action
   */
  export type HotelAmenityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelAmenity
     */
    select?: HotelAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the HotelAmenity
     */
    omit?: HotelAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelAmenityInclude<ExtArgs> | null
  }


  /**
   * Model RoomType
   */

  export type AggregateRoomType = {
    _count: RoomTypeCountAggregateOutputType | null
    _avg: RoomTypeAvgAggregateOutputType | null
    _sum: RoomTypeSumAggregateOutputType | null
    _min: RoomTypeMinAggregateOutputType | null
    _max: RoomTypeMaxAggregateOutputType | null
  }

  export type RoomTypeAvgAggregateOutputType = {
    id: number | null
    hotelId: number | null
    maxGuests: number | null
  }

  export type RoomTypeSumAggregateOutputType = {
    id: number | null
    hotelId: number | null
    maxGuests: number | null
  }

  export type RoomTypeMinAggregateOutputType = {
    id: number | null
    hotelId: number | null
    name: string | null
    description: string | null
    maxGuests: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoomTypeMaxAggregateOutputType = {
    id: number | null
    hotelId: number | null
    name: string | null
    description: string | null
    maxGuests: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoomTypeCountAggregateOutputType = {
    id: number
    hotelId: number
    name: number
    description: number
    maxGuests: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoomTypeAvgAggregateInputType = {
    id?: true
    hotelId?: true
    maxGuests?: true
  }

  export type RoomTypeSumAggregateInputType = {
    id?: true
    hotelId?: true
    maxGuests?: true
  }

  export type RoomTypeMinAggregateInputType = {
    id?: true
    hotelId?: true
    name?: true
    description?: true
    maxGuests?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoomTypeMaxAggregateInputType = {
    id?: true
    hotelId?: true
    name?: true
    description?: true
    maxGuests?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoomTypeCountAggregateInputType = {
    id?: true
    hotelId?: true
    name?: true
    description?: true
    maxGuests?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoomTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomType to aggregate.
     */
    where?: RoomTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomTypes to fetch.
     */
    orderBy?: RoomTypeOrderByWithRelationInput | RoomTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoomTypes
    **/
    _count?: true | RoomTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoomTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoomTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomTypeMaxAggregateInputType
  }

  export type GetRoomTypeAggregateType<T extends RoomTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateRoomType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoomType[P]>
      : GetScalarType<T[P], AggregateRoomType[P]>
  }




  export type RoomTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomTypeWhereInput
    orderBy?: RoomTypeOrderByWithAggregationInput | RoomTypeOrderByWithAggregationInput[]
    by: RoomTypeScalarFieldEnum[] | RoomTypeScalarFieldEnum
    having?: RoomTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomTypeCountAggregateInputType | true
    _avg?: RoomTypeAvgAggregateInputType
    _sum?: RoomTypeSumAggregateInputType
    _min?: RoomTypeMinAggregateInputType
    _max?: RoomTypeMaxAggregateInputType
  }

  export type RoomTypeGroupByOutputType = {
    id: number
    hotelId: number
    name: string
    description: string | null
    maxGuests: number
    createdAt: Date
    updatedAt: Date
    _count: RoomTypeCountAggregateOutputType | null
    _avg: RoomTypeAvgAggregateOutputType | null
    _sum: RoomTypeSumAggregateOutputType | null
    _min: RoomTypeMinAggregateOutputType | null
    _max: RoomTypeMaxAggregateOutputType | null
  }

  type GetRoomTypeGroupByPayload<T extends RoomTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomTypeGroupByOutputType[P]>
            : GetScalarType<T[P], RoomTypeGroupByOutputType[P]>
        }
      >
    >


  export type RoomTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hotelId?: boolean
    name?: boolean
    description?: boolean
    maxGuests?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Hotel?: boolean | HotelDefaultArgs<ExtArgs>
    images?: boolean | RoomType$imagesArgs<ExtArgs>
    amenities?: boolean | RoomType$amenitiesArgs<ExtArgs>
    rooms?: boolean | RoomType$roomsArgs<ExtArgs>
    inventory?: boolean | RoomType$inventoryArgs<ExtArgs>
    prices?: boolean | RoomType$pricesArgs<ExtArgs>
    bookings?: boolean | RoomType$bookingsArgs<ExtArgs>
    PromotionRoomType?: boolean | RoomType$PromotionRoomTypeArgs<ExtArgs>
    _count?: boolean | RoomTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roomType"]>

  export type RoomTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hotelId?: boolean
    name?: boolean
    description?: boolean
    maxGuests?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Hotel?: boolean | HotelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roomType"]>

  export type RoomTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hotelId?: boolean
    name?: boolean
    description?: boolean
    maxGuests?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Hotel?: boolean | HotelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roomType"]>

  export type RoomTypeSelectScalar = {
    id?: boolean
    hotelId?: boolean
    name?: boolean
    description?: boolean
    maxGuests?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoomTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "hotelId" | "name" | "description" | "maxGuests" | "createdAt" | "updatedAt", ExtArgs["result"]["roomType"]>
  export type RoomTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Hotel?: boolean | HotelDefaultArgs<ExtArgs>
    images?: boolean | RoomType$imagesArgs<ExtArgs>
    amenities?: boolean | RoomType$amenitiesArgs<ExtArgs>
    rooms?: boolean | RoomType$roomsArgs<ExtArgs>
    inventory?: boolean | RoomType$inventoryArgs<ExtArgs>
    prices?: boolean | RoomType$pricesArgs<ExtArgs>
    bookings?: boolean | RoomType$bookingsArgs<ExtArgs>
    PromotionRoomType?: boolean | RoomType$PromotionRoomTypeArgs<ExtArgs>
    _count?: boolean | RoomTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoomTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Hotel?: boolean | HotelDefaultArgs<ExtArgs>
  }
  export type RoomTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Hotel?: boolean | HotelDefaultArgs<ExtArgs>
  }

  export type $RoomTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoomType"
    objects: {
      Hotel: Prisma.$HotelPayload<ExtArgs>
      images: Prisma.$ImagePayload<ExtArgs>[]
      amenities: Prisma.$RoomTypeAmenityPayload<ExtArgs>[]
      rooms: Prisma.$RoomPayload<ExtArgs>[]
      inventory: Prisma.$RoomInventoryPayload<ExtArgs>[]
      prices: Prisma.$RoomPricePayload<ExtArgs>[]
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      PromotionRoomType: Prisma.$PromotionRoomTypePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      hotelId: number
      name: string
      description: string | null
      /**
       * Max occupancy for this room type
       */
      maxGuests: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["roomType"]>
    composites: {}
  }

  type RoomTypeGetPayload<S extends boolean | null | undefined | RoomTypeDefaultArgs> = $Result.GetResult<Prisma.$RoomTypePayload, S>

  type RoomTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoomTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoomTypeCountAggregateInputType | true
    }

  export interface RoomTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoomType'], meta: { name: 'RoomType' } }
    /**
     * Find zero or one RoomType that matches the filter.
     * @param {RoomTypeFindUniqueArgs} args - Arguments to find a RoomType
     * @example
     * // Get one RoomType
     * const roomType = await prisma.roomType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoomTypeFindUniqueArgs>(args: SelectSubset<T, RoomTypeFindUniqueArgs<ExtArgs>>): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RoomType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoomTypeFindUniqueOrThrowArgs} args - Arguments to find a RoomType
     * @example
     * // Get one RoomType
     * const roomType = await prisma.roomType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoomTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, RoomTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoomType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTypeFindFirstArgs} args - Arguments to find a RoomType
     * @example
     * // Get one RoomType
     * const roomType = await prisma.roomType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoomTypeFindFirstArgs>(args?: SelectSubset<T, RoomTypeFindFirstArgs<ExtArgs>>): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoomType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTypeFindFirstOrThrowArgs} args - Arguments to find a RoomType
     * @example
     * // Get one RoomType
     * const roomType = await prisma.roomType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoomTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, RoomTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RoomTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoomTypes
     * const roomTypes = await prisma.roomType.findMany()
     * 
     * // Get first 10 RoomTypes
     * const roomTypes = await prisma.roomType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomTypeWithIdOnly = await prisma.roomType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoomTypeFindManyArgs>(args?: SelectSubset<T, RoomTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RoomType.
     * @param {RoomTypeCreateArgs} args - Arguments to create a RoomType.
     * @example
     * // Create one RoomType
     * const RoomType = await prisma.roomType.create({
     *   data: {
     *     // ... data to create a RoomType
     *   }
     * })
     * 
     */
    create<T extends RoomTypeCreateArgs>(args: SelectSubset<T, RoomTypeCreateArgs<ExtArgs>>): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RoomTypes.
     * @param {RoomTypeCreateManyArgs} args - Arguments to create many RoomTypes.
     * @example
     * // Create many RoomTypes
     * const roomType = await prisma.roomType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoomTypeCreateManyArgs>(args?: SelectSubset<T, RoomTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoomTypes and returns the data saved in the database.
     * @param {RoomTypeCreateManyAndReturnArgs} args - Arguments to create many RoomTypes.
     * @example
     * // Create many RoomTypes
     * const roomType = await prisma.roomType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoomTypes and only return the `id`
     * const roomTypeWithIdOnly = await prisma.roomType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoomTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, RoomTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RoomType.
     * @param {RoomTypeDeleteArgs} args - Arguments to delete one RoomType.
     * @example
     * // Delete one RoomType
     * const RoomType = await prisma.roomType.delete({
     *   where: {
     *     // ... filter to delete one RoomType
     *   }
     * })
     * 
     */
    delete<T extends RoomTypeDeleteArgs>(args: SelectSubset<T, RoomTypeDeleteArgs<ExtArgs>>): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RoomType.
     * @param {RoomTypeUpdateArgs} args - Arguments to update one RoomType.
     * @example
     * // Update one RoomType
     * const roomType = await prisma.roomType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoomTypeUpdateArgs>(args: SelectSubset<T, RoomTypeUpdateArgs<ExtArgs>>): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RoomTypes.
     * @param {RoomTypeDeleteManyArgs} args - Arguments to filter RoomTypes to delete.
     * @example
     * // Delete a few RoomTypes
     * const { count } = await prisma.roomType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoomTypeDeleteManyArgs>(args?: SelectSubset<T, RoomTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoomTypes
     * const roomType = await prisma.roomType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoomTypeUpdateManyArgs>(args: SelectSubset<T, RoomTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomTypes and returns the data updated in the database.
     * @param {RoomTypeUpdateManyAndReturnArgs} args - Arguments to update many RoomTypes.
     * @example
     * // Update many RoomTypes
     * const roomType = await prisma.roomType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RoomTypes and only return the `id`
     * const roomTypeWithIdOnly = await prisma.roomType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoomTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, RoomTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RoomType.
     * @param {RoomTypeUpsertArgs} args - Arguments to update or create a RoomType.
     * @example
     * // Update or create a RoomType
     * const roomType = await prisma.roomType.upsert({
     *   create: {
     *     // ... data to create a RoomType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoomType we want to update
     *   }
     * })
     */
    upsert<T extends RoomTypeUpsertArgs>(args: SelectSubset<T, RoomTypeUpsertArgs<ExtArgs>>): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RoomTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTypeCountArgs} args - Arguments to filter RoomTypes to count.
     * @example
     * // Count the number of RoomTypes
     * const count = await prisma.roomType.count({
     *   where: {
     *     // ... the filter for the RoomTypes we want to count
     *   }
     * })
    **/
    count<T extends RoomTypeCountArgs>(
      args?: Subset<T, RoomTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoomType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomTypeAggregateArgs>(args: Subset<T, RoomTypeAggregateArgs>): Prisma.PrismaPromise<GetRoomTypeAggregateType<T>>

    /**
     * Group by RoomType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomTypeGroupByArgs['orderBy'] }
        : { orderBy?: RoomTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoomType model
   */
  readonly fields: RoomTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoomType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Hotel<T extends HotelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HotelDefaultArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    images<T extends RoomType$imagesArgs<ExtArgs> = {}>(args?: Subset<T, RoomType$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    amenities<T extends RoomType$amenitiesArgs<ExtArgs> = {}>(args?: Subset<T, RoomType$amenitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomTypeAmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rooms<T extends RoomType$roomsArgs<ExtArgs> = {}>(args?: Subset<T, RoomType$roomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventory<T extends RoomType$inventoryArgs<ExtArgs> = {}>(args?: Subset<T, RoomType$inventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomInventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    prices<T extends RoomType$pricesArgs<ExtArgs> = {}>(args?: Subset<T, RoomType$pricesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPricePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookings<T extends RoomType$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, RoomType$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PromotionRoomType<T extends RoomType$PromotionRoomTypeArgs<ExtArgs> = {}>(args?: Subset<T, RoomType$PromotionRoomTypeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionRoomTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoomType model
   */
  interface RoomTypeFieldRefs {
    readonly id: FieldRef<"RoomType", 'Int'>
    readonly hotelId: FieldRef<"RoomType", 'Int'>
    readonly name: FieldRef<"RoomType", 'String'>
    readonly description: FieldRef<"RoomType", 'String'>
    readonly maxGuests: FieldRef<"RoomType", 'Int'>
    readonly createdAt: FieldRef<"RoomType", 'DateTime'>
    readonly updatedAt: FieldRef<"RoomType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RoomType findUnique
   */
  export type RoomTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomType
     */
    omit?: RoomTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
    /**
     * Filter, which RoomType to fetch.
     */
    where: RoomTypeWhereUniqueInput
  }

  /**
   * RoomType findUniqueOrThrow
   */
  export type RoomTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomType
     */
    omit?: RoomTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
    /**
     * Filter, which RoomType to fetch.
     */
    where: RoomTypeWhereUniqueInput
  }

  /**
   * RoomType findFirst
   */
  export type RoomTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomType
     */
    omit?: RoomTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
    /**
     * Filter, which RoomType to fetch.
     */
    where?: RoomTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomTypes to fetch.
     */
    orderBy?: RoomTypeOrderByWithRelationInput | RoomTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomTypes.
     */
    cursor?: RoomTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomTypes.
     */
    distinct?: RoomTypeScalarFieldEnum | RoomTypeScalarFieldEnum[]
  }

  /**
   * RoomType findFirstOrThrow
   */
  export type RoomTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomType
     */
    omit?: RoomTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
    /**
     * Filter, which RoomType to fetch.
     */
    where?: RoomTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomTypes to fetch.
     */
    orderBy?: RoomTypeOrderByWithRelationInput | RoomTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomTypes.
     */
    cursor?: RoomTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomTypes.
     */
    distinct?: RoomTypeScalarFieldEnum | RoomTypeScalarFieldEnum[]
  }

  /**
   * RoomType findMany
   */
  export type RoomTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomType
     */
    omit?: RoomTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
    /**
     * Filter, which RoomTypes to fetch.
     */
    where?: RoomTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomTypes to fetch.
     */
    orderBy?: RoomTypeOrderByWithRelationInput | RoomTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoomTypes.
     */
    cursor?: RoomTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomTypes.
     */
    skip?: number
    distinct?: RoomTypeScalarFieldEnum | RoomTypeScalarFieldEnum[]
  }

  /**
   * RoomType create
   */
  export type RoomTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomType
     */
    omit?: RoomTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a RoomType.
     */
    data: XOR<RoomTypeCreateInput, RoomTypeUncheckedCreateInput>
  }

  /**
   * RoomType createMany
   */
  export type RoomTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoomTypes.
     */
    data: RoomTypeCreateManyInput | RoomTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoomType createManyAndReturn
   */
  export type RoomTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoomType
     */
    omit?: RoomTypeOmit<ExtArgs> | null
    /**
     * The data used to create many RoomTypes.
     */
    data: RoomTypeCreateManyInput | RoomTypeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoomType update
   */
  export type RoomTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomType
     */
    omit?: RoomTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a RoomType.
     */
    data: XOR<RoomTypeUpdateInput, RoomTypeUncheckedUpdateInput>
    /**
     * Choose, which RoomType to update.
     */
    where: RoomTypeWhereUniqueInput
  }

  /**
   * RoomType updateMany
   */
  export type RoomTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoomTypes.
     */
    data: XOR<RoomTypeUpdateManyMutationInput, RoomTypeUncheckedUpdateManyInput>
    /**
     * Filter which RoomTypes to update
     */
    where?: RoomTypeWhereInput
    /**
     * Limit how many RoomTypes to update.
     */
    limit?: number
  }

  /**
   * RoomType updateManyAndReturn
   */
  export type RoomTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoomType
     */
    omit?: RoomTypeOmit<ExtArgs> | null
    /**
     * The data used to update RoomTypes.
     */
    data: XOR<RoomTypeUpdateManyMutationInput, RoomTypeUncheckedUpdateManyInput>
    /**
     * Filter which RoomTypes to update
     */
    where?: RoomTypeWhereInput
    /**
     * Limit how many RoomTypes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoomType upsert
   */
  export type RoomTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomType
     */
    omit?: RoomTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the RoomType to update in case it exists.
     */
    where: RoomTypeWhereUniqueInput
    /**
     * In case the RoomType found by the `where` argument doesn't exist, create a new RoomType with this data.
     */
    create: XOR<RoomTypeCreateInput, RoomTypeUncheckedCreateInput>
    /**
     * In case the RoomType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomTypeUpdateInput, RoomTypeUncheckedUpdateInput>
  }

  /**
   * RoomType delete
   */
  export type RoomTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomType
     */
    omit?: RoomTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
    /**
     * Filter which RoomType to delete.
     */
    where: RoomTypeWhereUniqueInput
  }

  /**
   * RoomType deleteMany
   */
  export type RoomTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomTypes to delete
     */
    where?: RoomTypeWhereInput
    /**
     * Limit how many RoomTypes to delete.
     */
    limit?: number
  }

  /**
   * RoomType.images
   */
  export type RoomType$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    where?: ImageWhereInput
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    cursor?: ImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * RoomType.amenities
   */
  export type RoomType$amenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTypeAmenity
     */
    select?: RoomTypeAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomTypeAmenity
     */
    omit?: RoomTypeAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeAmenityInclude<ExtArgs> | null
    where?: RoomTypeAmenityWhereInput
    orderBy?: RoomTypeAmenityOrderByWithRelationInput | RoomTypeAmenityOrderByWithRelationInput[]
    cursor?: RoomTypeAmenityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomTypeAmenityScalarFieldEnum | RoomTypeAmenityScalarFieldEnum[]
  }

  /**
   * RoomType.rooms
   */
  export type RoomType$roomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    cursor?: RoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * RoomType.inventory
   */
  export type RoomType$inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomInventory
     */
    select?: RoomInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomInventory
     */
    omit?: RoomInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInventoryInclude<ExtArgs> | null
    where?: RoomInventoryWhereInput
    orderBy?: RoomInventoryOrderByWithRelationInput | RoomInventoryOrderByWithRelationInput[]
    cursor?: RoomInventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomInventoryScalarFieldEnum | RoomInventoryScalarFieldEnum[]
  }

  /**
   * RoomType.prices
   */
  export type RoomType$pricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomPrice
     */
    select?: RoomPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomPrice
     */
    omit?: RoomPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomPriceInclude<ExtArgs> | null
    where?: RoomPriceWhereInput
    orderBy?: RoomPriceOrderByWithRelationInput | RoomPriceOrderByWithRelationInput[]
    cursor?: RoomPriceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomPriceScalarFieldEnum | RoomPriceScalarFieldEnum[]
  }

  /**
   * RoomType.bookings
   */
  export type RoomType$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * RoomType.PromotionRoomType
   */
  export type RoomType$PromotionRoomTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRoomType
     */
    select?: PromotionRoomTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRoomType
     */
    omit?: PromotionRoomTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRoomTypeInclude<ExtArgs> | null
    where?: PromotionRoomTypeWhereInput
    orderBy?: PromotionRoomTypeOrderByWithRelationInput | PromotionRoomTypeOrderByWithRelationInput[]
    cursor?: PromotionRoomTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromotionRoomTypeScalarFieldEnum | PromotionRoomTypeScalarFieldEnum[]
  }

  /**
   * RoomType without action
   */
  export type RoomTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomType
     */
    select?: RoomTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomType
     */
    omit?: RoomTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeInclude<ExtArgs> | null
  }


  /**
   * Model RoomTypeAmenity
   */

  export type AggregateRoomTypeAmenity = {
    _count: RoomTypeAmenityCountAggregateOutputType | null
    _avg: RoomTypeAmenityAvgAggregateOutputType | null
    _sum: RoomTypeAmenitySumAggregateOutputType | null
    _min: RoomTypeAmenityMinAggregateOutputType | null
    _max: RoomTypeAmenityMaxAggregateOutputType | null
  }

  export type RoomTypeAmenityAvgAggregateOutputType = {
    roomTypeId: number | null
    amenityId: number | null
  }

  export type RoomTypeAmenitySumAggregateOutputType = {
    roomTypeId: number | null
    amenityId: number | null
  }

  export type RoomTypeAmenityMinAggregateOutputType = {
    roomTypeId: number | null
    amenityId: number | null
    createdAt: Date | null
  }

  export type RoomTypeAmenityMaxAggregateOutputType = {
    roomTypeId: number | null
    amenityId: number | null
    createdAt: Date | null
  }

  export type RoomTypeAmenityCountAggregateOutputType = {
    roomTypeId: number
    amenityId: number
    createdAt: number
    _all: number
  }


  export type RoomTypeAmenityAvgAggregateInputType = {
    roomTypeId?: true
    amenityId?: true
  }

  export type RoomTypeAmenitySumAggregateInputType = {
    roomTypeId?: true
    amenityId?: true
  }

  export type RoomTypeAmenityMinAggregateInputType = {
    roomTypeId?: true
    amenityId?: true
    createdAt?: true
  }

  export type RoomTypeAmenityMaxAggregateInputType = {
    roomTypeId?: true
    amenityId?: true
    createdAt?: true
  }

  export type RoomTypeAmenityCountAggregateInputType = {
    roomTypeId?: true
    amenityId?: true
    createdAt?: true
    _all?: true
  }

  export type RoomTypeAmenityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomTypeAmenity to aggregate.
     */
    where?: RoomTypeAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomTypeAmenities to fetch.
     */
    orderBy?: RoomTypeAmenityOrderByWithRelationInput | RoomTypeAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomTypeAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomTypeAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomTypeAmenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoomTypeAmenities
    **/
    _count?: true | RoomTypeAmenityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoomTypeAmenityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoomTypeAmenitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomTypeAmenityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomTypeAmenityMaxAggregateInputType
  }

  export type GetRoomTypeAmenityAggregateType<T extends RoomTypeAmenityAggregateArgs> = {
        [P in keyof T & keyof AggregateRoomTypeAmenity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoomTypeAmenity[P]>
      : GetScalarType<T[P], AggregateRoomTypeAmenity[P]>
  }




  export type RoomTypeAmenityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomTypeAmenityWhereInput
    orderBy?: RoomTypeAmenityOrderByWithAggregationInput | RoomTypeAmenityOrderByWithAggregationInput[]
    by: RoomTypeAmenityScalarFieldEnum[] | RoomTypeAmenityScalarFieldEnum
    having?: RoomTypeAmenityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomTypeAmenityCountAggregateInputType | true
    _avg?: RoomTypeAmenityAvgAggregateInputType
    _sum?: RoomTypeAmenitySumAggregateInputType
    _min?: RoomTypeAmenityMinAggregateInputType
    _max?: RoomTypeAmenityMaxAggregateInputType
  }

  export type RoomTypeAmenityGroupByOutputType = {
    roomTypeId: number
    amenityId: number
    createdAt: Date
    _count: RoomTypeAmenityCountAggregateOutputType | null
    _avg: RoomTypeAmenityAvgAggregateOutputType | null
    _sum: RoomTypeAmenitySumAggregateOutputType | null
    _min: RoomTypeAmenityMinAggregateOutputType | null
    _max: RoomTypeAmenityMaxAggregateOutputType | null
  }

  type GetRoomTypeAmenityGroupByPayload<T extends RoomTypeAmenityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomTypeAmenityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomTypeAmenityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomTypeAmenityGroupByOutputType[P]>
            : GetScalarType<T[P], RoomTypeAmenityGroupByOutputType[P]>
        }
      >
    >


  export type RoomTypeAmenitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roomTypeId?: boolean
    amenityId?: boolean
    createdAt?: boolean
    RoomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
    Amenity?: boolean | AmenityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roomTypeAmenity"]>

  export type RoomTypeAmenitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roomTypeId?: boolean
    amenityId?: boolean
    createdAt?: boolean
    RoomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
    Amenity?: boolean | AmenityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roomTypeAmenity"]>

  export type RoomTypeAmenitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roomTypeId?: boolean
    amenityId?: boolean
    createdAt?: boolean
    RoomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
    Amenity?: boolean | AmenityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roomTypeAmenity"]>

  export type RoomTypeAmenitySelectScalar = {
    roomTypeId?: boolean
    amenityId?: boolean
    createdAt?: boolean
  }

  export type RoomTypeAmenityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"roomTypeId" | "amenityId" | "createdAt", ExtArgs["result"]["roomTypeAmenity"]>
  export type RoomTypeAmenityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RoomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
    Amenity?: boolean | AmenityDefaultArgs<ExtArgs>
  }
  export type RoomTypeAmenityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RoomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
    Amenity?: boolean | AmenityDefaultArgs<ExtArgs>
  }
  export type RoomTypeAmenityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RoomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
    Amenity?: boolean | AmenityDefaultArgs<ExtArgs>
  }

  export type $RoomTypeAmenityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoomTypeAmenity"
    objects: {
      RoomType: Prisma.$RoomTypePayload<ExtArgs>
      Amenity: Prisma.$AmenityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      roomTypeId: number
      amenityId: number
      createdAt: Date
    }, ExtArgs["result"]["roomTypeAmenity"]>
    composites: {}
  }

  type RoomTypeAmenityGetPayload<S extends boolean | null | undefined | RoomTypeAmenityDefaultArgs> = $Result.GetResult<Prisma.$RoomTypeAmenityPayload, S>

  type RoomTypeAmenityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoomTypeAmenityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoomTypeAmenityCountAggregateInputType | true
    }

  export interface RoomTypeAmenityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoomTypeAmenity'], meta: { name: 'RoomTypeAmenity' } }
    /**
     * Find zero or one RoomTypeAmenity that matches the filter.
     * @param {RoomTypeAmenityFindUniqueArgs} args - Arguments to find a RoomTypeAmenity
     * @example
     * // Get one RoomTypeAmenity
     * const roomTypeAmenity = await prisma.roomTypeAmenity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoomTypeAmenityFindUniqueArgs>(args: SelectSubset<T, RoomTypeAmenityFindUniqueArgs<ExtArgs>>): Prisma__RoomTypeAmenityClient<$Result.GetResult<Prisma.$RoomTypeAmenityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RoomTypeAmenity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoomTypeAmenityFindUniqueOrThrowArgs} args - Arguments to find a RoomTypeAmenity
     * @example
     * // Get one RoomTypeAmenity
     * const roomTypeAmenity = await prisma.roomTypeAmenity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoomTypeAmenityFindUniqueOrThrowArgs>(args: SelectSubset<T, RoomTypeAmenityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoomTypeAmenityClient<$Result.GetResult<Prisma.$RoomTypeAmenityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoomTypeAmenity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTypeAmenityFindFirstArgs} args - Arguments to find a RoomTypeAmenity
     * @example
     * // Get one RoomTypeAmenity
     * const roomTypeAmenity = await prisma.roomTypeAmenity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoomTypeAmenityFindFirstArgs>(args?: SelectSubset<T, RoomTypeAmenityFindFirstArgs<ExtArgs>>): Prisma__RoomTypeAmenityClient<$Result.GetResult<Prisma.$RoomTypeAmenityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoomTypeAmenity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTypeAmenityFindFirstOrThrowArgs} args - Arguments to find a RoomTypeAmenity
     * @example
     * // Get one RoomTypeAmenity
     * const roomTypeAmenity = await prisma.roomTypeAmenity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoomTypeAmenityFindFirstOrThrowArgs>(args?: SelectSubset<T, RoomTypeAmenityFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoomTypeAmenityClient<$Result.GetResult<Prisma.$RoomTypeAmenityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RoomTypeAmenities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTypeAmenityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoomTypeAmenities
     * const roomTypeAmenities = await prisma.roomTypeAmenity.findMany()
     * 
     * // Get first 10 RoomTypeAmenities
     * const roomTypeAmenities = await prisma.roomTypeAmenity.findMany({ take: 10 })
     * 
     * // Only select the `roomTypeId`
     * const roomTypeAmenityWithRoomTypeIdOnly = await prisma.roomTypeAmenity.findMany({ select: { roomTypeId: true } })
     * 
     */
    findMany<T extends RoomTypeAmenityFindManyArgs>(args?: SelectSubset<T, RoomTypeAmenityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomTypeAmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RoomTypeAmenity.
     * @param {RoomTypeAmenityCreateArgs} args - Arguments to create a RoomTypeAmenity.
     * @example
     * // Create one RoomTypeAmenity
     * const RoomTypeAmenity = await prisma.roomTypeAmenity.create({
     *   data: {
     *     // ... data to create a RoomTypeAmenity
     *   }
     * })
     * 
     */
    create<T extends RoomTypeAmenityCreateArgs>(args: SelectSubset<T, RoomTypeAmenityCreateArgs<ExtArgs>>): Prisma__RoomTypeAmenityClient<$Result.GetResult<Prisma.$RoomTypeAmenityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RoomTypeAmenities.
     * @param {RoomTypeAmenityCreateManyArgs} args - Arguments to create many RoomTypeAmenities.
     * @example
     * // Create many RoomTypeAmenities
     * const roomTypeAmenity = await prisma.roomTypeAmenity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoomTypeAmenityCreateManyArgs>(args?: SelectSubset<T, RoomTypeAmenityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoomTypeAmenities and returns the data saved in the database.
     * @param {RoomTypeAmenityCreateManyAndReturnArgs} args - Arguments to create many RoomTypeAmenities.
     * @example
     * // Create many RoomTypeAmenities
     * const roomTypeAmenity = await prisma.roomTypeAmenity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoomTypeAmenities and only return the `roomTypeId`
     * const roomTypeAmenityWithRoomTypeIdOnly = await prisma.roomTypeAmenity.createManyAndReturn({
     *   select: { roomTypeId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoomTypeAmenityCreateManyAndReturnArgs>(args?: SelectSubset<T, RoomTypeAmenityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomTypeAmenityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RoomTypeAmenity.
     * @param {RoomTypeAmenityDeleteArgs} args - Arguments to delete one RoomTypeAmenity.
     * @example
     * // Delete one RoomTypeAmenity
     * const RoomTypeAmenity = await prisma.roomTypeAmenity.delete({
     *   where: {
     *     // ... filter to delete one RoomTypeAmenity
     *   }
     * })
     * 
     */
    delete<T extends RoomTypeAmenityDeleteArgs>(args: SelectSubset<T, RoomTypeAmenityDeleteArgs<ExtArgs>>): Prisma__RoomTypeAmenityClient<$Result.GetResult<Prisma.$RoomTypeAmenityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RoomTypeAmenity.
     * @param {RoomTypeAmenityUpdateArgs} args - Arguments to update one RoomTypeAmenity.
     * @example
     * // Update one RoomTypeAmenity
     * const roomTypeAmenity = await prisma.roomTypeAmenity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoomTypeAmenityUpdateArgs>(args: SelectSubset<T, RoomTypeAmenityUpdateArgs<ExtArgs>>): Prisma__RoomTypeAmenityClient<$Result.GetResult<Prisma.$RoomTypeAmenityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RoomTypeAmenities.
     * @param {RoomTypeAmenityDeleteManyArgs} args - Arguments to filter RoomTypeAmenities to delete.
     * @example
     * // Delete a few RoomTypeAmenities
     * const { count } = await prisma.roomTypeAmenity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoomTypeAmenityDeleteManyArgs>(args?: SelectSubset<T, RoomTypeAmenityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomTypeAmenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTypeAmenityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoomTypeAmenities
     * const roomTypeAmenity = await prisma.roomTypeAmenity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoomTypeAmenityUpdateManyArgs>(args: SelectSubset<T, RoomTypeAmenityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomTypeAmenities and returns the data updated in the database.
     * @param {RoomTypeAmenityUpdateManyAndReturnArgs} args - Arguments to update many RoomTypeAmenities.
     * @example
     * // Update many RoomTypeAmenities
     * const roomTypeAmenity = await prisma.roomTypeAmenity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RoomTypeAmenities and only return the `roomTypeId`
     * const roomTypeAmenityWithRoomTypeIdOnly = await prisma.roomTypeAmenity.updateManyAndReturn({
     *   select: { roomTypeId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoomTypeAmenityUpdateManyAndReturnArgs>(args: SelectSubset<T, RoomTypeAmenityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomTypeAmenityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RoomTypeAmenity.
     * @param {RoomTypeAmenityUpsertArgs} args - Arguments to update or create a RoomTypeAmenity.
     * @example
     * // Update or create a RoomTypeAmenity
     * const roomTypeAmenity = await prisma.roomTypeAmenity.upsert({
     *   create: {
     *     // ... data to create a RoomTypeAmenity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoomTypeAmenity we want to update
     *   }
     * })
     */
    upsert<T extends RoomTypeAmenityUpsertArgs>(args: SelectSubset<T, RoomTypeAmenityUpsertArgs<ExtArgs>>): Prisma__RoomTypeAmenityClient<$Result.GetResult<Prisma.$RoomTypeAmenityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RoomTypeAmenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTypeAmenityCountArgs} args - Arguments to filter RoomTypeAmenities to count.
     * @example
     * // Count the number of RoomTypeAmenities
     * const count = await prisma.roomTypeAmenity.count({
     *   where: {
     *     // ... the filter for the RoomTypeAmenities we want to count
     *   }
     * })
    **/
    count<T extends RoomTypeAmenityCountArgs>(
      args?: Subset<T, RoomTypeAmenityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomTypeAmenityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoomTypeAmenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTypeAmenityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomTypeAmenityAggregateArgs>(args: Subset<T, RoomTypeAmenityAggregateArgs>): Prisma.PrismaPromise<GetRoomTypeAmenityAggregateType<T>>

    /**
     * Group by RoomTypeAmenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomTypeAmenityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomTypeAmenityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomTypeAmenityGroupByArgs['orderBy'] }
        : { orderBy?: RoomTypeAmenityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomTypeAmenityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomTypeAmenityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoomTypeAmenity model
   */
  readonly fields: RoomTypeAmenityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoomTypeAmenity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomTypeAmenityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    RoomType<T extends RoomTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomTypeDefaultArgs<ExtArgs>>): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Amenity<T extends AmenityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AmenityDefaultArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoomTypeAmenity model
   */
  interface RoomTypeAmenityFieldRefs {
    readonly roomTypeId: FieldRef<"RoomTypeAmenity", 'Int'>
    readonly amenityId: FieldRef<"RoomTypeAmenity", 'Int'>
    readonly createdAt: FieldRef<"RoomTypeAmenity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RoomTypeAmenity findUnique
   */
  export type RoomTypeAmenityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTypeAmenity
     */
    select?: RoomTypeAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomTypeAmenity
     */
    omit?: RoomTypeAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeAmenityInclude<ExtArgs> | null
    /**
     * Filter, which RoomTypeAmenity to fetch.
     */
    where: RoomTypeAmenityWhereUniqueInput
  }

  /**
   * RoomTypeAmenity findUniqueOrThrow
   */
  export type RoomTypeAmenityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTypeAmenity
     */
    select?: RoomTypeAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomTypeAmenity
     */
    omit?: RoomTypeAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeAmenityInclude<ExtArgs> | null
    /**
     * Filter, which RoomTypeAmenity to fetch.
     */
    where: RoomTypeAmenityWhereUniqueInput
  }

  /**
   * RoomTypeAmenity findFirst
   */
  export type RoomTypeAmenityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTypeAmenity
     */
    select?: RoomTypeAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomTypeAmenity
     */
    omit?: RoomTypeAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeAmenityInclude<ExtArgs> | null
    /**
     * Filter, which RoomTypeAmenity to fetch.
     */
    where?: RoomTypeAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomTypeAmenities to fetch.
     */
    orderBy?: RoomTypeAmenityOrderByWithRelationInput | RoomTypeAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomTypeAmenities.
     */
    cursor?: RoomTypeAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomTypeAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomTypeAmenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomTypeAmenities.
     */
    distinct?: RoomTypeAmenityScalarFieldEnum | RoomTypeAmenityScalarFieldEnum[]
  }

  /**
   * RoomTypeAmenity findFirstOrThrow
   */
  export type RoomTypeAmenityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTypeAmenity
     */
    select?: RoomTypeAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomTypeAmenity
     */
    omit?: RoomTypeAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeAmenityInclude<ExtArgs> | null
    /**
     * Filter, which RoomTypeAmenity to fetch.
     */
    where?: RoomTypeAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomTypeAmenities to fetch.
     */
    orderBy?: RoomTypeAmenityOrderByWithRelationInput | RoomTypeAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomTypeAmenities.
     */
    cursor?: RoomTypeAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomTypeAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomTypeAmenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomTypeAmenities.
     */
    distinct?: RoomTypeAmenityScalarFieldEnum | RoomTypeAmenityScalarFieldEnum[]
  }

  /**
   * RoomTypeAmenity findMany
   */
  export type RoomTypeAmenityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTypeAmenity
     */
    select?: RoomTypeAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomTypeAmenity
     */
    omit?: RoomTypeAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeAmenityInclude<ExtArgs> | null
    /**
     * Filter, which RoomTypeAmenities to fetch.
     */
    where?: RoomTypeAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomTypeAmenities to fetch.
     */
    orderBy?: RoomTypeAmenityOrderByWithRelationInput | RoomTypeAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoomTypeAmenities.
     */
    cursor?: RoomTypeAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomTypeAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomTypeAmenities.
     */
    skip?: number
    distinct?: RoomTypeAmenityScalarFieldEnum | RoomTypeAmenityScalarFieldEnum[]
  }

  /**
   * RoomTypeAmenity create
   */
  export type RoomTypeAmenityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTypeAmenity
     */
    select?: RoomTypeAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomTypeAmenity
     */
    omit?: RoomTypeAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeAmenityInclude<ExtArgs> | null
    /**
     * The data needed to create a RoomTypeAmenity.
     */
    data: XOR<RoomTypeAmenityCreateInput, RoomTypeAmenityUncheckedCreateInput>
  }

  /**
   * RoomTypeAmenity createMany
   */
  export type RoomTypeAmenityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoomTypeAmenities.
     */
    data: RoomTypeAmenityCreateManyInput | RoomTypeAmenityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoomTypeAmenity createManyAndReturn
   */
  export type RoomTypeAmenityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTypeAmenity
     */
    select?: RoomTypeAmenitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoomTypeAmenity
     */
    omit?: RoomTypeAmenityOmit<ExtArgs> | null
    /**
     * The data used to create many RoomTypeAmenities.
     */
    data: RoomTypeAmenityCreateManyInput | RoomTypeAmenityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeAmenityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoomTypeAmenity update
   */
  export type RoomTypeAmenityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTypeAmenity
     */
    select?: RoomTypeAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomTypeAmenity
     */
    omit?: RoomTypeAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeAmenityInclude<ExtArgs> | null
    /**
     * The data needed to update a RoomTypeAmenity.
     */
    data: XOR<RoomTypeAmenityUpdateInput, RoomTypeAmenityUncheckedUpdateInput>
    /**
     * Choose, which RoomTypeAmenity to update.
     */
    where: RoomTypeAmenityWhereUniqueInput
  }

  /**
   * RoomTypeAmenity updateMany
   */
  export type RoomTypeAmenityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoomTypeAmenities.
     */
    data: XOR<RoomTypeAmenityUpdateManyMutationInput, RoomTypeAmenityUncheckedUpdateManyInput>
    /**
     * Filter which RoomTypeAmenities to update
     */
    where?: RoomTypeAmenityWhereInput
    /**
     * Limit how many RoomTypeAmenities to update.
     */
    limit?: number
  }

  /**
   * RoomTypeAmenity updateManyAndReturn
   */
  export type RoomTypeAmenityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTypeAmenity
     */
    select?: RoomTypeAmenitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoomTypeAmenity
     */
    omit?: RoomTypeAmenityOmit<ExtArgs> | null
    /**
     * The data used to update RoomTypeAmenities.
     */
    data: XOR<RoomTypeAmenityUpdateManyMutationInput, RoomTypeAmenityUncheckedUpdateManyInput>
    /**
     * Filter which RoomTypeAmenities to update
     */
    where?: RoomTypeAmenityWhereInput
    /**
     * Limit how many RoomTypeAmenities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeAmenityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoomTypeAmenity upsert
   */
  export type RoomTypeAmenityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTypeAmenity
     */
    select?: RoomTypeAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomTypeAmenity
     */
    omit?: RoomTypeAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeAmenityInclude<ExtArgs> | null
    /**
     * The filter to search for the RoomTypeAmenity to update in case it exists.
     */
    where: RoomTypeAmenityWhereUniqueInput
    /**
     * In case the RoomTypeAmenity found by the `where` argument doesn't exist, create a new RoomTypeAmenity with this data.
     */
    create: XOR<RoomTypeAmenityCreateInput, RoomTypeAmenityUncheckedCreateInput>
    /**
     * In case the RoomTypeAmenity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomTypeAmenityUpdateInput, RoomTypeAmenityUncheckedUpdateInput>
  }

  /**
   * RoomTypeAmenity delete
   */
  export type RoomTypeAmenityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTypeAmenity
     */
    select?: RoomTypeAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomTypeAmenity
     */
    omit?: RoomTypeAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeAmenityInclude<ExtArgs> | null
    /**
     * Filter which RoomTypeAmenity to delete.
     */
    where: RoomTypeAmenityWhereUniqueInput
  }

  /**
   * RoomTypeAmenity deleteMany
   */
  export type RoomTypeAmenityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomTypeAmenities to delete
     */
    where?: RoomTypeAmenityWhereInput
    /**
     * Limit how many RoomTypeAmenities to delete.
     */
    limit?: number
  }

  /**
   * RoomTypeAmenity without action
   */
  export type RoomTypeAmenityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomTypeAmenity
     */
    select?: RoomTypeAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomTypeAmenity
     */
    omit?: RoomTypeAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomTypeAmenityInclude<ExtArgs> | null
  }


  /**
   * Model Room
   */

  export type AggregateRoom = {
    _count: RoomCountAggregateOutputType | null
    _avg: RoomAvgAggregateOutputType | null
    _sum: RoomSumAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  export type RoomAvgAggregateOutputType = {
    id: number | null
    roomTypeId: number | null
    hotelId: number | null
  }

  export type RoomSumAggregateOutputType = {
    id: number | null
    roomTypeId: number | null
    hotelId: number | null
  }

  export type RoomMinAggregateOutputType = {
    id: number | null
    roomTypeId: number | null
    roomNumber: string | null
    floor: string | null
    status: $Enums.RoomStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    hotelId: number | null
  }

  export type RoomMaxAggregateOutputType = {
    id: number | null
    roomTypeId: number | null
    roomNumber: string | null
    floor: string | null
    status: $Enums.RoomStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    hotelId: number | null
  }

  export type RoomCountAggregateOutputType = {
    id: number
    roomTypeId: number
    roomNumber: number
    floor: number
    status: number
    createdAt: number
    updatedAt: number
    hotelId: number
    _all: number
  }


  export type RoomAvgAggregateInputType = {
    id?: true
    roomTypeId?: true
    hotelId?: true
  }

  export type RoomSumAggregateInputType = {
    id?: true
    roomTypeId?: true
    hotelId?: true
  }

  export type RoomMinAggregateInputType = {
    id?: true
    roomTypeId?: true
    roomNumber?: true
    floor?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    hotelId?: true
  }

  export type RoomMaxAggregateInputType = {
    id?: true
    roomTypeId?: true
    roomNumber?: true
    floor?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    hotelId?: true
  }

  export type RoomCountAggregateInputType = {
    id?: true
    roomTypeId?: true
    roomNumber?: true
    floor?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    hotelId?: true
    _all?: true
  }

  export type RoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Room to aggregate.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rooms
    **/
    _count?: true | RoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomMaxAggregateInputType
  }

  export type GetRoomAggregateType<T extends RoomAggregateArgs> = {
        [P in keyof T & keyof AggregateRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoom[P]>
      : GetScalarType<T[P], AggregateRoom[P]>
  }




  export type RoomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithAggregationInput | RoomOrderByWithAggregationInput[]
    by: RoomScalarFieldEnum[] | RoomScalarFieldEnum
    having?: RoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomCountAggregateInputType | true
    _avg?: RoomAvgAggregateInputType
    _sum?: RoomSumAggregateInputType
    _min?: RoomMinAggregateInputType
    _max?: RoomMaxAggregateInputType
  }

  export type RoomGroupByOutputType = {
    id: number
    roomTypeId: number
    roomNumber: string
    floor: string | null
    status: $Enums.RoomStatus
    createdAt: Date
    updatedAt: Date
    hotelId: number | null
    _count: RoomCountAggregateOutputType | null
    _avg: RoomAvgAggregateOutputType | null
    _sum: RoomSumAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  type GetRoomGroupByPayload<T extends RoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomGroupByOutputType[P]>
            : GetScalarType<T[P], RoomGroupByOutputType[P]>
        }
      >
    >


  export type RoomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomTypeId?: boolean
    roomNumber?: boolean
    floor?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelId?: boolean
    RoomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
    Hotel?: boolean | Room$HotelArgs<ExtArgs>
  }, ExtArgs["result"]["room"]>

  export type RoomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomTypeId?: boolean
    roomNumber?: boolean
    floor?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelId?: boolean
    RoomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
    Hotel?: boolean | Room$HotelArgs<ExtArgs>
  }, ExtArgs["result"]["room"]>

  export type RoomSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomTypeId?: boolean
    roomNumber?: boolean
    floor?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelId?: boolean
    RoomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
    Hotel?: boolean | Room$HotelArgs<ExtArgs>
  }, ExtArgs["result"]["room"]>

  export type RoomSelectScalar = {
    id?: boolean
    roomTypeId?: boolean
    roomNumber?: boolean
    floor?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelId?: boolean
  }

  export type RoomOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roomTypeId" | "roomNumber" | "floor" | "status" | "createdAt" | "updatedAt" | "hotelId", ExtArgs["result"]["room"]>
  export type RoomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RoomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
    Hotel?: boolean | Room$HotelArgs<ExtArgs>
  }
  export type RoomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RoomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
    Hotel?: boolean | Room$HotelArgs<ExtArgs>
  }
  export type RoomIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RoomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
    Hotel?: boolean | Room$HotelArgs<ExtArgs>
  }

  export type $RoomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Room"
    objects: {
      RoomType: Prisma.$RoomTypePayload<ExtArgs>
      Hotel: Prisma.$HotelPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      roomTypeId: number
      roomNumber: string
      floor: string | null
      status: $Enums.RoomStatus
      createdAt: Date
      updatedAt: Date
      hotelId: number | null
    }, ExtArgs["result"]["room"]>
    composites: {}
  }

  type RoomGetPayload<S extends boolean | null | undefined | RoomDefaultArgs> = $Result.GetResult<Prisma.$RoomPayload, S>

  type RoomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoomFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoomCountAggregateInputType | true
    }

  export interface RoomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Room'], meta: { name: 'Room' } }
    /**
     * Find zero or one Room that matches the filter.
     * @param {RoomFindUniqueArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoomFindUniqueArgs>(args: SelectSubset<T, RoomFindUniqueArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Room that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoomFindUniqueOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoomFindUniqueOrThrowArgs>(args: SelectSubset<T, RoomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Room that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoomFindFirstArgs>(args?: SelectSubset<T, RoomFindFirstArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Room that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoomFindFirstOrThrowArgs>(args?: SelectSubset<T, RoomFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rooms
     * const rooms = await prisma.room.findMany()
     * 
     * // Get first 10 Rooms
     * const rooms = await prisma.room.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomWithIdOnly = await prisma.room.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoomFindManyArgs>(args?: SelectSubset<T, RoomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Room.
     * @param {RoomCreateArgs} args - Arguments to create a Room.
     * @example
     * // Create one Room
     * const Room = await prisma.room.create({
     *   data: {
     *     // ... data to create a Room
     *   }
     * })
     * 
     */
    create<T extends RoomCreateArgs>(args: SelectSubset<T, RoomCreateArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rooms.
     * @param {RoomCreateManyArgs} args - Arguments to create many Rooms.
     * @example
     * // Create many Rooms
     * const room = await prisma.room.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoomCreateManyArgs>(args?: SelectSubset<T, RoomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rooms and returns the data saved in the database.
     * @param {RoomCreateManyAndReturnArgs} args - Arguments to create many Rooms.
     * @example
     * // Create many Rooms
     * const room = await prisma.room.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rooms and only return the `id`
     * const roomWithIdOnly = await prisma.room.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoomCreateManyAndReturnArgs>(args?: SelectSubset<T, RoomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Room.
     * @param {RoomDeleteArgs} args - Arguments to delete one Room.
     * @example
     * // Delete one Room
     * const Room = await prisma.room.delete({
     *   where: {
     *     // ... filter to delete one Room
     *   }
     * })
     * 
     */
    delete<T extends RoomDeleteArgs>(args: SelectSubset<T, RoomDeleteArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Room.
     * @param {RoomUpdateArgs} args - Arguments to update one Room.
     * @example
     * // Update one Room
     * const room = await prisma.room.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoomUpdateArgs>(args: SelectSubset<T, RoomUpdateArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rooms.
     * @param {RoomDeleteManyArgs} args - Arguments to filter Rooms to delete.
     * @example
     * // Delete a few Rooms
     * const { count } = await prisma.room.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoomDeleteManyArgs>(args?: SelectSubset<T, RoomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rooms
     * const room = await prisma.room.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoomUpdateManyArgs>(args: SelectSubset<T, RoomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rooms and returns the data updated in the database.
     * @param {RoomUpdateManyAndReturnArgs} args - Arguments to update many Rooms.
     * @example
     * // Update many Rooms
     * const room = await prisma.room.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Rooms and only return the `id`
     * const roomWithIdOnly = await prisma.room.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoomUpdateManyAndReturnArgs>(args: SelectSubset<T, RoomUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Room.
     * @param {RoomUpsertArgs} args - Arguments to update or create a Room.
     * @example
     * // Update or create a Room
     * const room = await prisma.room.upsert({
     *   create: {
     *     // ... data to create a Room
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Room we want to update
     *   }
     * })
     */
    upsert<T extends RoomUpsertArgs>(args: SelectSubset<T, RoomUpsertArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomCountArgs} args - Arguments to filter Rooms to count.
     * @example
     * // Count the number of Rooms
     * const count = await prisma.room.count({
     *   where: {
     *     // ... the filter for the Rooms we want to count
     *   }
     * })
    **/
    count<T extends RoomCountArgs>(
      args?: Subset<T, RoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomAggregateArgs>(args: Subset<T, RoomAggregateArgs>): Prisma.PrismaPromise<GetRoomAggregateType<T>>

    /**
     * Group by Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomGroupByArgs['orderBy'] }
        : { orderBy?: RoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Room model
   */
  readonly fields: RoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Room.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    RoomType<T extends RoomTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomTypeDefaultArgs<ExtArgs>>): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Hotel<T extends Room$HotelArgs<ExtArgs> = {}>(args?: Subset<T, Room$HotelArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Room model
   */
  interface RoomFieldRefs {
    readonly id: FieldRef<"Room", 'Int'>
    readonly roomTypeId: FieldRef<"Room", 'Int'>
    readonly roomNumber: FieldRef<"Room", 'String'>
    readonly floor: FieldRef<"Room", 'String'>
    readonly status: FieldRef<"Room", 'RoomStatus'>
    readonly createdAt: FieldRef<"Room", 'DateTime'>
    readonly updatedAt: FieldRef<"Room", 'DateTime'>
    readonly hotelId: FieldRef<"Room", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Room findUnique
   */
  export type RoomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room findUniqueOrThrow
   */
  export type RoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room findFirst
   */
  export type RoomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room findFirstOrThrow
   */
  export type RoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room findMany
   */
  export type RoomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Rooms to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room create
   */
  export type RoomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to create a Room.
     */
    data: XOR<RoomCreateInput, RoomUncheckedCreateInput>
  }

  /**
   * Room createMany
   */
  export type RoomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rooms.
     */
    data: RoomCreateManyInput | RoomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Room createManyAndReturn
   */
  export type RoomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * The data used to create many Rooms.
     */
    data: RoomCreateManyInput | RoomCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Room update
   */
  export type RoomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to update a Room.
     */
    data: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
    /**
     * Choose, which Room to update.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room updateMany
   */
  export type RoomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rooms.
     */
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyInput>
    /**
     * Filter which Rooms to update
     */
    where?: RoomWhereInput
    /**
     * Limit how many Rooms to update.
     */
    limit?: number
  }

  /**
   * Room updateManyAndReturn
   */
  export type RoomUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * The data used to update Rooms.
     */
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyInput>
    /**
     * Filter which Rooms to update
     */
    where?: RoomWhereInput
    /**
     * Limit how many Rooms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Room upsert
   */
  export type RoomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The filter to search for the Room to update in case it exists.
     */
    where: RoomWhereUniqueInput
    /**
     * In case the Room found by the `where` argument doesn't exist, create a new Room with this data.
     */
    create: XOR<RoomCreateInput, RoomUncheckedCreateInput>
    /**
     * In case the Room was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
  }

  /**
   * Room delete
   */
  export type RoomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter which Room to delete.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room deleteMany
   */
  export type RoomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rooms to delete
     */
    where?: RoomWhereInput
    /**
     * Limit how many Rooms to delete.
     */
    limit?: number
  }

  /**
   * Room.Hotel
   */
  export type Room$HotelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    where?: HotelWhereInput
  }

  /**
   * Room without action
   */
  export type RoomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
  }


  /**
   * Model RoomInventory
   */

  export type AggregateRoomInventory = {
    _count: RoomInventoryCountAggregateOutputType | null
    _avg: RoomInventoryAvgAggregateOutputType | null
    _sum: RoomInventorySumAggregateOutputType | null
    _min: RoomInventoryMinAggregateOutputType | null
    _max: RoomInventoryMaxAggregateOutputType | null
  }

  export type RoomInventoryAvgAggregateOutputType = {
    id: number | null
    roomTypeId: number | null
    totalInventory: number | null
    bookedCount: number | null
    hotelId: number | null
  }

  export type RoomInventorySumAggregateOutputType = {
    id: number | null
    roomTypeId: number | null
    totalInventory: number | null
    bookedCount: number | null
    hotelId: number | null
  }

  export type RoomInventoryMinAggregateOutputType = {
    id: number | null
    roomTypeId: number | null
    date: Date | null
    totalInventory: number | null
    bookedCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    hotelId: number | null
  }

  export type RoomInventoryMaxAggregateOutputType = {
    id: number | null
    roomTypeId: number | null
    date: Date | null
    totalInventory: number | null
    bookedCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    hotelId: number | null
  }

  export type RoomInventoryCountAggregateOutputType = {
    id: number
    roomTypeId: number
    date: number
    totalInventory: number
    bookedCount: number
    createdAt: number
    updatedAt: number
    hotelId: number
    _all: number
  }


  export type RoomInventoryAvgAggregateInputType = {
    id?: true
    roomTypeId?: true
    totalInventory?: true
    bookedCount?: true
    hotelId?: true
  }

  export type RoomInventorySumAggregateInputType = {
    id?: true
    roomTypeId?: true
    totalInventory?: true
    bookedCount?: true
    hotelId?: true
  }

  export type RoomInventoryMinAggregateInputType = {
    id?: true
    roomTypeId?: true
    date?: true
    totalInventory?: true
    bookedCount?: true
    createdAt?: true
    updatedAt?: true
    hotelId?: true
  }

  export type RoomInventoryMaxAggregateInputType = {
    id?: true
    roomTypeId?: true
    date?: true
    totalInventory?: true
    bookedCount?: true
    createdAt?: true
    updatedAt?: true
    hotelId?: true
  }

  export type RoomInventoryCountAggregateInputType = {
    id?: true
    roomTypeId?: true
    date?: true
    totalInventory?: true
    bookedCount?: true
    createdAt?: true
    updatedAt?: true
    hotelId?: true
    _all?: true
  }

  export type RoomInventoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomInventory to aggregate.
     */
    where?: RoomInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomInventories to fetch.
     */
    orderBy?: RoomInventoryOrderByWithRelationInput | RoomInventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomInventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoomInventories
    **/
    _count?: true | RoomInventoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoomInventoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoomInventorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomInventoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomInventoryMaxAggregateInputType
  }

  export type GetRoomInventoryAggregateType<T extends RoomInventoryAggregateArgs> = {
        [P in keyof T & keyof AggregateRoomInventory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoomInventory[P]>
      : GetScalarType<T[P], AggregateRoomInventory[P]>
  }




  export type RoomInventoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomInventoryWhereInput
    orderBy?: RoomInventoryOrderByWithAggregationInput | RoomInventoryOrderByWithAggregationInput[]
    by: RoomInventoryScalarFieldEnum[] | RoomInventoryScalarFieldEnum
    having?: RoomInventoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomInventoryCountAggregateInputType | true
    _avg?: RoomInventoryAvgAggregateInputType
    _sum?: RoomInventorySumAggregateInputType
    _min?: RoomInventoryMinAggregateInputType
    _max?: RoomInventoryMaxAggregateInputType
  }

  export type RoomInventoryGroupByOutputType = {
    id: number
    roomTypeId: number
    date: Date
    totalInventory: number
    bookedCount: number
    createdAt: Date
    updatedAt: Date
    hotelId: number | null
    _count: RoomInventoryCountAggregateOutputType | null
    _avg: RoomInventoryAvgAggregateOutputType | null
    _sum: RoomInventorySumAggregateOutputType | null
    _min: RoomInventoryMinAggregateOutputType | null
    _max: RoomInventoryMaxAggregateOutputType | null
  }

  type GetRoomInventoryGroupByPayload<T extends RoomInventoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomInventoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomInventoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomInventoryGroupByOutputType[P]>
            : GetScalarType<T[P], RoomInventoryGroupByOutputType[P]>
        }
      >
    >


  export type RoomInventorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomTypeId?: boolean
    date?: boolean
    totalInventory?: boolean
    bookedCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelId?: boolean
    RoomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
    Hotel?: boolean | RoomInventory$HotelArgs<ExtArgs>
  }, ExtArgs["result"]["roomInventory"]>

  export type RoomInventorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomTypeId?: boolean
    date?: boolean
    totalInventory?: boolean
    bookedCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelId?: boolean
    RoomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
    Hotel?: boolean | RoomInventory$HotelArgs<ExtArgs>
  }, ExtArgs["result"]["roomInventory"]>

  export type RoomInventorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomTypeId?: boolean
    date?: boolean
    totalInventory?: boolean
    bookedCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelId?: boolean
    RoomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
    Hotel?: boolean | RoomInventory$HotelArgs<ExtArgs>
  }, ExtArgs["result"]["roomInventory"]>

  export type RoomInventorySelectScalar = {
    id?: boolean
    roomTypeId?: boolean
    date?: boolean
    totalInventory?: boolean
    bookedCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelId?: boolean
  }

  export type RoomInventoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roomTypeId" | "date" | "totalInventory" | "bookedCount" | "createdAt" | "updatedAt" | "hotelId", ExtArgs["result"]["roomInventory"]>
  export type RoomInventoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RoomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
    Hotel?: boolean | RoomInventory$HotelArgs<ExtArgs>
  }
  export type RoomInventoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RoomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
    Hotel?: boolean | RoomInventory$HotelArgs<ExtArgs>
  }
  export type RoomInventoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RoomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
    Hotel?: boolean | RoomInventory$HotelArgs<ExtArgs>
  }

  export type $RoomInventoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoomInventory"
    objects: {
      RoomType: Prisma.$RoomTypePayload<ExtArgs>
      Hotel: Prisma.$HotelPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      roomTypeId: number
      /**
       * Date for which inventory is tracked
       */
      date: Date
      /**
       * Total physical rooms of this type
       */
      totalInventory: number
      /**
       * Rooms booked on this date
       */
      bookedCount: number
      createdAt: Date
      updatedAt: Date
      hotelId: number | null
    }, ExtArgs["result"]["roomInventory"]>
    composites: {}
  }

  type RoomInventoryGetPayload<S extends boolean | null | undefined | RoomInventoryDefaultArgs> = $Result.GetResult<Prisma.$RoomInventoryPayload, S>

  type RoomInventoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoomInventoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoomInventoryCountAggregateInputType | true
    }

  export interface RoomInventoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoomInventory'], meta: { name: 'RoomInventory' } }
    /**
     * Find zero or one RoomInventory that matches the filter.
     * @param {RoomInventoryFindUniqueArgs} args - Arguments to find a RoomInventory
     * @example
     * // Get one RoomInventory
     * const roomInventory = await prisma.roomInventory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoomInventoryFindUniqueArgs>(args: SelectSubset<T, RoomInventoryFindUniqueArgs<ExtArgs>>): Prisma__RoomInventoryClient<$Result.GetResult<Prisma.$RoomInventoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RoomInventory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoomInventoryFindUniqueOrThrowArgs} args - Arguments to find a RoomInventory
     * @example
     * // Get one RoomInventory
     * const roomInventory = await prisma.roomInventory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoomInventoryFindUniqueOrThrowArgs>(args: SelectSubset<T, RoomInventoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoomInventoryClient<$Result.GetResult<Prisma.$RoomInventoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoomInventory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomInventoryFindFirstArgs} args - Arguments to find a RoomInventory
     * @example
     * // Get one RoomInventory
     * const roomInventory = await prisma.roomInventory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoomInventoryFindFirstArgs>(args?: SelectSubset<T, RoomInventoryFindFirstArgs<ExtArgs>>): Prisma__RoomInventoryClient<$Result.GetResult<Prisma.$RoomInventoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoomInventory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomInventoryFindFirstOrThrowArgs} args - Arguments to find a RoomInventory
     * @example
     * // Get one RoomInventory
     * const roomInventory = await prisma.roomInventory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoomInventoryFindFirstOrThrowArgs>(args?: SelectSubset<T, RoomInventoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoomInventoryClient<$Result.GetResult<Prisma.$RoomInventoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RoomInventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomInventoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoomInventories
     * const roomInventories = await prisma.roomInventory.findMany()
     * 
     * // Get first 10 RoomInventories
     * const roomInventories = await prisma.roomInventory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomInventoryWithIdOnly = await prisma.roomInventory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoomInventoryFindManyArgs>(args?: SelectSubset<T, RoomInventoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomInventoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RoomInventory.
     * @param {RoomInventoryCreateArgs} args - Arguments to create a RoomInventory.
     * @example
     * // Create one RoomInventory
     * const RoomInventory = await prisma.roomInventory.create({
     *   data: {
     *     // ... data to create a RoomInventory
     *   }
     * })
     * 
     */
    create<T extends RoomInventoryCreateArgs>(args: SelectSubset<T, RoomInventoryCreateArgs<ExtArgs>>): Prisma__RoomInventoryClient<$Result.GetResult<Prisma.$RoomInventoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RoomInventories.
     * @param {RoomInventoryCreateManyArgs} args - Arguments to create many RoomInventories.
     * @example
     * // Create many RoomInventories
     * const roomInventory = await prisma.roomInventory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoomInventoryCreateManyArgs>(args?: SelectSubset<T, RoomInventoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoomInventories and returns the data saved in the database.
     * @param {RoomInventoryCreateManyAndReturnArgs} args - Arguments to create many RoomInventories.
     * @example
     * // Create many RoomInventories
     * const roomInventory = await prisma.roomInventory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoomInventories and only return the `id`
     * const roomInventoryWithIdOnly = await prisma.roomInventory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoomInventoryCreateManyAndReturnArgs>(args?: SelectSubset<T, RoomInventoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomInventoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RoomInventory.
     * @param {RoomInventoryDeleteArgs} args - Arguments to delete one RoomInventory.
     * @example
     * // Delete one RoomInventory
     * const RoomInventory = await prisma.roomInventory.delete({
     *   where: {
     *     // ... filter to delete one RoomInventory
     *   }
     * })
     * 
     */
    delete<T extends RoomInventoryDeleteArgs>(args: SelectSubset<T, RoomInventoryDeleteArgs<ExtArgs>>): Prisma__RoomInventoryClient<$Result.GetResult<Prisma.$RoomInventoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RoomInventory.
     * @param {RoomInventoryUpdateArgs} args - Arguments to update one RoomInventory.
     * @example
     * // Update one RoomInventory
     * const roomInventory = await prisma.roomInventory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoomInventoryUpdateArgs>(args: SelectSubset<T, RoomInventoryUpdateArgs<ExtArgs>>): Prisma__RoomInventoryClient<$Result.GetResult<Prisma.$RoomInventoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RoomInventories.
     * @param {RoomInventoryDeleteManyArgs} args - Arguments to filter RoomInventories to delete.
     * @example
     * // Delete a few RoomInventories
     * const { count } = await prisma.roomInventory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoomInventoryDeleteManyArgs>(args?: SelectSubset<T, RoomInventoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomInventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomInventoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoomInventories
     * const roomInventory = await prisma.roomInventory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoomInventoryUpdateManyArgs>(args: SelectSubset<T, RoomInventoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomInventories and returns the data updated in the database.
     * @param {RoomInventoryUpdateManyAndReturnArgs} args - Arguments to update many RoomInventories.
     * @example
     * // Update many RoomInventories
     * const roomInventory = await prisma.roomInventory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RoomInventories and only return the `id`
     * const roomInventoryWithIdOnly = await prisma.roomInventory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoomInventoryUpdateManyAndReturnArgs>(args: SelectSubset<T, RoomInventoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomInventoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RoomInventory.
     * @param {RoomInventoryUpsertArgs} args - Arguments to update or create a RoomInventory.
     * @example
     * // Update or create a RoomInventory
     * const roomInventory = await prisma.roomInventory.upsert({
     *   create: {
     *     // ... data to create a RoomInventory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoomInventory we want to update
     *   }
     * })
     */
    upsert<T extends RoomInventoryUpsertArgs>(args: SelectSubset<T, RoomInventoryUpsertArgs<ExtArgs>>): Prisma__RoomInventoryClient<$Result.GetResult<Prisma.$RoomInventoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RoomInventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomInventoryCountArgs} args - Arguments to filter RoomInventories to count.
     * @example
     * // Count the number of RoomInventories
     * const count = await prisma.roomInventory.count({
     *   where: {
     *     // ... the filter for the RoomInventories we want to count
     *   }
     * })
    **/
    count<T extends RoomInventoryCountArgs>(
      args?: Subset<T, RoomInventoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomInventoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoomInventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomInventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomInventoryAggregateArgs>(args: Subset<T, RoomInventoryAggregateArgs>): Prisma.PrismaPromise<GetRoomInventoryAggregateType<T>>

    /**
     * Group by RoomInventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomInventoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomInventoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomInventoryGroupByArgs['orderBy'] }
        : { orderBy?: RoomInventoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomInventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomInventoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoomInventory model
   */
  readonly fields: RoomInventoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoomInventory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomInventoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    RoomType<T extends RoomTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomTypeDefaultArgs<ExtArgs>>): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Hotel<T extends RoomInventory$HotelArgs<ExtArgs> = {}>(args?: Subset<T, RoomInventory$HotelArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoomInventory model
   */
  interface RoomInventoryFieldRefs {
    readonly id: FieldRef<"RoomInventory", 'Int'>
    readonly roomTypeId: FieldRef<"RoomInventory", 'Int'>
    readonly date: FieldRef<"RoomInventory", 'DateTime'>
    readonly totalInventory: FieldRef<"RoomInventory", 'Int'>
    readonly bookedCount: FieldRef<"RoomInventory", 'Int'>
    readonly createdAt: FieldRef<"RoomInventory", 'DateTime'>
    readonly updatedAt: FieldRef<"RoomInventory", 'DateTime'>
    readonly hotelId: FieldRef<"RoomInventory", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RoomInventory findUnique
   */
  export type RoomInventoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomInventory
     */
    select?: RoomInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomInventory
     */
    omit?: RoomInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInventoryInclude<ExtArgs> | null
    /**
     * Filter, which RoomInventory to fetch.
     */
    where: RoomInventoryWhereUniqueInput
  }

  /**
   * RoomInventory findUniqueOrThrow
   */
  export type RoomInventoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomInventory
     */
    select?: RoomInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomInventory
     */
    omit?: RoomInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInventoryInclude<ExtArgs> | null
    /**
     * Filter, which RoomInventory to fetch.
     */
    where: RoomInventoryWhereUniqueInput
  }

  /**
   * RoomInventory findFirst
   */
  export type RoomInventoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomInventory
     */
    select?: RoomInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomInventory
     */
    omit?: RoomInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInventoryInclude<ExtArgs> | null
    /**
     * Filter, which RoomInventory to fetch.
     */
    where?: RoomInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomInventories to fetch.
     */
    orderBy?: RoomInventoryOrderByWithRelationInput | RoomInventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomInventories.
     */
    cursor?: RoomInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomInventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomInventories.
     */
    distinct?: RoomInventoryScalarFieldEnum | RoomInventoryScalarFieldEnum[]
  }

  /**
   * RoomInventory findFirstOrThrow
   */
  export type RoomInventoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomInventory
     */
    select?: RoomInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomInventory
     */
    omit?: RoomInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInventoryInclude<ExtArgs> | null
    /**
     * Filter, which RoomInventory to fetch.
     */
    where?: RoomInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomInventories to fetch.
     */
    orderBy?: RoomInventoryOrderByWithRelationInput | RoomInventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomInventories.
     */
    cursor?: RoomInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomInventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomInventories.
     */
    distinct?: RoomInventoryScalarFieldEnum | RoomInventoryScalarFieldEnum[]
  }

  /**
   * RoomInventory findMany
   */
  export type RoomInventoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomInventory
     */
    select?: RoomInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomInventory
     */
    omit?: RoomInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInventoryInclude<ExtArgs> | null
    /**
     * Filter, which RoomInventories to fetch.
     */
    where?: RoomInventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomInventories to fetch.
     */
    orderBy?: RoomInventoryOrderByWithRelationInput | RoomInventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoomInventories.
     */
    cursor?: RoomInventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomInventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomInventories.
     */
    skip?: number
    distinct?: RoomInventoryScalarFieldEnum | RoomInventoryScalarFieldEnum[]
  }

  /**
   * RoomInventory create
   */
  export type RoomInventoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomInventory
     */
    select?: RoomInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomInventory
     */
    omit?: RoomInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInventoryInclude<ExtArgs> | null
    /**
     * The data needed to create a RoomInventory.
     */
    data: XOR<RoomInventoryCreateInput, RoomInventoryUncheckedCreateInput>
  }

  /**
   * RoomInventory createMany
   */
  export type RoomInventoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoomInventories.
     */
    data: RoomInventoryCreateManyInput | RoomInventoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoomInventory createManyAndReturn
   */
  export type RoomInventoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomInventory
     */
    select?: RoomInventorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoomInventory
     */
    omit?: RoomInventoryOmit<ExtArgs> | null
    /**
     * The data used to create many RoomInventories.
     */
    data: RoomInventoryCreateManyInput | RoomInventoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInventoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoomInventory update
   */
  export type RoomInventoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomInventory
     */
    select?: RoomInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomInventory
     */
    omit?: RoomInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInventoryInclude<ExtArgs> | null
    /**
     * The data needed to update a RoomInventory.
     */
    data: XOR<RoomInventoryUpdateInput, RoomInventoryUncheckedUpdateInput>
    /**
     * Choose, which RoomInventory to update.
     */
    where: RoomInventoryWhereUniqueInput
  }

  /**
   * RoomInventory updateMany
   */
  export type RoomInventoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoomInventories.
     */
    data: XOR<RoomInventoryUpdateManyMutationInput, RoomInventoryUncheckedUpdateManyInput>
    /**
     * Filter which RoomInventories to update
     */
    where?: RoomInventoryWhereInput
    /**
     * Limit how many RoomInventories to update.
     */
    limit?: number
  }

  /**
   * RoomInventory updateManyAndReturn
   */
  export type RoomInventoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomInventory
     */
    select?: RoomInventorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoomInventory
     */
    omit?: RoomInventoryOmit<ExtArgs> | null
    /**
     * The data used to update RoomInventories.
     */
    data: XOR<RoomInventoryUpdateManyMutationInput, RoomInventoryUncheckedUpdateManyInput>
    /**
     * Filter which RoomInventories to update
     */
    where?: RoomInventoryWhereInput
    /**
     * Limit how many RoomInventories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInventoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoomInventory upsert
   */
  export type RoomInventoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomInventory
     */
    select?: RoomInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomInventory
     */
    omit?: RoomInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInventoryInclude<ExtArgs> | null
    /**
     * The filter to search for the RoomInventory to update in case it exists.
     */
    where: RoomInventoryWhereUniqueInput
    /**
     * In case the RoomInventory found by the `where` argument doesn't exist, create a new RoomInventory with this data.
     */
    create: XOR<RoomInventoryCreateInput, RoomInventoryUncheckedCreateInput>
    /**
     * In case the RoomInventory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomInventoryUpdateInput, RoomInventoryUncheckedUpdateInput>
  }

  /**
   * RoomInventory delete
   */
  export type RoomInventoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomInventory
     */
    select?: RoomInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomInventory
     */
    omit?: RoomInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInventoryInclude<ExtArgs> | null
    /**
     * Filter which RoomInventory to delete.
     */
    where: RoomInventoryWhereUniqueInput
  }

  /**
   * RoomInventory deleteMany
   */
  export type RoomInventoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomInventories to delete
     */
    where?: RoomInventoryWhereInput
    /**
     * Limit how many RoomInventories to delete.
     */
    limit?: number
  }

  /**
   * RoomInventory.Hotel
   */
  export type RoomInventory$HotelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    where?: HotelWhereInput
  }

  /**
   * RoomInventory without action
   */
  export type RoomInventoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomInventory
     */
    select?: RoomInventorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomInventory
     */
    omit?: RoomInventoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInventoryInclude<ExtArgs> | null
  }


  /**
   * Model RoomPrice
   */

  export type AggregateRoomPrice = {
    _count: RoomPriceCountAggregateOutputType | null
    _avg: RoomPriceAvgAggregateOutputType | null
    _sum: RoomPriceSumAggregateOutputType | null
    _min: RoomPriceMinAggregateOutputType | null
    _max: RoomPriceMaxAggregateOutputType | null
  }

  export type RoomPriceAvgAggregateOutputType = {
    id: number | null
    roomTypeId: number | null
    price: number | null
    hotelId: number | null
  }

  export type RoomPriceSumAggregateOutputType = {
    id: number | null
    roomTypeId: number | null
    price: number | null
    hotelId: number | null
  }

  export type RoomPriceMinAggregateOutputType = {
    id: number | null
    roomTypeId: number | null
    date: Date | null
    price: number | null
    currency: $Enums.CurrencyCode | null
    priceType: $Enums.PriceType | null
    createdAt: Date | null
    updatedAt: Date | null
    hotelId: number | null
  }

  export type RoomPriceMaxAggregateOutputType = {
    id: number | null
    roomTypeId: number | null
    date: Date | null
    price: number | null
    currency: $Enums.CurrencyCode | null
    priceType: $Enums.PriceType | null
    createdAt: Date | null
    updatedAt: Date | null
    hotelId: number | null
  }

  export type RoomPriceCountAggregateOutputType = {
    id: number
    roomTypeId: number
    date: number
    price: number
    currency: number
    priceType: number
    createdAt: number
    updatedAt: number
    hotelId: number
    _all: number
  }


  export type RoomPriceAvgAggregateInputType = {
    id?: true
    roomTypeId?: true
    price?: true
    hotelId?: true
  }

  export type RoomPriceSumAggregateInputType = {
    id?: true
    roomTypeId?: true
    price?: true
    hotelId?: true
  }

  export type RoomPriceMinAggregateInputType = {
    id?: true
    roomTypeId?: true
    date?: true
    price?: true
    currency?: true
    priceType?: true
    createdAt?: true
    updatedAt?: true
    hotelId?: true
  }

  export type RoomPriceMaxAggregateInputType = {
    id?: true
    roomTypeId?: true
    date?: true
    price?: true
    currency?: true
    priceType?: true
    createdAt?: true
    updatedAt?: true
    hotelId?: true
  }

  export type RoomPriceCountAggregateInputType = {
    id?: true
    roomTypeId?: true
    date?: true
    price?: true
    currency?: true
    priceType?: true
    createdAt?: true
    updatedAt?: true
    hotelId?: true
    _all?: true
  }

  export type RoomPriceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomPrice to aggregate.
     */
    where?: RoomPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomPrices to fetch.
     */
    orderBy?: RoomPriceOrderByWithRelationInput | RoomPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoomPrices
    **/
    _count?: true | RoomPriceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoomPriceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoomPriceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomPriceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomPriceMaxAggregateInputType
  }

  export type GetRoomPriceAggregateType<T extends RoomPriceAggregateArgs> = {
        [P in keyof T & keyof AggregateRoomPrice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoomPrice[P]>
      : GetScalarType<T[P], AggregateRoomPrice[P]>
  }




  export type RoomPriceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomPriceWhereInput
    orderBy?: RoomPriceOrderByWithAggregationInput | RoomPriceOrderByWithAggregationInput[]
    by: RoomPriceScalarFieldEnum[] | RoomPriceScalarFieldEnum
    having?: RoomPriceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomPriceCountAggregateInputType | true
    _avg?: RoomPriceAvgAggregateInputType
    _sum?: RoomPriceSumAggregateInputType
    _min?: RoomPriceMinAggregateInputType
    _max?: RoomPriceMaxAggregateInputType
  }

  export type RoomPriceGroupByOutputType = {
    id: number
    roomTypeId: number
    date: Date
    price: number
    currency: $Enums.CurrencyCode
    priceType: $Enums.PriceType | null
    createdAt: Date
    updatedAt: Date
    hotelId: number | null
    _count: RoomPriceCountAggregateOutputType | null
    _avg: RoomPriceAvgAggregateOutputType | null
    _sum: RoomPriceSumAggregateOutputType | null
    _min: RoomPriceMinAggregateOutputType | null
    _max: RoomPriceMaxAggregateOutputType | null
  }

  type GetRoomPriceGroupByPayload<T extends RoomPriceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomPriceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomPriceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomPriceGroupByOutputType[P]>
            : GetScalarType<T[P], RoomPriceGroupByOutputType[P]>
        }
      >
    >


  export type RoomPriceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomTypeId?: boolean
    date?: boolean
    price?: boolean
    currency?: boolean
    priceType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelId?: boolean
    RoomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
    Hotel?: boolean | RoomPrice$HotelArgs<ExtArgs>
  }, ExtArgs["result"]["roomPrice"]>

  export type RoomPriceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomTypeId?: boolean
    date?: boolean
    price?: boolean
    currency?: boolean
    priceType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelId?: boolean
    RoomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
    Hotel?: boolean | RoomPrice$HotelArgs<ExtArgs>
  }, ExtArgs["result"]["roomPrice"]>

  export type RoomPriceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomTypeId?: boolean
    date?: boolean
    price?: boolean
    currency?: boolean
    priceType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelId?: boolean
    RoomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
    Hotel?: boolean | RoomPrice$HotelArgs<ExtArgs>
  }, ExtArgs["result"]["roomPrice"]>

  export type RoomPriceSelectScalar = {
    id?: boolean
    roomTypeId?: boolean
    date?: boolean
    price?: boolean
    currency?: boolean
    priceType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelId?: boolean
  }

  export type RoomPriceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roomTypeId" | "date" | "price" | "currency" | "priceType" | "createdAt" | "updatedAt" | "hotelId", ExtArgs["result"]["roomPrice"]>
  export type RoomPriceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RoomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
    Hotel?: boolean | RoomPrice$HotelArgs<ExtArgs>
  }
  export type RoomPriceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RoomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
    Hotel?: boolean | RoomPrice$HotelArgs<ExtArgs>
  }
  export type RoomPriceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RoomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
    Hotel?: boolean | RoomPrice$HotelArgs<ExtArgs>
  }

  export type $RoomPricePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoomPrice"
    objects: {
      RoomType: Prisma.$RoomTypePayload<ExtArgs>
      Hotel: Prisma.$HotelPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      roomTypeId: number
      /**
       * Date for which this price applies
       */
      date: Date
      /**
       * Price per night for this date
       */
      price: number
      currency: $Enums.CurrencyCode
      /**
       * Categorizes the price [15]
       */
      priceType: $Enums.PriceType | null
      createdAt: Date
      updatedAt: Date
      hotelId: number | null
    }, ExtArgs["result"]["roomPrice"]>
    composites: {}
  }

  type RoomPriceGetPayload<S extends boolean | null | undefined | RoomPriceDefaultArgs> = $Result.GetResult<Prisma.$RoomPricePayload, S>

  type RoomPriceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoomPriceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoomPriceCountAggregateInputType | true
    }

  export interface RoomPriceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoomPrice'], meta: { name: 'RoomPrice' } }
    /**
     * Find zero or one RoomPrice that matches the filter.
     * @param {RoomPriceFindUniqueArgs} args - Arguments to find a RoomPrice
     * @example
     * // Get one RoomPrice
     * const roomPrice = await prisma.roomPrice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoomPriceFindUniqueArgs>(args: SelectSubset<T, RoomPriceFindUniqueArgs<ExtArgs>>): Prisma__RoomPriceClient<$Result.GetResult<Prisma.$RoomPricePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RoomPrice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoomPriceFindUniqueOrThrowArgs} args - Arguments to find a RoomPrice
     * @example
     * // Get one RoomPrice
     * const roomPrice = await prisma.roomPrice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoomPriceFindUniqueOrThrowArgs>(args: SelectSubset<T, RoomPriceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoomPriceClient<$Result.GetResult<Prisma.$RoomPricePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoomPrice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomPriceFindFirstArgs} args - Arguments to find a RoomPrice
     * @example
     * // Get one RoomPrice
     * const roomPrice = await prisma.roomPrice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoomPriceFindFirstArgs>(args?: SelectSubset<T, RoomPriceFindFirstArgs<ExtArgs>>): Prisma__RoomPriceClient<$Result.GetResult<Prisma.$RoomPricePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoomPrice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomPriceFindFirstOrThrowArgs} args - Arguments to find a RoomPrice
     * @example
     * // Get one RoomPrice
     * const roomPrice = await prisma.roomPrice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoomPriceFindFirstOrThrowArgs>(args?: SelectSubset<T, RoomPriceFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoomPriceClient<$Result.GetResult<Prisma.$RoomPricePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RoomPrices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomPriceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoomPrices
     * const roomPrices = await prisma.roomPrice.findMany()
     * 
     * // Get first 10 RoomPrices
     * const roomPrices = await prisma.roomPrice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomPriceWithIdOnly = await prisma.roomPrice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoomPriceFindManyArgs>(args?: SelectSubset<T, RoomPriceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPricePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RoomPrice.
     * @param {RoomPriceCreateArgs} args - Arguments to create a RoomPrice.
     * @example
     * // Create one RoomPrice
     * const RoomPrice = await prisma.roomPrice.create({
     *   data: {
     *     // ... data to create a RoomPrice
     *   }
     * })
     * 
     */
    create<T extends RoomPriceCreateArgs>(args: SelectSubset<T, RoomPriceCreateArgs<ExtArgs>>): Prisma__RoomPriceClient<$Result.GetResult<Prisma.$RoomPricePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RoomPrices.
     * @param {RoomPriceCreateManyArgs} args - Arguments to create many RoomPrices.
     * @example
     * // Create many RoomPrices
     * const roomPrice = await prisma.roomPrice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoomPriceCreateManyArgs>(args?: SelectSubset<T, RoomPriceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoomPrices and returns the data saved in the database.
     * @param {RoomPriceCreateManyAndReturnArgs} args - Arguments to create many RoomPrices.
     * @example
     * // Create many RoomPrices
     * const roomPrice = await prisma.roomPrice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoomPrices and only return the `id`
     * const roomPriceWithIdOnly = await prisma.roomPrice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoomPriceCreateManyAndReturnArgs>(args?: SelectSubset<T, RoomPriceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPricePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RoomPrice.
     * @param {RoomPriceDeleteArgs} args - Arguments to delete one RoomPrice.
     * @example
     * // Delete one RoomPrice
     * const RoomPrice = await prisma.roomPrice.delete({
     *   where: {
     *     // ... filter to delete one RoomPrice
     *   }
     * })
     * 
     */
    delete<T extends RoomPriceDeleteArgs>(args: SelectSubset<T, RoomPriceDeleteArgs<ExtArgs>>): Prisma__RoomPriceClient<$Result.GetResult<Prisma.$RoomPricePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RoomPrice.
     * @param {RoomPriceUpdateArgs} args - Arguments to update one RoomPrice.
     * @example
     * // Update one RoomPrice
     * const roomPrice = await prisma.roomPrice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoomPriceUpdateArgs>(args: SelectSubset<T, RoomPriceUpdateArgs<ExtArgs>>): Prisma__RoomPriceClient<$Result.GetResult<Prisma.$RoomPricePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RoomPrices.
     * @param {RoomPriceDeleteManyArgs} args - Arguments to filter RoomPrices to delete.
     * @example
     * // Delete a few RoomPrices
     * const { count } = await prisma.roomPrice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoomPriceDeleteManyArgs>(args?: SelectSubset<T, RoomPriceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomPriceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoomPrices
     * const roomPrice = await prisma.roomPrice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoomPriceUpdateManyArgs>(args: SelectSubset<T, RoomPriceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomPrices and returns the data updated in the database.
     * @param {RoomPriceUpdateManyAndReturnArgs} args - Arguments to update many RoomPrices.
     * @example
     * // Update many RoomPrices
     * const roomPrice = await prisma.roomPrice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RoomPrices and only return the `id`
     * const roomPriceWithIdOnly = await prisma.roomPrice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoomPriceUpdateManyAndReturnArgs>(args: SelectSubset<T, RoomPriceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPricePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RoomPrice.
     * @param {RoomPriceUpsertArgs} args - Arguments to update or create a RoomPrice.
     * @example
     * // Update or create a RoomPrice
     * const roomPrice = await prisma.roomPrice.upsert({
     *   create: {
     *     // ... data to create a RoomPrice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoomPrice we want to update
     *   }
     * })
     */
    upsert<T extends RoomPriceUpsertArgs>(args: SelectSubset<T, RoomPriceUpsertArgs<ExtArgs>>): Prisma__RoomPriceClient<$Result.GetResult<Prisma.$RoomPricePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RoomPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomPriceCountArgs} args - Arguments to filter RoomPrices to count.
     * @example
     * // Count the number of RoomPrices
     * const count = await prisma.roomPrice.count({
     *   where: {
     *     // ... the filter for the RoomPrices we want to count
     *   }
     * })
    **/
    count<T extends RoomPriceCountArgs>(
      args?: Subset<T, RoomPriceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomPriceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoomPrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomPriceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomPriceAggregateArgs>(args: Subset<T, RoomPriceAggregateArgs>): Prisma.PrismaPromise<GetRoomPriceAggregateType<T>>

    /**
     * Group by RoomPrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomPriceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomPriceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomPriceGroupByArgs['orderBy'] }
        : { orderBy?: RoomPriceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomPriceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomPriceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoomPrice model
   */
  readonly fields: RoomPriceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoomPrice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomPriceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    RoomType<T extends RoomTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomTypeDefaultArgs<ExtArgs>>): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Hotel<T extends RoomPrice$HotelArgs<ExtArgs> = {}>(args?: Subset<T, RoomPrice$HotelArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoomPrice model
   */
  interface RoomPriceFieldRefs {
    readonly id: FieldRef<"RoomPrice", 'Int'>
    readonly roomTypeId: FieldRef<"RoomPrice", 'Int'>
    readonly date: FieldRef<"RoomPrice", 'DateTime'>
    readonly price: FieldRef<"RoomPrice", 'Float'>
    readonly currency: FieldRef<"RoomPrice", 'CurrencyCode'>
    readonly priceType: FieldRef<"RoomPrice", 'PriceType'>
    readonly createdAt: FieldRef<"RoomPrice", 'DateTime'>
    readonly updatedAt: FieldRef<"RoomPrice", 'DateTime'>
    readonly hotelId: FieldRef<"RoomPrice", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RoomPrice findUnique
   */
  export type RoomPriceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomPrice
     */
    select?: RoomPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomPrice
     */
    omit?: RoomPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomPriceInclude<ExtArgs> | null
    /**
     * Filter, which RoomPrice to fetch.
     */
    where: RoomPriceWhereUniqueInput
  }

  /**
   * RoomPrice findUniqueOrThrow
   */
  export type RoomPriceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomPrice
     */
    select?: RoomPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomPrice
     */
    omit?: RoomPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomPriceInclude<ExtArgs> | null
    /**
     * Filter, which RoomPrice to fetch.
     */
    where: RoomPriceWhereUniqueInput
  }

  /**
   * RoomPrice findFirst
   */
  export type RoomPriceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomPrice
     */
    select?: RoomPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomPrice
     */
    omit?: RoomPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomPriceInclude<ExtArgs> | null
    /**
     * Filter, which RoomPrice to fetch.
     */
    where?: RoomPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomPrices to fetch.
     */
    orderBy?: RoomPriceOrderByWithRelationInput | RoomPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomPrices.
     */
    cursor?: RoomPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomPrices.
     */
    distinct?: RoomPriceScalarFieldEnum | RoomPriceScalarFieldEnum[]
  }

  /**
   * RoomPrice findFirstOrThrow
   */
  export type RoomPriceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomPrice
     */
    select?: RoomPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomPrice
     */
    omit?: RoomPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomPriceInclude<ExtArgs> | null
    /**
     * Filter, which RoomPrice to fetch.
     */
    where?: RoomPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomPrices to fetch.
     */
    orderBy?: RoomPriceOrderByWithRelationInput | RoomPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomPrices.
     */
    cursor?: RoomPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomPrices.
     */
    distinct?: RoomPriceScalarFieldEnum | RoomPriceScalarFieldEnum[]
  }

  /**
   * RoomPrice findMany
   */
  export type RoomPriceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomPrice
     */
    select?: RoomPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomPrice
     */
    omit?: RoomPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomPriceInclude<ExtArgs> | null
    /**
     * Filter, which RoomPrices to fetch.
     */
    where?: RoomPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomPrices to fetch.
     */
    orderBy?: RoomPriceOrderByWithRelationInput | RoomPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoomPrices.
     */
    cursor?: RoomPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomPrices.
     */
    skip?: number
    distinct?: RoomPriceScalarFieldEnum | RoomPriceScalarFieldEnum[]
  }

  /**
   * RoomPrice create
   */
  export type RoomPriceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomPrice
     */
    select?: RoomPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomPrice
     */
    omit?: RoomPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomPriceInclude<ExtArgs> | null
    /**
     * The data needed to create a RoomPrice.
     */
    data: XOR<RoomPriceCreateInput, RoomPriceUncheckedCreateInput>
  }

  /**
   * RoomPrice createMany
   */
  export type RoomPriceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoomPrices.
     */
    data: RoomPriceCreateManyInput | RoomPriceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoomPrice createManyAndReturn
   */
  export type RoomPriceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomPrice
     */
    select?: RoomPriceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoomPrice
     */
    omit?: RoomPriceOmit<ExtArgs> | null
    /**
     * The data used to create many RoomPrices.
     */
    data: RoomPriceCreateManyInput | RoomPriceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomPriceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoomPrice update
   */
  export type RoomPriceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomPrice
     */
    select?: RoomPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomPrice
     */
    omit?: RoomPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomPriceInclude<ExtArgs> | null
    /**
     * The data needed to update a RoomPrice.
     */
    data: XOR<RoomPriceUpdateInput, RoomPriceUncheckedUpdateInput>
    /**
     * Choose, which RoomPrice to update.
     */
    where: RoomPriceWhereUniqueInput
  }

  /**
   * RoomPrice updateMany
   */
  export type RoomPriceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoomPrices.
     */
    data: XOR<RoomPriceUpdateManyMutationInput, RoomPriceUncheckedUpdateManyInput>
    /**
     * Filter which RoomPrices to update
     */
    where?: RoomPriceWhereInput
    /**
     * Limit how many RoomPrices to update.
     */
    limit?: number
  }

  /**
   * RoomPrice updateManyAndReturn
   */
  export type RoomPriceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomPrice
     */
    select?: RoomPriceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoomPrice
     */
    omit?: RoomPriceOmit<ExtArgs> | null
    /**
     * The data used to update RoomPrices.
     */
    data: XOR<RoomPriceUpdateManyMutationInput, RoomPriceUncheckedUpdateManyInput>
    /**
     * Filter which RoomPrices to update
     */
    where?: RoomPriceWhereInput
    /**
     * Limit how many RoomPrices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomPriceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoomPrice upsert
   */
  export type RoomPriceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomPrice
     */
    select?: RoomPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomPrice
     */
    omit?: RoomPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomPriceInclude<ExtArgs> | null
    /**
     * The filter to search for the RoomPrice to update in case it exists.
     */
    where: RoomPriceWhereUniqueInput
    /**
     * In case the RoomPrice found by the `where` argument doesn't exist, create a new RoomPrice with this data.
     */
    create: XOR<RoomPriceCreateInput, RoomPriceUncheckedCreateInput>
    /**
     * In case the RoomPrice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomPriceUpdateInput, RoomPriceUncheckedUpdateInput>
  }

  /**
   * RoomPrice delete
   */
  export type RoomPriceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomPrice
     */
    select?: RoomPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomPrice
     */
    omit?: RoomPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomPriceInclude<ExtArgs> | null
    /**
     * Filter which RoomPrice to delete.
     */
    where: RoomPriceWhereUniqueInput
  }

  /**
   * RoomPrice deleteMany
   */
  export type RoomPriceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomPrices to delete
     */
    where?: RoomPriceWhereInput
    /**
     * Limit how many RoomPrices to delete.
     */
    limit?: number
  }

  /**
   * RoomPrice.Hotel
   */
  export type RoomPrice$HotelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    where?: HotelWhereInput
  }

  /**
   * RoomPrice without action
   */
  export type RoomPriceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomPrice
     */
    select?: RoomPriceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomPrice
     */
    omit?: RoomPriceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomPriceInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    roleId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    roleId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    phoneNumber: string | null
    roleId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    phoneNumber: string | null
    roleId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    email: number
    password: number
    firstName: number
    lastName: number
    phoneNumber: number
    roleId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    roleId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    roleId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    phoneNumber?: true
    roleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    phoneNumber?: true
    roleId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    phoneNumber?: true
    roleId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    username: string
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    phoneNumber: string | null
    roleId: number
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    phoneNumber?: boolean
    roleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Role?: boolean | RoleDefaultArgs<ExtArgs>
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    cancellations?: boolean | User$cancellationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    phoneNumber?: boolean
    roleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    phoneNumber?: boolean
    roleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    phoneNumber?: boolean
    roleId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "email" | "password" | "firstName" | "lastName" | "phoneNumber" | "roleId" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Role?: boolean | RoleDefaultArgs<ExtArgs>
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    cancellations?: boolean | User$cancellationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      Role: Prisma.$RolePayload<ExtArgs>
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      cancellations: Prisma.$CancellationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      email: string | null
      password: string | null
      firstName: string | null
      lastName: string | null
      phoneNumber: string | null
      roleId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bookings<T extends User$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, User$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends User$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cancellations<T extends User$cancellationsArgs<ExtArgs> = {}>(args?: Subset<T, User$cancellationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CancellationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly username: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly phoneNumber: FieldRef<"User", 'String'>
    readonly roleId: FieldRef<"User", 'Int'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.bookings
   */
  export type User$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * User.reviews
   */
  export type User$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * User.cancellations
   */
  export type User$cancellationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cancellation
     */
    select?: CancellationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cancellation
     */
    omit?: CancellationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationInclude<ExtArgs> | null
    where?: CancellationWhereInput
    orderBy?: CancellationOrderByWithRelationInput | CancellationOrderByWithRelationInput[]
    cursor?: CancellationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CancellationScalarFieldEnum | CancellationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    id: number | null
  }

  export type RoleSumAggregateOutputType = {
    id: number | null
  }

  export type RoleMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    id?: true
  }

  export type RoleSumAggregateInputType = {
    id?: true
  }

  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Role$usersArgs<ExtArgs> = {}>(args?: Subset<T, Role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'Int'>
    readonly name: FieldRef<"Role", 'String'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
    readonly updatedAt: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.users
   */
  export type Role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model Booking
   */

  export type AggregateBooking = {
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  export type BookingAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    roomTypeId: number | null
    numberOfRooms: number | null
    totalAmount: number | null
    promotionId: number | null
    cancellationPolicyId: number | null
    hotelId: number | null
  }

  export type BookingSumAggregateOutputType = {
    id: number | null
    userId: number | null
    roomTypeId: number | null
    numberOfRooms: number | null
    totalAmount: number | null
    promotionId: number | null
    cancellationPolicyId: number | null
    hotelId: number | null
  }

  export type BookingMinAggregateOutputType = {
    id: number | null
    userId: number | null
    roomTypeId: number | null
    numberOfRooms: number | null
    checkIn: Date | null
    checkOut: Date | null
    totalAmount: number | null
    currency: $Enums.CurrencyCode | null
    status: $Enums.BookingStatus | null
    guestName: string | null
    guestSurname: string | null
    guestEmail: string | null
    guestPhone: string | null
    guestIdentity: string | null
    promotionId: number | null
    cancellationPolicyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    hotelId: number | null
  }

  export type BookingMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    roomTypeId: number | null
    numberOfRooms: number | null
    checkIn: Date | null
    checkOut: Date | null
    totalAmount: number | null
    currency: $Enums.CurrencyCode | null
    status: $Enums.BookingStatus | null
    guestName: string | null
    guestSurname: string | null
    guestEmail: string | null
    guestPhone: string | null
    guestIdentity: string | null
    promotionId: number | null
    cancellationPolicyId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    hotelId: number | null
  }

  export type BookingCountAggregateOutputType = {
    id: number
    userId: number
    roomTypeId: number
    numberOfRooms: number
    checkIn: number
    checkOut: number
    totalAmount: number
    currency: number
    status: number
    guestName: number
    guestSurname: number
    guestEmail: number
    guestPhone: number
    guestIdentity: number
    promotionId: number
    cancellationPolicyId: number
    promotionSnapshot: number
    policySnapshot: number
    createdAt: number
    updatedAt: number
    hotelId: number
    _all: number
  }


  export type BookingAvgAggregateInputType = {
    id?: true
    userId?: true
    roomTypeId?: true
    numberOfRooms?: true
    totalAmount?: true
    promotionId?: true
    cancellationPolicyId?: true
    hotelId?: true
  }

  export type BookingSumAggregateInputType = {
    id?: true
    userId?: true
    roomTypeId?: true
    numberOfRooms?: true
    totalAmount?: true
    promotionId?: true
    cancellationPolicyId?: true
    hotelId?: true
  }

  export type BookingMinAggregateInputType = {
    id?: true
    userId?: true
    roomTypeId?: true
    numberOfRooms?: true
    checkIn?: true
    checkOut?: true
    totalAmount?: true
    currency?: true
    status?: true
    guestName?: true
    guestSurname?: true
    guestEmail?: true
    guestPhone?: true
    guestIdentity?: true
    promotionId?: true
    cancellationPolicyId?: true
    createdAt?: true
    updatedAt?: true
    hotelId?: true
  }

  export type BookingMaxAggregateInputType = {
    id?: true
    userId?: true
    roomTypeId?: true
    numberOfRooms?: true
    checkIn?: true
    checkOut?: true
    totalAmount?: true
    currency?: true
    status?: true
    guestName?: true
    guestSurname?: true
    guestEmail?: true
    guestPhone?: true
    guestIdentity?: true
    promotionId?: true
    cancellationPolicyId?: true
    createdAt?: true
    updatedAt?: true
    hotelId?: true
  }

  export type BookingCountAggregateInputType = {
    id?: true
    userId?: true
    roomTypeId?: true
    numberOfRooms?: true
    checkIn?: true
    checkOut?: true
    totalAmount?: true
    currency?: true
    status?: true
    guestName?: true
    guestSurname?: true
    guestEmail?: true
    guestPhone?: true
    guestIdentity?: true
    promotionId?: true
    cancellationPolicyId?: true
    promotionSnapshot?: true
    policySnapshot?: true
    createdAt?: true
    updatedAt?: true
    hotelId?: true
    _all?: true
  }

  export type BookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Booking to aggregate.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMaxAggregateInputType
  }

  export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking[P]>
      : GetScalarType<T[P], AggregateBooking[P]>
  }




  export type BookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithAggregationInput | BookingOrderByWithAggregationInput[]
    by: BookingScalarFieldEnum[] | BookingScalarFieldEnum
    having?: BookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCountAggregateInputType | true
    _avg?: BookingAvgAggregateInputType
    _sum?: BookingSumAggregateInputType
    _min?: BookingMinAggregateInputType
    _max?: BookingMaxAggregateInputType
  }

  export type BookingGroupByOutputType = {
    id: number
    userId: number | null
    roomTypeId: number
    numberOfRooms: number
    checkIn: Date
    checkOut: Date
    totalAmount: number | null
    currency: $Enums.CurrencyCode
    status: $Enums.BookingStatus
    guestName: string | null
    guestSurname: string | null
    guestEmail: string | null
    guestPhone: string | null
    guestIdentity: string | null
    promotionId: number | null
    cancellationPolicyId: number | null
    promotionSnapshot: JsonValue | null
    policySnapshot: JsonValue | null
    createdAt: Date
    updatedAt: Date
    hotelId: number | null
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  type GetBookingGroupByPayload<T extends BookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGroupByOutputType[P]>
        }
      >
    >


  export type BookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roomTypeId?: boolean
    numberOfRooms?: boolean
    checkIn?: boolean
    checkOut?: boolean
    totalAmount?: boolean
    currency?: boolean
    status?: boolean
    guestName?: boolean
    guestSurname?: boolean
    guestEmail?: boolean
    guestPhone?: boolean
    guestIdentity?: boolean
    promotionId?: boolean
    cancellationPolicyId?: boolean
    promotionSnapshot?: boolean
    policySnapshot?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelId?: boolean
    User?: boolean | Booking$UserArgs<ExtArgs>
    RoomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
    payment?: boolean | Booking$paymentArgs<ExtArgs>
    review?: boolean | Booking$reviewArgs<ExtArgs>
    Promotion?: boolean | Booking$PromotionArgs<ExtArgs>
    CancellationPolicy?: boolean | Booking$CancellationPolicyArgs<ExtArgs>
    cancellation?: boolean | Booking$cancellationArgs<ExtArgs>
    Hotel?: boolean | Booking$HotelArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roomTypeId?: boolean
    numberOfRooms?: boolean
    checkIn?: boolean
    checkOut?: boolean
    totalAmount?: boolean
    currency?: boolean
    status?: boolean
    guestName?: boolean
    guestSurname?: boolean
    guestEmail?: boolean
    guestPhone?: boolean
    guestIdentity?: boolean
    promotionId?: boolean
    cancellationPolicyId?: boolean
    promotionSnapshot?: boolean
    policySnapshot?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelId?: boolean
    User?: boolean | Booking$UserArgs<ExtArgs>
    RoomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
    Promotion?: boolean | Booking$PromotionArgs<ExtArgs>
    CancellationPolicy?: boolean | Booking$CancellationPolicyArgs<ExtArgs>
    Hotel?: boolean | Booking$HotelArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roomTypeId?: boolean
    numberOfRooms?: boolean
    checkIn?: boolean
    checkOut?: boolean
    totalAmount?: boolean
    currency?: boolean
    status?: boolean
    guestName?: boolean
    guestSurname?: boolean
    guestEmail?: boolean
    guestPhone?: boolean
    guestIdentity?: boolean
    promotionId?: boolean
    cancellationPolicyId?: boolean
    promotionSnapshot?: boolean
    policySnapshot?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelId?: boolean
    User?: boolean | Booking$UserArgs<ExtArgs>
    RoomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
    Promotion?: boolean | Booking$PromotionArgs<ExtArgs>
    CancellationPolicy?: boolean | Booking$CancellationPolicyArgs<ExtArgs>
    Hotel?: boolean | Booking$HotelArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectScalar = {
    id?: boolean
    userId?: boolean
    roomTypeId?: boolean
    numberOfRooms?: boolean
    checkIn?: boolean
    checkOut?: boolean
    totalAmount?: boolean
    currency?: boolean
    status?: boolean
    guestName?: boolean
    guestSurname?: boolean
    guestEmail?: boolean
    guestPhone?: boolean
    guestIdentity?: boolean
    promotionId?: boolean
    cancellationPolicyId?: boolean
    promotionSnapshot?: boolean
    policySnapshot?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelId?: boolean
  }

  export type BookingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "roomTypeId" | "numberOfRooms" | "checkIn" | "checkOut" | "totalAmount" | "currency" | "status" | "guestName" | "guestSurname" | "guestEmail" | "guestPhone" | "guestIdentity" | "promotionId" | "cancellationPolicyId" | "promotionSnapshot" | "policySnapshot" | "createdAt" | "updatedAt" | "hotelId", ExtArgs["result"]["booking"]>
  export type BookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | Booking$UserArgs<ExtArgs>
    RoomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
    payment?: boolean | Booking$paymentArgs<ExtArgs>
    review?: boolean | Booking$reviewArgs<ExtArgs>
    Promotion?: boolean | Booking$PromotionArgs<ExtArgs>
    CancellationPolicy?: boolean | Booking$CancellationPolicyArgs<ExtArgs>
    cancellation?: boolean | Booking$cancellationArgs<ExtArgs>
    Hotel?: boolean | Booking$HotelArgs<ExtArgs>
  }
  export type BookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | Booking$UserArgs<ExtArgs>
    RoomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
    Promotion?: boolean | Booking$PromotionArgs<ExtArgs>
    CancellationPolicy?: boolean | Booking$CancellationPolicyArgs<ExtArgs>
    Hotel?: boolean | Booking$HotelArgs<ExtArgs>
  }
  export type BookingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | Booking$UserArgs<ExtArgs>
    RoomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
    Promotion?: boolean | Booking$PromotionArgs<ExtArgs>
    CancellationPolicy?: boolean | Booking$CancellationPolicyArgs<ExtArgs>
    Hotel?: boolean | Booking$HotelArgs<ExtArgs>
  }

  export type $BookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Booking"
    objects: {
      User: Prisma.$UserPayload<ExtArgs> | null
      RoomType: Prisma.$RoomTypePayload<ExtArgs>
      /**
       * Link to the payment record
       */
      payment: Prisma.$PaymentPayload<ExtArgs> | null
      /**
       * Link to the review for this booking
       */
      review: Prisma.$ReviewPayload<ExtArgs> | null
      Promotion: Prisma.$PromotionPayload<ExtArgs> | null
      CancellationPolicy: Prisma.$CancellationPolicyPayload<ExtArgs> | null
      /**
       * Link to cancellation details (if using separate model)
       */
      cancellation: Prisma.$CancellationPayload<ExtArgs> | null
      Hotel: Prisma.$HotelPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      /**
       * Link to registered user (if applicable)
       */
      userId: number | null
      /**
       * Type of room booked
       */
      roomTypeId: number
      numberOfRooms: number
      /**
       * Check-in date
       */
      checkIn: Date
      /**
       * Check-out date
       */
      checkOut: Date
      /**
       * Final calculated amount at time of booking
       */
      totalAmount: number | null
      currency: $Enums.CurrencyCode
      /**
       * Current status of the booking [11, 15]
       */
      status: $Enums.BookingStatus
      guestName: string | null
      guestSurname: string | null
      guestEmail: string | null
      guestPhone: string | null
      guestIdentity: string | null
      /**
       * Optional link to applied promotion
       */
      promotionId: number | null
      /**
       * Link to applicable cancellation policy
       */
      cancellationPolicyId: number | null
      promotionSnapshot: Prisma.JsonValue | null
      policySnapshot: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      hotelId: number | null
    }, ExtArgs["result"]["booking"]>
    composites: {}
  }

  type BookingGetPayload<S extends boolean | null | undefined | BookingDefaultArgs> = $Result.GetResult<Prisma.$BookingPayload, S>

  type BookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingCountAggregateInputType | true
    }

  export interface BookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Booking'], meta: { name: 'Booking' } }
    /**
     * Find zero or one Booking that matches the filter.
     * @param {BookingFindUniqueArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingFindUniqueArgs>(args: SelectSubset<T, BookingFindUniqueArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Booking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingFindFirstArgs>(args?: SelectSubset<T, BookingFindFirstArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.booking.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.booking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingWithIdOnly = await prisma.booking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingFindManyArgs>(args?: SelectSubset<T, BookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Booking.
     * @param {BookingCreateArgs} args - Arguments to create a Booking.
     * @example
     * // Create one Booking
     * const Booking = await prisma.booking.create({
     *   data: {
     *     // ... data to create a Booking
     *   }
     * })
     * 
     */
    create<T extends BookingCreateArgs>(args: SelectSubset<T, BookingCreateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bookings.
     * @param {BookingCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingCreateManyArgs>(args?: SelectSubset<T, BookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookings and returns the data saved in the database.
     * @param {BookingCreateManyAndReturnArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Booking.
     * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
     * @example
     * // Delete one Booking
     * const Booking = await prisma.booking.delete({
     *   where: {
     *     // ... filter to delete one Booking
     *   }
     * })
     * 
     */
    delete<T extends BookingDeleteArgs>(args: SelectSubset<T, BookingDeleteArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Booking.
     * @param {BookingUpdateArgs} args - Arguments to update one Booking.
     * @example
     * // Update one Booking
     * const booking = await prisma.booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingUpdateArgs>(args: SelectSubset<T, BookingUpdateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bookings.
     * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingDeleteManyArgs>(args?: SelectSubset<T, BookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingUpdateManyArgs>(args: SelectSubset<T, BookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings and returns the data updated in the database.
     * @param {BookingUpdateManyAndReturnArgs} args - Arguments to update many Bookings.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Booking.
     * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
     * @example
     * // Update or create a Booking
     * const booking = await prisma.booking.upsert({
     *   create: {
     *     // ... data to create a Booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking we want to update
     *   }
     * })
     */
    upsert<T extends BookingUpsertArgs>(args: SelectSubset<T, BookingUpsertArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.booking.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingCountArgs>(
      args?: Subset<T, BookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAggregateArgs>(args: Subset<T, BookingAggregateArgs>): Prisma.PrismaPromise<GetBookingAggregateType<T>>

    /**
     * Group by Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingGroupByArgs['orderBy'] }
        : { orderBy?: BookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Booking model
   */
  readonly fields: BookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends Booking$UserArgs<ExtArgs> = {}>(args?: Subset<T, Booking$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    RoomType<T extends RoomTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomTypeDefaultArgs<ExtArgs>>): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payment<T extends Booking$paymentArgs<ExtArgs> = {}>(args?: Subset<T, Booking$paymentArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    review<T extends Booking$reviewArgs<ExtArgs> = {}>(args?: Subset<T, Booking$reviewArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Promotion<T extends Booking$PromotionArgs<ExtArgs> = {}>(args?: Subset<T, Booking$PromotionArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    CancellationPolicy<T extends Booking$CancellationPolicyArgs<ExtArgs> = {}>(args?: Subset<T, Booking$CancellationPolicyArgs<ExtArgs>>): Prisma__CancellationPolicyClient<$Result.GetResult<Prisma.$CancellationPolicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    cancellation<T extends Booking$cancellationArgs<ExtArgs> = {}>(args?: Subset<T, Booking$cancellationArgs<ExtArgs>>): Prisma__CancellationClient<$Result.GetResult<Prisma.$CancellationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Hotel<T extends Booking$HotelArgs<ExtArgs> = {}>(args?: Subset<T, Booking$HotelArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Booking model
   */
  interface BookingFieldRefs {
    readonly id: FieldRef<"Booking", 'Int'>
    readonly userId: FieldRef<"Booking", 'Int'>
    readonly roomTypeId: FieldRef<"Booking", 'Int'>
    readonly numberOfRooms: FieldRef<"Booking", 'Int'>
    readonly checkIn: FieldRef<"Booking", 'DateTime'>
    readonly checkOut: FieldRef<"Booking", 'DateTime'>
    readonly totalAmount: FieldRef<"Booking", 'Float'>
    readonly currency: FieldRef<"Booking", 'CurrencyCode'>
    readonly status: FieldRef<"Booking", 'BookingStatus'>
    readonly guestName: FieldRef<"Booking", 'String'>
    readonly guestSurname: FieldRef<"Booking", 'String'>
    readonly guestEmail: FieldRef<"Booking", 'String'>
    readonly guestPhone: FieldRef<"Booking", 'String'>
    readonly guestIdentity: FieldRef<"Booking", 'String'>
    readonly promotionId: FieldRef<"Booking", 'Int'>
    readonly cancellationPolicyId: FieldRef<"Booking", 'Int'>
    readonly promotionSnapshot: FieldRef<"Booking", 'Json'>
    readonly policySnapshot: FieldRef<"Booking", 'Json'>
    readonly createdAt: FieldRef<"Booking", 'DateTime'>
    readonly updatedAt: FieldRef<"Booking", 'DateTime'>
    readonly hotelId: FieldRef<"Booking", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Booking findUnique
   */
  export type BookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findUniqueOrThrow
   */
  export type BookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findFirst
   */
  export type BookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findFirstOrThrow
   */
  export type BookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findMany
   */
  export type BookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking create
   */
  export type BookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to create a Booking.
     */
    data: XOR<BookingCreateInput, BookingUncheckedCreateInput>
  }

  /**
   * Booking createMany
   */
  export type BookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Booking createManyAndReturn
   */
  export type BookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking update
   */
  export type BookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to update a Booking.
     */
    data: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
    /**
     * Choose, which Booking to update.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking updateMany
   */
  export type BookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to update.
     */
    limit?: number
  }

  /**
   * Booking updateManyAndReturn
   */
  export type BookingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking upsert
   */
  export type BookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The filter to search for the Booking to update in case it exists.
     */
    where: BookingWhereUniqueInput
    /**
     * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
     */
    create: XOR<BookingCreateInput, BookingUncheckedCreateInput>
    /**
     * In case the Booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
  }

  /**
   * Booking delete
   */
  export type BookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter which Booking to delete.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking deleteMany
   */
  export type BookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to delete.
     */
    limit?: number
  }

  /**
   * Booking.User
   */
  export type Booking$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Booking.payment
   */
  export type Booking$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
  }

  /**
   * Booking.review
   */
  export type Booking$reviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
  }

  /**
   * Booking.Promotion
   */
  export type Booking$PromotionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    where?: PromotionWhereInput
  }

  /**
   * Booking.CancellationPolicy
   */
  export type Booking$CancellationPolicyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationPolicy
     */
    select?: CancellationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CancellationPolicy
     */
    omit?: CancellationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationPolicyInclude<ExtArgs> | null
    where?: CancellationPolicyWhereInput
  }

  /**
   * Booking.cancellation
   */
  export type Booking$cancellationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cancellation
     */
    select?: CancellationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cancellation
     */
    omit?: CancellationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationInclude<ExtArgs> | null
    where?: CancellationWhereInput
  }

  /**
   * Booking.Hotel
   */
  export type Booking$HotelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    where?: HotelWhereInput
  }

  /**
   * Booking without action
   */
  export type BookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    bookingId: number | null
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    bookingId: number | null
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    bookingId: number | null
    amount: number | null
    currency: $Enums.CurrencyCode | null
    paymentMethod: $Enums.PaymentMethod | null
    paymentGatewayId: string | null
    status: $Enums.PaymentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    bookingId: number | null
    amount: number | null
    currency: $Enums.CurrencyCode | null
    paymentMethod: $Enums.PaymentMethod | null
    paymentGatewayId: string | null
    status: $Enums.PaymentStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    bookingId: number
    amount: number
    currency: number
    paymentMethod: number
    paymentGatewayId: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    bookingId?: true
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    bookingId?: true
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    bookingId?: true
    amount?: true
    currency?: true
    paymentMethod?: true
    paymentGatewayId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    bookingId?: true
    amount?: true
    currency?: true
    paymentMethod?: true
    paymentGatewayId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    bookingId?: true
    amount?: true
    currency?: true
    paymentMethod?: true
    paymentGatewayId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    bookingId: number
    amount: number
    currency: $Enums.CurrencyCode
    paymentMethod: $Enums.PaymentMethod | null
    paymentGatewayId: string | null
    status: $Enums.PaymentStatus
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    amount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    paymentGatewayId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Booking?: boolean | BookingDefaultArgs<ExtArgs>
    transactions?: boolean | Payment$transactionsArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    amount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    paymentGatewayId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    amount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    paymentGatewayId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    bookingId?: boolean
    amount?: boolean
    currency?: boolean
    paymentMethod?: boolean
    paymentGatewayId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "amount" | "currency" | "paymentMethod" | "paymentGatewayId" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Booking?: boolean | BookingDefaultArgs<ExtArgs>
    transactions?: boolean | Payment$transactionsArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Booking?: boolean | BookingDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Booking?: boolean | BookingDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      Booking: Prisma.$BookingPayload<ExtArgs>
      /**
       * Detailed transaction ledger
       */
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingId: number
      amount: number
      currency: $Enums.CurrencyCode
      paymentMethod: $Enums.PaymentMethod | null
      /**
       * Transaction ID from payment provider
       */
      paymentGatewayId: string | null
      status: $Enums.PaymentStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transactions<T extends Payment$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Payment$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly bookingId: FieldRef<"Payment", 'Int'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly currency: FieldRef<"Payment", 'CurrencyCode'>
    readonly paymentMethod: FieldRef<"Payment", 'PaymentMethod'>
    readonly paymentGatewayId: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'PaymentStatus'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment.transactions
   */
  export type Payment$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: number | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    paymentId: string | null
    type: $Enums.TransactionType | null
    amount: number | null
    currency: $Enums.CurrencyCode | null
    timestamp: Date | null
    status: $Enums.TransactionStatus | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    paymentId: string | null
    type: $Enums.TransactionType | null
    amount: number | null
    currency: $Enums.CurrencyCode | null
    timestamp: Date | null
    status: $Enums.TransactionStatus | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    paymentId: number
    type: number
    amount: number
    currency: number
    gatewayResponse: number
    timestamp: number
    status: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    paymentId?: true
    type?: true
    amount?: true
    currency?: true
    timestamp?: true
    status?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    paymentId?: true
    type?: true
    amount?: true
    currency?: true
    timestamp?: true
    status?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    paymentId?: true
    type?: true
    amount?: true
    currency?: true
    gatewayResponse?: true
    timestamp?: true
    status?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    paymentId: string
    type: $Enums.TransactionType
    amount: number
    currency: $Enums.CurrencyCode
    gatewayResponse: JsonValue | null
    timestamp: Date
    status: $Enums.TransactionStatus
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentId?: boolean
    type?: boolean
    amount?: boolean
    currency?: boolean
    gatewayResponse?: boolean
    timestamp?: boolean
    status?: boolean
    Payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentId?: boolean
    type?: boolean
    amount?: boolean
    currency?: boolean
    gatewayResponse?: boolean
    timestamp?: boolean
    status?: boolean
    Payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentId?: boolean
    type?: boolean
    amount?: boolean
    currency?: boolean
    gatewayResponse?: boolean
    timestamp?: boolean
    status?: boolean
    Payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    paymentId?: boolean
    type?: boolean
    amount?: boolean
    currency?: boolean
    gatewayResponse?: boolean
    timestamp?: boolean
    status?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "paymentId" | "type" | "amount" | "currency" | "gatewayResponse" | "timestamp" | "status", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      Payment: Prisma.$PaymentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      paymentId: string
      type: $Enums.TransactionType
      amount: number
      currency: $Enums.CurrencyCode
      /**
       * Raw response from payment gateway
       */
      gatewayResponse: Prisma.JsonValue | null
      timestamp: Date
      /**
       * Status of this specific attempt
       */
      status: $Enums.TransactionStatus
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Payment<T extends PaymentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentDefaultArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly paymentId: FieldRef<"Transaction", 'String'>
    readonly type: FieldRef<"Transaction", 'TransactionType'>
    readonly amount: FieldRef<"Transaction", 'Float'>
    readonly currency: FieldRef<"Transaction", 'CurrencyCode'>
    readonly gatewayResponse: FieldRef<"Transaction", 'Json'>
    readonly timestamp: FieldRef<"Transaction", 'DateTime'>
    readonly status: FieldRef<"Transaction", 'TransactionStatus'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction updateManyAndReturn
   */
  export type TransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    id: number | null
    bookingId: number | null
    userId: number | null
    rating: number | null
    hotelId: number | null
  }

  export type ReviewSumAggregateOutputType = {
    id: number | null
    bookingId: number | null
    userId: number | null
    rating: number | null
    hotelId: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: number | null
    bookingId: number | null
    userId: number | null
    rating: number | null
    title: string | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
    hotelId: number | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: number | null
    bookingId: number | null
    userId: number | null
    rating: number | null
    title: string | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
    hotelId: number | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    bookingId: number
    userId: number
    rating: number
    title: number
    comment: number
    createdAt: number
    updatedAt: number
    hotelId: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    id?: true
    bookingId?: true
    userId?: true
    rating?: true
    hotelId?: true
  }

  export type ReviewSumAggregateInputType = {
    id?: true
    bookingId?: true
    userId?: true
    rating?: true
    hotelId?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    bookingId?: true
    userId?: true
    rating?: true
    title?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
    hotelId?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    bookingId?: true
    userId?: true
    rating?: true
    title?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
    hotelId?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    bookingId?: true
    userId?: true
    rating?: true
    title?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
    hotelId?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: number
    bookingId: number
    userId: number
    rating: number
    title: string | null
    comment: string | null
    createdAt: Date
    updatedAt: Date
    hotelId: number | null
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    userId?: boolean
    rating?: boolean
    title?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelId?: boolean
    Booking?: boolean | BookingDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    Hotel?: boolean | Review$HotelArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    userId?: boolean
    rating?: boolean
    title?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelId?: boolean
    Booking?: boolean | BookingDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    Hotel?: boolean | Review$HotelArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    userId?: boolean
    rating?: boolean
    title?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelId?: boolean
    Booking?: boolean | BookingDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    Hotel?: boolean | Review$HotelArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    id?: boolean
    bookingId?: boolean
    userId?: boolean
    rating?: boolean
    title?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelId?: boolean
  }

  export type ReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "userId" | "rating" | "title" | "comment" | "createdAt" | "updatedAt" | "hotelId", ExtArgs["result"]["review"]>
  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Booking?: boolean | BookingDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    Hotel?: boolean | Review$HotelArgs<ExtArgs>
  }
  export type ReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Booking?: boolean | BookingDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    Hotel?: boolean | Review$HotelArgs<ExtArgs>
  }
  export type ReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Booking?: boolean | BookingDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    Hotel?: boolean | Review$HotelArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      Booking: Prisma.$BookingPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>
      Hotel: Prisma.$HotelPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      /**
       * Ensures review is tied to a verified stay
       */
      bookingId: number
      userId: number
      /**
       * e.g., 1-5 stars
       */
      rating: number
      title: string | null
      comment: string | null
      createdAt: Date
      updatedAt: Date
      hotelId: number | null
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews and returns the data updated in the database.
     * @param {ReviewUpdateManyAndReturnArgs} args - Arguments to update many Reviews.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Hotel<T extends Review$HotelArgs<ExtArgs> = {}>(args?: Subset<T, Review$HotelArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'Int'>
    readonly bookingId: FieldRef<"Review", 'Int'>
    readonly userId: FieldRef<"Review", 'Int'>
    readonly rating: FieldRef<"Review", 'Int'>
    readonly title: FieldRef<"Review", 'String'>
    readonly comment: FieldRef<"Review", 'String'>
    readonly createdAt: FieldRef<"Review", 'DateTime'>
    readonly updatedAt: FieldRef<"Review", 'DateTime'>
    readonly hotelId: FieldRef<"Review", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
  }

  /**
   * Review updateManyAndReturn
   */
  export type ReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to delete.
     */
    limit?: number
  }

  /**
   * Review.Hotel
   */
  export type Review$HotelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    where?: HotelWhereInput
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model Promotion
   */

  export type AggregatePromotion = {
    _count: PromotionCountAggregateOutputType | null
    _avg: PromotionAvgAggregateOutputType | null
    _sum: PromotionSumAggregateOutputType | null
    _min: PromotionMinAggregateOutputType | null
    _max: PromotionMaxAggregateOutputType | null
  }

  export type PromotionAvgAggregateOutputType = {
    id: number | null
    discountValue: number | null
    maxUses: number | null
    usesPerUser: number | null
    currentUses: number | null
    minNights: number | null
    minAmount: number | null
  }

  export type PromotionSumAggregateOutputType = {
    id: number | null
    discountValue: number | null
    maxUses: number | null
    usesPerUser: number | null
    currentUses: number | null
    minNights: number | null
    minAmount: number | null
  }

  export type PromotionMinAggregateOutputType = {
    id: number | null
    code: string | null
    description: string | null
    discountType: $Enums.DiscountType | null
    discountValue: number | null
    validFrom: Date | null
    validUntil: Date | null
    maxUses: number | null
    usesPerUser: number | null
    currentUses: number | null
    minNights: number | null
    minAmount: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromotionMaxAggregateOutputType = {
    id: number | null
    code: string | null
    description: string | null
    discountType: $Enums.DiscountType | null
    discountValue: number | null
    validFrom: Date | null
    validUntil: Date | null
    maxUses: number | null
    usesPerUser: number | null
    currentUses: number | null
    minNights: number | null
    minAmount: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PromotionCountAggregateOutputType = {
    id: number
    code: number
    description: number
    discountType: number
    discountValue: number
    validFrom: number
    validUntil: number
    maxUses: number
    usesPerUser: number
    currentUses: number
    minNights: number
    minAmount: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PromotionAvgAggregateInputType = {
    id?: true
    discountValue?: true
    maxUses?: true
    usesPerUser?: true
    currentUses?: true
    minNights?: true
    minAmount?: true
  }

  export type PromotionSumAggregateInputType = {
    id?: true
    discountValue?: true
    maxUses?: true
    usesPerUser?: true
    currentUses?: true
    minNights?: true
    minAmount?: true
  }

  export type PromotionMinAggregateInputType = {
    id?: true
    code?: true
    description?: true
    discountType?: true
    discountValue?: true
    validFrom?: true
    validUntil?: true
    maxUses?: true
    usesPerUser?: true
    currentUses?: true
    minNights?: true
    minAmount?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromotionMaxAggregateInputType = {
    id?: true
    code?: true
    description?: true
    discountType?: true
    discountValue?: true
    validFrom?: true
    validUntil?: true
    maxUses?: true
    usesPerUser?: true
    currentUses?: true
    minNights?: true
    minAmount?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PromotionCountAggregateInputType = {
    id?: true
    code?: true
    description?: true
    discountType?: true
    discountValue?: true
    validFrom?: true
    validUntil?: true
    maxUses?: true
    usesPerUser?: true
    currentUses?: true
    minNights?: true
    minAmount?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PromotionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Promotion to aggregate.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Promotions
    **/
    _count?: true | PromotionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PromotionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PromotionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromotionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromotionMaxAggregateInputType
  }

  export type GetPromotionAggregateType<T extends PromotionAggregateArgs> = {
        [P in keyof T & keyof AggregatePromotion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromotion[P]>
      : GetScalarType<T[P], AggregatePromotion[P]>
  }




  export type PromotionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionWhereInput
    orderBy?: PromotionOrderByWithAggregationInput | PromotionOrderByWithAggregationInput[]
    by: PromotionScalarFieldEnum[] | PromotionScalarFieldEnum
    having?: PromotionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromotionCountAggregateInputType | true
    _avg?: PromotionAvgAggregateInputType
    _sum?: PromotionSumAggregateInputType
    _min?: PromotionMinAggregateInputType
    _max?: PromotionMaxAggregateInputType
  }

  export type PromotionGroupByOutputType = {
    id: number
    code: string
    description: string | null
    discountType: $Enums.DiscountType
    discountValue: number
    validFrom: Date | null
    validUntil: Date | null
    maxUses: number | null
    usesPerUser: number | null
    currentUses: number
    minNights: number | null
    minAmount: number | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: PromotionCountAggregateOutputType | null
    _avg: PromotionAvgAggregateOutputType | null
    _sum: PromotionSumAggregateOutputType | null
    _min: PromotionMinAggregateOutputType | null
    _max: PromotionMaxAggregateOutputType | null
  }

  type GetPromotionGroupByPayload<T extends PromotionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromotionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromotionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromotionGroupByOutputType[P]>
            : GetScalarType<T[P], PromotionGroupByOutputType[P]>
        }
      >
    >


  export type PromotionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    discountType?: boolean
    discountValue?: boolean
    validFrom?: boolean
    validUntil?: boolean
    maxUses?: boolean
    usesPerUser?: boolean
    currentUses?: boolean
    minNights?: boolean
    minAmount?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookings?: boolean | Promotion$bookingsArgs<ExtArgs>
    PromotionHotel?: boolean | Promotion$PromotionHotelArgs<ExtArgs>
    PromotionRoomType?: boolean | Promotion$PromotionRoomTypeArgs<ExtArgs>
    _count?: boolean | PromotionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promotion"]>

  export type PromotionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    discountType?: boolean
    discountValue?: boolean
    validFrom?: boolean
    validUntil?: boolean
    maxUses?: boolean
    usesPerUser?: boolean
    currentUses?: boolean
    minNights?: boolean
    minAmount?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["promotion"]>

  export type PromotionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    discountType?: boolean
    discountValue?: boolean
    validFrom?: boolean
    validUntil?: boolean
    maxUses?: boolean
    usesPerUser?: boolean
    currentUses?: boolean
    minNights?: boolean
    minAmount?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["promotion"]>

  export type PromotionSelectScalar = {
    id?: boolean
    code?: boolean
    description?: boolean
    discountType?: boolean
    discountValue?: boolean
    validFrom?: boolean
    validUntil?: boolean
    maxUses?: boolean
    usesPerUser?: boolean
    currentUses?: boolean
    minNights?: boolean
    minAmount?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PromotionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "description" | "discountType" | "discountValue" | "validFrom" | "validUntil" | "maxUses" | "usesPerUser" | "currentUses" | "minNights" | "minAmount" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["promotion"]>
  export type PromotionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | Promotion$bookingsArgs<ExtArgs>
    PromotionHotel?: boolean | Promotion$PromotionHotelArgs<ExtArgs>
    PromotionRoomType?: boolean | Promotion$PromotionRoomTypeArgs<ExtArgs>
    _count?: boolean | PromotionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PromotionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PromotionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PromotionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Promotion"
    objects: {
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      PromotionHotel: Prisma.$PromotionHotelPayload<ExtArgs>[]
      PromotionRoomType: Prisma.$PromotionRoomTypePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      /**
       * User-facing promo code
       */
      code: string
      description: string | null
      discountType: $Enums.DiscountType
      discountValue: number
      validFrom: Date | null
      validUntil: Date | null
      /**
       * Max total uses allowed
       */
      maxUses: number | null
      /**
       * Max uses per customer
       */
      usesPerUser: number | null
      currentUses: number
      /**
       * Minimum stay duration
       */
      minNights: number | null
      /**
       * Minimum booking value
       */
      minAmount: number | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["promotion"]>
    composites: {}
  }

  type PromotionGetPayload<S extends boolean | null | undefined | PromotionDefaultArgs> = $Result.GetResult<Prisma.$PromotionPayload, S>

  type PromotionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PromotionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PromotionCountAggregateInputType | true
    }

  export interface PromotionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Promotion'], meta: { name: 'Promotion' } }
    /**
     * Find zero or one Promotion that matches the filter.
     * @param {PromotionFindUniqueArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromotionFindUniqueArgs>(args: SelectSubset<T, PromotionFindUniqueArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Promotion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PromotionFindUniqueOrThrowArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromotionFindUniqueOrThrowArgs>(args: SelectSubset<T, PromotionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Promotion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindFirstArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromotionFindFirstArgs>(args?: SelectSubset<T, PromotionFindFirstArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Promotion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindFirstOrThrowArgs} args - Arguments to find a Promotion
     * @example
     * // Get one Promotion
     * const promotion = await prisma.promotion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromotionFindFirstOrThrowArgs>(args?: SelectSubset<T, PromotionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Promotions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Promotions
     * const promotions = await prisma.promotion.findMany()
     * 
     * // Get first 10 Promotions
     * const promotions = await prisma.promotion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promotionWithIdOnly = await prisma.promotion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromotionFindManyArgs>(args?: SelectSubset<T, PromotionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Promotion.
     * @param {PromotionCreateArgs} args - Arguments to create a Promotion.
     * @example
     * // Create one Promotion
     * const Promotion = await prisma.promotion.create({
     *   data: {
     *     // ... data to create a Promotion
     *   }
     * })
     * 
     */
    create<T extends PromotionCreateArgs>(args: SelectSubset<T, PromotionCreateArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Promotions.
     * @param {PromotionCreateManyArgs} args - Arguments to create many Promotions.
     * @example
     * // Create many Promotions
     * const promotion = await prisma.promotion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromotionCreateManyArgs>(args?: SelectSubset<T, PromotionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Promotions and returns the data saved in the database.
     * @param {PromotionCreateManyAndReturnArgs} args - Arguments to create many Promotions.
     * @example
     * // Create many Promotions
     * const promotion = await prisma.promotion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Promotions and only return the `id`
     * const promotionWithIdOnly = await prisma.promotion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PromotionCreateManyAndReturnArgs>(args?: SelectSubset<T, PromotionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Promotion.
     * @param {PromotionDeleteArgs} args - Arguments to delete one Promotion.
     * @example
     * // Delete one Promotion
     * const Promotion = await prisma.promotion.delete({
     *   where: {
     *     // ... filter to delete one Promotion
     *   }
     * })
     * 
     */
    delete<T extends PromotionDeleteArgs>(args: SelectSubset<T, PromotionDeleteArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Promotion.
     * @param {PromotionUpdateArgs} args - Arguments to update one Promotion.
     * @example
     * // Update one Promotion
     * const promotion = await prisma.promotion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromotionUpdateArgs>(args: SelectSubset<T, PromotionUpdateArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Promotions.
     * @param {PromotionDeleteManyArgs} args - Arguments to filter Promotions to delete.
     * @example
     * // Delete a few Promotions
     * const { count } = await prisma.promotion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromotionDeleteManyArgs>(args?: SelectSubset<T, PromotionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Promotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Promotions
     * const promotion = await prisma.promotion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromotionUpdateManyArgs>(args: SelectSubset<T, PromotionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Promotions and returns the data updated in the database.
     * @param {PromotionUpdateManyAndReturnArgs} args - Arguments to update many Promotions.
     * @example
     * // Update many Promotions
     * const promotion = await prisma.promotion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Promotions and only return the `id`
     * const promotionWithIdOnly = await prisma.promotion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PromotionUpdateManyAndReturnArgs>(args: SelectSubset<T, PromotionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Promotion.
     * @param {PromotionUpsertArgs} args - Arguments to update or create a Promotion.
     * @example
     * // Update or create a Promotion
     * const promotion = await prisma.promotion.upsert({
     *   create: {
     *     // ... data to create a Promotion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Promotion we want to update
     *   }
     * })
     */
    upsert<T extends PromotionUpsertArgs>(args: SelectSubset<T, PromotionUpsertArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Promotions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionCountArgs} args - Arguments to filter Promotions to count.
     * @example
     * // Count the number of Promotions
     * const count = await prisma.promotion.count({
     *   where: {
     *     // ... the filter for the Promotions we want to count
     *   }
     * })
    **/
    count<T extends PromotionCountArgs>(
      args?: Subset<T, PromotionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromotionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Promotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromotionAggregateArgs>(args: Subset<T, PromotionAggregateArgs>): Prisma.PrismaPromise<GetPromotionAggregateType<T>>

    /**
     * Group by Promotion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromotionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromotionGroupByArgs['orderBy'] }
        : { orderBy?: PromotionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromotionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromotionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Promotion model
   */
  readonly fields: PromotionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Promotion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromotionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookings<T extends Promotion$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Promotion$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PromotionHotel<T extends Promotion$PromotionHotelArgs<ExtArgs> = {}>(args?: Subset<T, Promotion$PromotionHotelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionHotelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PromotionRoomType<T extends Promotion$PromotionRoomTypeArgs<ExtArgs> = {}>(args?: Subset<T, Promotion$PromotionRoomTypeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionRoomTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Promotion model
   */
  interface PromotionFieldRefs {
    readonly id: FieldRef<"Promotion", 'Int'>
    readonly code: FieldRef<"Promotion", 'String'>
    readonly description: FieldRef<"Promotion", 'String'>
    readonly discountType: FieldRef<"Promotion", 'DiscountType'>
    readonly discountValue: FieldRef<"Promotion", 'Float'>
    readonly validFrom: FieldRef<"Promotion", 'DateTime'>
    readonly validUntil: FieldRef<"Promotion", 'DateTime'>
    readonly maxUses: FieldRef<"Promotion", 'Int'>
    readonly usesPerUser: FieldRef<"Promotion", 'Int'>
    readonly currentUses: FieldRef<"Promotion", 'Int'>
    readonly minNights: FieldRef<"Promotion", 'Int'>
    readonly minAmount: FieldRef<"Promotion", 'Float'>
    readonly isActive: FieldRef<"Promotion", 'Boolean'>
    readonly createdAt: FieldRef<"Promotion", 'DateTime'>
    readonly updatedAt: FieldRef<"Promotion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Promotion findUnique
   */
  export type PromotionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion findUniqueOrThrow
   */
  export type PromotionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion findFirst
   */
  export type PromotionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Promotions.
     */
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Promotion findFirstOrThrow
   */
  export type PromotionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotion to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Promotions.
     */
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Promotion findMany
   */
  export type PromotionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter, which Promotions to fetch.
     */
    where?: PromotionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Promotions to fetch.
     */
    orderBy?: PromotionOrderByWithRelationInput | PromotionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Promotions.
     */
    cursor?: PromotionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Promotions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Promotions.
     */
    skip?: number
    distinct?: PromotionScalarFieldEnum | PromotionScalarFieldEnum[]
  }

  /**
   * Promotion create
   */
  export type PromotionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * The data needed to create a Promotion.
     */
    data: XOR<PromotionCreateInput, PromotionUncheckedCreateInput>
  }

  /**
   * Promotion createMany
   */
  export type PromotionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Promotions.
     */
    data: PromotionCreateManyInput | PromotionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Promotion createManyAndReturn
   */
  export type PromotionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * The data used to create many Promotions.
     */
    data: PromotionCreateManyInput | PromotionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Promotion update
   */
  export type PromotionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * The data needed to update a Promotion.
     */
    data: XOR<PromotionUpdateInput, PromotionUncheckedUpdateInput>
    /**
     * Choose, which Promotion to update.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion updateMany
   */
  export type PromotionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Promotions.
     */
    data: XOR<PromotionUpdateManyMutationInput, PromotionUncheckedUpdateManyInput>
    /**
     * Filter which Promotions to update
     */
    where?: PromotionWhereInput
    /**
     * Limit how many Promotions to update.
     */
    limit?: number
  }

  /**
   * Promotion updateManyAndReturn
   */
  export type PromotionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * The data used to update Promotions.
     */
    data: XOR<PromotionUpdateManyMutationInput, PromotionUncheckedUpdateManyInput>
    /**
     * Filter which Promotions to update
     */
    where?: PromotionWhereInput
    /**
     * Limit how many Promotions to update.
     */
    limit?: number
  }

  /**
   * Promotion upsert
   */
  export type PromotionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * The filter to search for the Promotion to update in case it exists.
     */
    where: PromotionWhereUniqueInput
    /**
     * In case the Promotion found by the `where` argument doesn't exist, create a new Promotion with this data.
     */
    create: XOR<PromotionCreateInput, PromotionUncheckedCreateInput>
    /**
     * In case the Promotion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromotionUpdateInput, PromotionUncheckedUpdateInput>
  }

  /**
   * Promotion delete
   */
  export type PromotionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
    /**
     * Filter which Promotion to delete.
     */
    where: PromotionWhereUniqueInput
  }

  /**
   * Promotion deleteMany
   */
  export type PromotionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Promotions to delete
     */
    where?: PromotionWhereInput
    /**
     * Limit how many Promotions to delete.
     */
    limit?: number
  }

  /**
   * Promotion.bookings
   */
  export type Promotion$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Promotion.PromotionHotel
   */
  export type Promotion$PromotionHotelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionHotel
     */
    select?: PromotionHotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionHotel
     */
    omit?: PromotionHotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionHotelInclude<ExtArgs> | null
    where?: PromotionHotelWhereInput
    orderBy?: PromotionHotelOrderByWithRelationInput | PromotionHotelOrderByWithRelationInput[]
    cursor?: PromotionHotelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromotionHotelScalarFieldEnum | PromotionHotelScalarFieldEnum[]
  }

  /**
   * Promotion.PromotionRoomType
   */
  export type Promotion$PromotionRoomTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRoomType
     */
    select?: PromotionRoomTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRoomType
     */
    omit?: PromotionRoomTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRoomTypeInclude<ExtArgs> | null
    where?: PromotionRoomTypeWhereInput
    orderBy?: PromotionRoomTypeOrderByWithRelationInput | PromotionRoomTypeOrderByWithRelationInput[]
    cursor?: PromotionRoomTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromotionRoomTypeScalarFieldEnum | PromotionRoomTypeScalarFieldEnum[]
  }

  /**
   * Promotion without action
   */
  export type PromotionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Promotion
     */
    select?: PromotionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Promotion
     */
    omit?: PromotionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionInclude<ExtArgs> | null
  }


  /**
   * Model CancellationPolicy
   */

  export type AggregateCancellationPolicy = {
    _count: CancellationPolicyCountAggregateOutputType | null
    _avg: CancellationPolicyAvgAggregateOutputType | null
    _sum: CancellationPolicySumAggregateOutputType | null
    _min: CancellationPolicyMinAggregateOutputType | null
    _max: CancellationPolicyMaxAggregateOutputType | null
  }

  export type CancellationPolicyAvgAggregateOutputType = {
    id: number | null
    hotelId: number | null
  }

  export type CancellationPolicySumAggregateOutputType = {
    id: number | null
    hotelId: number | null
  }

  export type CancellationPolicyMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    hotelId: number | null
  }

  export type CancellationPolicyMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    hotelId: number | null
  }

  export type CancellationPolicyCountAggregateOutputType = {
    id: number
    name: number
    description: number
    rules: number
    createdAt: number
    updatedAt: number
    hotelId: number
    _all: number
  }


  export type CancellationPolicyAvgAggregateInputType = {
    id?: true
    hotelId?: true
  }

  export type CancellationPolicySumAggregateInputType = {
    id?: true
    hotelId?: true
  }

  export type CancellationPolicyMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    hotelId?: true
  }

  export type CancellationPolicyMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    hotelId?: true
  }

  export type CancellationPolicyCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    rules?: true
    createdAt?: true
    updatedAt?: true
    hotelId?: true
    _all?: true
  }

  export type CancellationPolicyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CancellationPolicy to aggregate.
     */
    where?: CancellationPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CancellationPolicies to fetch.
     */
    orderBy?: CancellationPolicyOrderByWithRelationInput | CancellationPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CancellationPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CancellationPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CancellationPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CancellationPolicies
    **/
    _count?: true | CancellationPolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CancellationPolicyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CancellationPolicySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CancellationPolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CancellationPolicyMaxAggregateInputType
  }

  export type GetCancellationPolicyAggregateType<T extends CancellationPolicyAggregateArgs> = {
        [P in keyof T & keyof AggregateCancellationPolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCancellationPolicy[P]>
      : GetScalarType<T[P], AggregateCancellationPolicy[P]>
  }




  export type CancellationPolicyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CancellationPolicyWhereInput
    orderBy?: CancellationPolicyOrderByWithAggregationInput | CancellationPolicyOrderByWithAggregationInput[]
    by: CancellationPolicyScalarFieldEnum[] | CancellationPolicyScalarFieldEnum
    having?: CancellationPolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CancellationPolicyCountAggregateInputType | true
    _avg?: CancellationPolicyAvgAggregateInputType
    _sum?: CancellationPolicySumAggregateInputType
    _min?: CancellationPolicyMinAggregateInputType
    _max?: CancellationPolicyMaxAggregateInputType
  }

  export type CancellationPolicyGroupByOutputType = {
    id: number
    name: string
    description: string | null
    rules: JsonValue | null
    createdAt: Date
    updatedAt: Date
    hotelId: number | null
    _count: CancellationPolicyCountAggregateOutputType | null
    _avg: CancellationPolicyAvgAggregateOutputType | null
    _sum: CancellationPolicySumAggregateOutputType | null
    _min: CancellationPolicyMinAggregateOutputType | null
    _max: CancellationPolicyMaxAggregateOutputType | null
  }

  type GetCancellationPolicyGroupByPayload<T extends CancellationPolicyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CancellationPolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CancellationPolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CancellationPolicyGroupByOutputType[P]>
            : GetScalarType<T[P], CancellationPolicyGroupByOutputType[P]>
        }
      >
    >


  export type CancellationPolicySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    rules?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelId?: boolean
    bookings?: boolean | CancellationPolicy$bookingsArgs<ExtArgs>
    Hotel?: boolean | CancellationPolicy$HotelArgs<ExtArgs>
    _count?: boolean | CancellationPolicyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cancellationPolicy"]>

  export type CancellationPolicySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    rules?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelId?: boolean
    Hotel?: boolean | CancellationPolicy$HotelArgs<ExtArgs>
  }, ExtArgs["result"]["cancellationPolicy"]>

  export type CancellationPolicySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    rules?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelId?: boolean
    Hotel?: boolean | CancellationPolicy$HotelArgs<ExtArgs>
  }, ExtArgs["result"]["cancellationPolicy"]>

  export type CancellationPolicySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    rules?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    hotelId?: boolean
  }

  export type CancellationPolicyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "rules" | "createdAt" | "updatedAt" | "hotelId", ExtArgs["result"]["cancellationPolicy"]>
  export type CancellationPolicyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | CancellationPolicy$bookingsArgs<ExtArgs>
    Hotel?: boolean | CancellationPolicy$HotelArgs<ExtArgs>
    _count?: boolean | CancellationPolicyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CancellationPolicyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Hotel?: boolean | CancellationPolicy$HotelArgs<ExtArgs>
  }
  export type CancellationPolicyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Hotel?: boolean | CancellationPolicy$HotelArgs<ExtArgs>
  }

  export type $CancellationPolicyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CancellationPolicy"
    objects: {
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      Hotel: Prisma.$HotelPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      /**
       * Store complex rules as JSON (e.g., deadlines, fees)
       */
      rules: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      hotelId: number | null
    }, ExtArgs["result"]["cancellationPolicy"]>
    composites: {}
  }

  type CancellationPolicyGetPayload<S extends boolean | null | undefined | CancellationPolicyDefaultArgs> = $Result.GetResult<Prisma.$CancellationPolicyPayload, S>

  type CancellationPolicyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CancellationPolicyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CancellationPolicyCountAggregateInputType | true
    }

  export interface CancellationPolicyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CancellationPolicy'], meta: { name: 'CancellationPolicy' } }
    /**
     * Find zero or one CancellationPolicy that matches the filter.
     * @param {CancellationPolicyFindUniqueArgs} args - Arguments to find a CancellationPolicy
     * @example
     * // Get one CancellationPolicy
     * const cancellationPolicy = await prisma.cancellationPolicy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CancellationPolicyFindUniqueArgs>(args: SelectSubset<T, CancellationPolicyFindUniqueArgs<ExtArgs>>): Prisma__CancellationPolicyClient<$Result.GetResult<Prisma.$CancellationPolicyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CancellationPolicy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CancellationPolicyFindUniqueOrThrowArgs} args - Arguments to find a CancellationPolicy
     * @example
     * // Get one CancellationPolicy
     * const cancellationPolicy = await prisma.cancellationPolicy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CancellationPolicyFindUniqueOrThrowArgs>(args: SelectSubset<T, CancellationPolicyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CancellationPolicyClient<$Result.GetResult<Prisma.$CancellationPolicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CancellationPolicy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CancellationPolicyFindFirstArgs} args - Arguments to find a CancellationPolicy
     * @example
     * // Get one CancellationPolicy
     * const cancellationPolicy = await prisma.cancellationPolicy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CancellationPolicyFindFirstArgs>(args?: SelectSubset<T, CancellationPolicyFindFirstArgs<ExtArgs>>): Prisma__CancellationPolicyClient<$Result.GetResult<Prisma.$CancellationPolicyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CancellationPolicy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CancellationPolicyFindFirstOrThrowArgs} args - Arguments to find a CancellationPolicy
     * @example
     * // Get one CancellationPolicy
     * const cancellationPolicy = await prisma.cancellationPolicy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CancellationPolicyFindFirstOrThrowArgs>(args?: SelectSubset<T, CancellationPolicyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CancellationPolicyClient<$Result.GetResult<Prisma.$CancellationPolicyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CancellationPolicies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CancellationPolicyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CancellationPolicies
     * const cancellationPolicies = await prisma.cancellationPolicy.findMany()
     * 
     * // Get first 10 CancellationPolicies
     * const cancellationPolicies = await prisma.cancellationPolicy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cancellationPolicyWithIdOnly = await prisma.cancellationPolicy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CancellationPolicyFindManyArgs>(args?: SelectSubset<T, CancellationPolicyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CancellationPolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CancellationPolicy.
     * @param {CancellationPolicyCreateArgs} args - Arguments to create a CancellationPolicy.
     * @example
     * // Create one CancellationPolicy
     * const CancellationPolicy = await prisma.cancellationPolicy.create({
     *   data: {
     *     // ... data to create a CancellationPolicy
     *   }
     * })
     * 
     */
    create<T extends CancellationPolicyCreateArgs>(args: SelectSubset<T, CancellationPolicyCreateArgs<ExtArgs>>): Prisma__CancellationPolicyClient<$Result.GetResult<Prisma.$CancellationPolicyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CancellationPolicies.
     * @param {CancellationPolicyCreateManyArgs} args - Arguments to create many CancellationPolicies.
     * @example
     * // Create many CancellationPolicies
     * const cancellationPolicy = await prisma.cancellationPolicy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CancellationPolicyCreateManyArgs>(args?: SelectSubset<T, CancellationPolicyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CancellationPolicies and returns the data saved in the database.
     * @param {CancellationPolicyCreateManyAndReturnArgs} args - Arguments to create many CancellationPolicies.
     * @example
     * // Create many CancellationPolicies
     * const cancellationPolicy = await prisma.cancellationPolicy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CancellationPolicies and only return the `id`
     * const cancellationPolicyWithIdOnly = await prisma.cancellationPolicy.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CancellationPolicyCreateManyAndReturnArgs>(args?: SelectSubset<T, CancellationPolicyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CancellationPolicyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CancellationPolicy.
     * @param {CancellationPolicyDeleteArgs} args - Arguments to delete one CancellationPolicy.
     * @example
     * // Delete one CancellationPolicy
     * const CancellationPolicy = await prisma.cancellationPolicy.delete({
     *   where: {
     *     // ... filter to delete one CancellationPolicy
     *   }
     * })
     * 
     */
    delete<T extends CancellationPolicyDeleteArgs>(args: SelectSubset<T, CancellationPolicyDeleteArgs<ExtArgs>>): Prisma__CancellationPolicyClient<$Result.GetResult<Prisma.$CancellationPolicyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CancellationPolicy.
     * @param {CancellationPolicyUpdateArgs} args - Arguments to update one CancellationPolicy.
     * @example
     * // Update one CancellationPolicy
     * const cancellationPolicy = await prisma.cancellationPolicy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CancellationPolicyUpdateArgs>(args: SelectSubset<T, CancellationPolicyUpdateArgs<ExtArgs>>): Prisma__CancellationPolicyClient<$Result.GetResult<Prisma.$CancellationPolicyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CancellationPolicies.
     * @param {CancellationPolicyDeleteManyArgs} args - Arguments to filter CancellationPolicies to delete.
     * @example
     * // Delete a few CancellationPolicies
     * const { count } = await prisma.cancellationPolicy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CancellationPolicyDeleteManyArgs>(args?: SelectSubset<T, CancellationPolicyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CancellationPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CancellationPolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CancellationPolicies
     * const cancellationPolicy = await prisma.cancellationPolicy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CancellationPolicyUpdateManyArgs>(args: SelectSubset<T, CancellationPolicyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CancellationPolicies and returns the data updated in the database.
     * @param {CancellationPolicyUpdateManyAndReturnArgs} args - Arguments to update many CancellationPolicies.
     * @example
     * // Update many CancellationPolicies
     * const cancellationPolicy = await prisma.cancellationPolicy.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CancellationPolicies and only return the `id`
     * const cancellationPolicyWithIdOnly = await prisma.cancellationPolicy.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CancellationPolicyUpdateManyAndReturnArgs>(args: SelectSubset<T, CancellationPolicyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CancellationPolicyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CancellationPolicy.
     * @param {CancellationPolicyUpsertArgs} args - Arguments to update or create a CancellationPolicy.
     * @example
     * // Update or create a CancellationPolicy
     * const cancellationPolicy = await prisma.cancellationPolicy.upsert({
     *   create: {
     *     // ... data to create a CancellationPolicy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CancellationPolicy we want to update
     *   }
     * })
     */
    upsert<T extends CancellationPolicyUpsertArgs>(args: SelectSubset<T, CancellationPolicyUpsertArgs<ExtArgs>>): Prisma__CancellationPolicyClient<$Result.GetResult<Prisma.$CancellationPolicyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CancellationPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CancellationPolicyCountArgs} args - Arguments to filter CancellationPolicies to count.
     * @example
     * // Count the number of CancellationPolicies
     * const count = await prisma.cancellationPolicy.count({
     *   where: {
     *     // ... the filter for the CancellationPolicies we want to count
     *   }
     * })
    **/
    count<T extends CancellationPolicyCountArgs>(
      args?: Subset<T, CancellationPolicyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CancellationPolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CancellationPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CancellationPolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CancellationPolicyAggregateArgs>(args: Subset<T, CancellationPolicyAggregateArgs>): Prisma.PrismaPromise<GetCancellationPolicyAggregateType<T>>

    /**
     * Group by CancellationPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CancellationPolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CancellationPolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CancellationPolicyGroupByArgs['orderBy'] }
        : { orderBy?: CancellationPolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CancellationPolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCancellationPolicyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CancellationPolicy model
   */
  readonly fields: CancellationPolicyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CancellationPolicy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CancellationPolicyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookings<T extends CancellationPolicy$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, CancellationPolicy$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Hotel<T extends CancellationPolicy$HotelArgs<ExtArgs> = {}>(args?: Subset<T, CancellationPolicy$HotelArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CancellationPolicy model
   */
  interface CancellationPolicyFieldRefs {
    readonly id: FieldRef<"CancellationPolicy", 'Int'>
    readonly name: FieldRef<"CancellationPolicy", 'String'>
    readonly description: FieldRef<"CancellationPolicy", 'String'>
    readonly rules: FieldRef<"CancellationPolicy", 'Json'>
    readonly createdAt: FieldRef<"CancellationPolicy", 'DateTime'>
    readonly updatedAt: FieldRef<"CancellationPolicy", 'DateTime'>
    readonly hotelId: FieldRef<"CancellationPolicy", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CancellationPolicy findUnique
   */
  export type CancellationPolicyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationPolicy
     */
    select?: CancellationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CancellationPolicy
     */
    omit?: CancellationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationPolicyInclude<ExtArgs> | null
    /**
     * Filter, which CancellationPolicy to fetch.
     */
    where: CancellationPolicyWhereUniqueInput
  }

  /**
   * CancellationPolicy findUniqueOrThrow
   */
  export type CancellationPolicyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationPolicy
     */
    select?: CancellationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CancellationPolicy
     */
    omit?: CancellationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationPolicyInclude<ExtArgs> | null
    /**
     * Filter, which CancellationPolicy to fetch.
     */
    where: CancellationPolicyWhereUniqueInput
  }

  /**
   * CancellationPolicy findFirst
   */
  export type CancellationPolicyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationPolicy
     */
    select?: CancellationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CancellationPolicy
     */
    omit?: CancellationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationPolicyInclude<ExtArgs> | null
    /**
     * Filter, which CancellationPolicy to fetch.
     */
    where?: CancellationPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CancellationPolicies to fetch.
     */
    orderBy?: CancellationPolicyOrderByWithRelationInput | CancellationPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CancellationPolicies.
     */
    cursor?: CancellationPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CancellationPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CancellationPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CancellationPolicies.
     */
    distinct?: CancellationPolicyScalarFieldEnum | CancellationPolicyScalarFieldEnum[]
  }

  /**
   * CancellationPolicy findFirstOrThrow
   */
  export type CancellationPolicyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationPolicy
     */
    select?: CancellationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CancellationPolicy
     */
    omit?: CancellationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationPolicyInclude<ExtArgs> | null
    /**
     * Filter, which CancellationPolicy to fetch.
     */
    where?: CancellationPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CancellationPolicies to fetch.
     */
    orderBy?: CancellationPolicyOrderByWithRelationInput | CancellationPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CancellationPolicies.
     */
    cursor?: CancellationPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CancellationPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CancellationPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CancellationPolicies.
     */
    distinct?: CancellationPolicyScalarFieldEnum | CancellationPolicyScalarFieldEnum[]
  }

  /**
   * CancellationPolicy findMany
   */
  export type CancellationPolicyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationPolicy
     */
    select?: CancellationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CancellationPolicy
     */
    omit?: CancellationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationPolicyInclude<ExtArgs> | null
    /**
     * Filter, which CancellationPolicies to fetch.
     */
    where?: CancellationPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CancellationPolicies to fetch.
     */
    orderBy?: CancellationPolicyOrderByWithRelationInput | CancellationPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CancellationPolicies.
     */
    cursor?: CancellationPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CancellationPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CancellationPolicies.
     */
    skip?: number
    distinct?: CancellationPolicyScalarFieldEnum | CancellationPolicyScalarFieldEnum[]
  }

  /**
   * CancellationPolicy create
   */
  export type CancellationPolicyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationPolicy
     */
    select?: CancellationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CancellationPolicy
     */
    omit?: CancellationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationPolicyInclude<ExtArgs> | null
    /**
     * The data needed to create a CancellationPolicy.
     */
    data: XOR<CancellationPolicyCreateInput, CancellationPolicyUncheckedCreateInput>
  }

  /**
   * CancellationPolicy createMany
   */
  export type CancellationPolicyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CancellationPolicies.
     */
    data: CancellationPolicyCreateManyInput | CancellationPolicyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CancellationPolicy createManyAndReturn
   */
  export type CancellationPolicyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationPolicy
     */
    select?: CancellationPolicySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CancellationPolicy
     */
    omit?: CancellationPolicyOmit<ExtArgs> | null
    /**
     * The data used to create many CancellationPolicies.
     */
    data: CancellationPolicyCreateManyInput | CancellationPolicyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationPolicyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CancellationPolicy update
   */
  export type CancellationPolicyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationPolicy
     */
    select?: CancellationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CancellationPolicy
     */
    omit?: CancellationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationPolicyInclude<ExtArgs> | null
    /**
     * The data needed to update a CancellationPolicy.
     */
    data: XOR<CancellationPolicyUpdateInput, CancellationPolicyUncheckedUpdateInput>
    /**
     * Choose, which CancellationPolicy to update.
     */
    where: CancellationPolicyWhereUniqueInput
  }

  /**
   * CancellationPolicy updateMany
   */
  export type CancellationPolicyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CancellationPolicies.
     */
    data: XOR<CancellationPolicyUpdateManyMutationInput, CancellationPolicyUncheckedUpdateManyInput>
    /**
     * Filter which CancellationPolicies to update
     */
    where?: CancellationPolicyWhereInput
    /**
     * Limit how many CancellationPolicies to update.
     */
    limit?: number
  }

  /**
   * CancellationPolicy updateManyAndReturn
   */
  export type CancellationPolicyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationPolicy
     */
    select?: CancellationPolicySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CancellationPolicy
     */
    omit?: CancellationPolicyOmit<ExtArgs> | null
    /**
     * The data used to update CancellationPolicies.
     */
    data: XOR<CancellationPolicyUpdateManyMutationInput, CancellationPolicyUncheckedUpdateManyInput>
    /**
     * Filter which CancellationPolicies to update
     */
    where?: CancellationPolicyWhereInput
    /**
     * Limit how many CancellationPolicies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationPolicyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CancellationPolicy upsert
   */
  export type CancellationPolicyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationPolicy
     */
    select?: CancellationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CancellationPolicy
     */
    omit?: CancellationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationPolicyInclude<ExtArgs> | null
    /**
     * The filter to search for the CancellationPolicy to update in case it exists.
     */
    where: CancellationPolicyWhereUniqueInput
    /**
     * In case the CancellationPolicy found by the `where` argument doesn't exist, create a new CancellationPolicy with this data.
     */
    create: XOR<CancellationPolicyCreateInput, CancellationPolicyUncheckedCreateInput>
    /**
     * In case the CancellationPolicy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CancellationPolicyUpdateInput, CancellationPolicyUncheckedUpdateInput>
  }

  /**
   * CancellationPolicy delete
   */
  export type CancellationPolicyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationPolicy
     */
    select?: CancellationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CancellationPolicy
     */
    omit?: CancellationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationPolicyInclude<ExtArgs> | null
    /**
     * Filter which CancellationPolicy to delete.
     */
    where: CancellationPolicyWhereUniqueInput
  }

  /**
   * CancellationPolicy deleteMany
   */
  export type CancellationPolicyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CancellationPolicies to delete
     */
    where?: CancellationPolicyWhereInput
    /**
     * Limit how many CancellationPolicies to delete.
     */
    limit?: number
  }

  /**
   * CancellationPolicy.bookings
   */
  export type CancellationPolicy$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * CancellationPolicy.Hotel
   */
  export type CancellationPolicy$HotelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hotel
     */
    omit?: HotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    where?: HotelWhereInput
  }

  /**
   * CancellationPolicy without action
   */
  export type CancellationPolicyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationPolicy
     */
    select?: CancellationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CancellationPolicy
     */
    omit?: CancellationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationPolicyInclude<ExtArgs> | null
  }


  /**
   * Model Cancellation
   */

  export type AggregateCancellation = {
    _count: CancellationCountAggregateOutputType | null
    _avg: CancellationAvgAggregateOutputType | null
    _sum: CancellationSumAggregateOutputType | null
    _min: CancellationMinAggregateOutputType | null
    _max: CancellationMaxAggregateOutputType | null
  }

  export type CancellationAvgAggregateOutputType = {
    id: number | null
    bookingId: number | null
    processedByUserId: number | null
    refundAmount: number | null
  }

  export type CancellationSumAggregateOutputType = {
    id: number | null
    bookingId: number | null
    processedByUserId: number | null
    refundAmount: number | null
  }

  export type CancellationMinAggregateOutputType = {
    id: number | null
    bookingId: number | null
    reason: string | null
    cancelledAt: Date | null
    processedByUserId: number | null
    refundAmount: number | null
    refundStatus: string | null
    notes: string | null
  }

  export type CancellationMaxAggregateOutputType = {
    id: number | null
    bookingId: number | null
    reason: string | null
    cancelledAt: Date | null
    processedByUserId: number | null
    refundAmount: number | null
    refundStatus: string | null
    notes: string | null
  }

  export type CancellationCountAggregateOutputType = {
    id: number
    bookingId: number
    reason: number
    cancelledAt: number
    processedByUserId: number
    refundAmount: number
    refundStatus: number
    notes: number
    _all: number
  }


  export type CancellationAvgAggregateInputType = {
    id?: true
    bookingId?: true
    processedByUserId?: true
    refundAmount?: true
  }

  export type CancellationSumAggregateInputType = {
    id?: true
    bookingId?: true
    processedByUserId?: true
    refundAmount?: true
  }

  export type CancellationMinAggregateInputType = {
    id?: true
    bookingId?: true
    reason?: true
    cancelledAt?: true
    processedByUserId?: true
    refundAmount?: true
    refundStatus?: true
    notes?: true
  }

  export type CancellationMaxAggregateInputType = {
    id?: true
    bookingId?: true
    reason?: true
    cancelledAt?: true
    processedByUserId?: true
    refundAmount?: true
    refundStatus?: true
    notes?: true
  }

  export type CancellationCountAggregateInputType = {
    id?: true
    bookingId?: true
    reason?: true
    cancelledAt?: true
    processedByUserId?: true
    refundAmount?: true
    refundStatus?: true
    notes?: true
    _all?: true
  }

  export type CancellationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cancellation to aggregate.
     */
    where?: CancellationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cancellations to fetch.
     */
    orderBy?: CancellationOrderByWithRelationInput | CancellationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CancellationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cancellations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cancellations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cancellations
    **/
    _count?: true | CancellationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CancellationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CancellationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CancellationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CancellationMaxAggregateInputType
  }

  export type GetCancellationAggregateType<T extends CancellationAggregateArgs> = {
        [P in keyof T & keyof AggregateCancellation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCancellation[P]>
      : GetScalarType<T[P], AggregateCancellation[P]>
  }




  export type CancellationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CancellationWhereInput
    orderBy?: CancellationOrderByWithAggregationInput | CancellationOrderByWithAggregationInput[]
    by: CancellationScalarFieldEnum[] | CancellationScalarFieldEnum
    having?: CancellationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CancellationCountAggregateInputType | true
    _avg?: CancellationAvgAggregateInputType
    _sum?: CancellationSumAggregateInputType
    _min?: CancellationMinAggregateInputType
    _max?: CancellationMaxAggregateInputType
  }

  export type CancellationGroupByOutputType = {
    id: number
    bookingId: number
    reason: string | null
    cancelledAt: Date
    processedByUserId: number | null
    refundAmount: number | null
    refundStatus: string | null
    notes: string | null
    _count: CancellationCountAggregateOutputType | null
    _avg: CancellationAvgAggregateOutputType | null
    _sum: CancellationSumAggregateOutputType | null
    _min: CancellationMinAggregateOutputType | null
    _max: CancellationMaxAggregateOutputType | null
  }

  type GetCancellationGroupByPayload<T extends CancellationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CancellationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CancellationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CancellationGroupByOutputType[P]>
            : GetScalarType<T[P], CancellationGroupByOutputType[P]>
        }
      >
    >


  export type CancellationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    reason?: boolean
    cancelledAt?: boolean
    processedByUserId?: boolean
    refundAmount?: boolean
    refundStatus?: boolean
    notes?: boolean
    Booking?: boolean | BookingDefaultArgs<ExtArgs>
    User?: boolean | Cancellation$UserArgs<ExtArgs>
  }, ExtArgs["result"]["cancellation"]>

  export type CancellationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    reason?: boolean
    cancelledAt?: boolean
    processedByUserId?: boolean
    refundAmount?: boolean
    refundStatus?: boolean
    notes?: boolean
    Booking?: boolean | BookingDefaultArgs<ExtArgs>
    User?: boolean | Cancellation$UserArgs<ExtArgs>
  }, ExtArgs["result"]["cancellation"]>

  export type CancellationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    reason?: boolean
    cancelledAt?: boolean
    processedByUserId?: boolean
    refundAmount?: boolean
    refundStatus?: boolean
    notes?: boolean
    Booking?: boolean | BookingDefaultArgs<ExtArgs>
    User?: boolean | Cancellation$UserArgs<ExtArgs>
  }, ExtArgs["result"]["cancellation"]>

  export type CancellationSelectScalar = {
    id?: boolean
    bookingId?: boolean
    reason?: boolean
    cancelledAt?: boolean
    processedByUserId?: boolean
    refundAmount?: boolean
    refundStatus?: boolean
    notes?: boolean
  }

  export type CancellationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "reason" | "cancelledAt" | "processedByUserId" | "refundAmount" | "refundStatus" | "notes", ExtArgs["result"]["cancellation"]>
  export type CancellationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Booking?: boolean | BookingDefaultArgs<ExtArgs>
    User?: boolean | Cancellation$UserArgs<ExtArgs>
  }
  export type CancellationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Booking?: boolean | BookingDefaultArgs<ExtArgs>
    User?: boolean | Cancellation$UserArgs<ExtArgs>
  }
  export type CancellationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Booking?: boolean | BookingDefaultArgs<ExtArgs>
    User?: boolean | Cancellation$UserArgs<ExtArgs>
  }

  export type $CancellationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cancellation"
    objects: {
      Booking: Prisma.$BookingPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bookingId: number
      reason: string | null
      cancelledAt: Date
      /**
       * Admin/Staff user who handled it
       */
      processedByUserId: number | null
      refundAmount: number | null
      refundStatus: string | null
      notes: string | null
    }, ExtArgs["result"]["cancellation"]>
    composites: {}
  }

  type CancellationGetPayload<S extends boolean | null | undefined | CancellationDefaultArgs> = $Result.GetResult<Prisma.$CancellationPayload, S>

  type CancellationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CancellationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CancellationCountAggregateInputType | true
    }

  export interface CancellationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cancellation'], meta: { name: 'Cancellation' } }
    /**
     * Find zero or one Cancellation that matches the filter.
     * @param {CancellationFindUniqueArgs} args - Arguments to find a Cancellation
     * @example
     * // Get one Cancellation
     * const cancellation = await prisma.cancellation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CancellationFindUniqueArgs>(args: SelectSubset<T, CancellationFindUniqueArgs<ExtArgs>>): Prisma__CancellationClient<$Result.GetResult<Prisma.$CancellationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cancellation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CancellationFindUniqueOrThrowArgs} args - Arguments to find a Cancellation
     * @example
     * // Get one Cancellation
     * const cancellation = await prisma.cancellation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CancellationFindUniqueOrThrowArgs>(args: SelectSubset<T, CancellationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CancellationClient<$Result.GetResult<Prisma.$CancellationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cancellation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CancellationFindFirstArgs} args - Arguments to find a Cancellation
     * @example
     * // Get one Cancellation
     * const cancellation = await prisma.cancellation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CancellationFindFirstArgs>(args?: SelectSubset<T, CancellationFindFirstArgs<ExtArgs>>): Prisma__CancellationClient<$Result.GetResult<Prisma.$CancellationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cancellation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CancellationFindFirstOrThrowArgs} args - Arguments to find a Cancellation
     * @example
     * // Get one Cancellation
     * const cancellation = await prisma.cancellation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CancellationFindFirstOrThrowArgs>(args?: SelectSubset<T, CancellationFindFirstOrThrowArgs<ExtArgs>>): Prisma__CancellationClient<$Result.GetResult<Prisma.$CancellationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cancellations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CancellationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cancellations
     * const cancellations = await prisma.cancellation.findMany()
     * 
     * // Get first 10 Cancellations
     * const cancellations = await prisma.cancellation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cancellationWithIdOnly = await prisma.cancellation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CancellationFindManyArgs>(args?: SelectSubset<T, CancellationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CancellationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cancellation.
     * @param {CancellationCreateArgs} args - Arguments to create a Cancellation.
     * @example
     * // Create one Cancellation
     * const Cancellation = await prisma.cancellation.create({
     *   data: {
     *     // ... data to create a Cancellation
     *   }
     * })
     * 
     */
    create<T extends CancellationCreateArgs>(args: SelectSubset<T, CancellationCreateArgs<ExtArgs>>): Prisma__CancellationClient<$Result.GetResult<Prisma.$CancellationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cancellations.
     * @param {CancellationCreateManyArgs} args - Arguments to create many Cancellations.
     * @example
     * // Create many Cancellations
     * const cancellation = await prisma.cancellation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CancellationCreateManyArgs>(args?: SelectSubset<T, CancellationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cancellations and returns the data saved in the database.
     * @param {CancellationCreateManyAndReturnArgs} args - Arguments to create many Cancellations.
     * @example
     * // Create many Cancellations
     * const cancellation = await prisma.cancellation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cancellations and only return the `id`
     * const cancellationWithIdOnly = await prisma.cancellation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CancellationCreateManyAndReturnArgs>(args?: SelectSubset<T, CancellationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CancellationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cancellation.
     * @param {CancellationDeleteArgs} args - Arguments to delete one Cancellation.
     * @example
     * // Delete one Cancellation
     * const Cancellation = await prisma.cancellation.delete({
     *   where: {
     *     // ... filter to delete one Cancellation
     *   }
     * })
     * 
     */
    delete<T extends CancellationDeleteArgs>(args: SelectSubset<T, CancellationDeleteArgs<ExtArgs>>): Prisma__CancellationClient<$Result.GetResult<Prisma.$CancellationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cancellation.
     * @param {CancellationUpdateArgs} args - Arguments to update one Cancellation.
     * @example
     * // Update one Cancellation
     * const cancellation = await prisma.cancellation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CancellationUpdateArgs>(args: SelectSubset<T, CancellationUpdateArgs<ExtArgs>>): Prisma__CancellationClient<$Result.GetResult<Prisma.$CancellationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cancellations.
     * @param {CancellationDeleteManyArgs} args - Arguments to filter Cancellations to delete.
     * @example
     * // Delete a few Cancellations
     * const { count } = await prisma.cancellation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CancellationDeleteManyArgs>(args?: SelectSubset<T, CancellationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cancellations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CancellationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cancellations
     * const cancellation = await prisma.cancellation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CancellationUpdateManyArgs>(args: SelectSubset<T, CancellationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cancellations and returns the data updated in the database.
     * @param {CancellationUpdateManyAndReturnArgs} args - Arguments to update many Cancellations.
     * @example
     * // Update many Cancellations
     * const cancellation = await prisma.cancellation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cancellations and only return the `id`
     * const cancellationWithIdOnly = await prisma.cancellation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CancellationUpdateManyAndReturnArgs>(args: SelectSubset<T, CancellationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CancellationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cancellation.
     * @param {CancellationUpsertArgs} args - Arguments to update or create a Cancellation.
     * @example
     * // Update or create a Cancellation
     * const cancellation = await prisma.cancellation.upsert({
     *   create: {
     *     // ... data to create a Cancellation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cancellation we want to update
     *   }
     * })
     */
    upsert<T extends CancellationUpsertArgs>(args: SelectSubset<T, CancellationUpsertArgs<ExtArgs>>): Prisma__CancellationClient<$Result.GetResult<Prisma.$CancellationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cancellations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CancellationCountArgs} args - Arguments to filter Cancellations to count.
     * @example
     * // Count the number of Cancellations
     * const count = await prisma.cancellation.count({
     *   where: {
     *     // ... the filter for the Cancellations we want to count
     *   }
     * })
    **/
    count<T extends CancellationCountArgs>(
      args?: Subset<T, CancellationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CancellationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cancellation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CancellationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CancellationAggregateArgs>(args: Subset<T, CancellationAggregateArgs>): Prisma.PrismaPromise<GetCancellationAggregateType<T>>

    /**
     * Group by Cancellation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CancellationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CancellationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CancellationGroupByArgs['orderBy'] }
        : { orderBy?: CancellationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CancellationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCancellationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cancellation model
   */
  readonly fields: CancellationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cancellation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CancellationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    User<T extends Cancellation$UserArgs<ExtArgs> = {}>(args?: Subset<T, Cancellation$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cancellation model
   */
  interface CancellationFieldRefs {
    readonly id: FieldRef<"Cancellation", 'Int'>
    readonly bookingId: FieldRef<"Cancellation", 'Int'>
    readonly reason: FieldRef<"Cancellation", 'String'>
    readonly cancelledAt: FieldRef<"Cancellation", 'DateTime'>
    readonly processedByUserId: FieldRef<"Cancellation", 'Int'>
    readonly refundAmount: FieldRef<"Cancellation", 'Float'>
    readonly refundStatus: FieldRef<"Cancellation", 'String'>
    readonly notes: FieldRef<"Cancellation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Cancellation findUnique
   */
  export type CancellationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cancellation
     */
    select?: CancellationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cancellation
     */
    omit?: CancellationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationInclude<ExtArgs> | null
    /**
     * Filter, which Cancellation to fetch.
     */
    where: CancellationWhereUniqueInput
  }

  /**
   * Cancellation findUniqueOrThrow
   */
  export type CancellationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cancellation
     */
    select?: CancellationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cancellation
     */
    omit?: CancellationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationInclude<ExtArgs> | null
    /**
     * Filter, which Cancellation to fetch.
     */
    where: CancellationWhereUniqueInput
  }

  /**
   * Cancellation findFirst
   */
  export type CancellationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cancellation
     */
    select?: CancellationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cancellation
     */
    omit?: CancellationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationInclude<ExtArgs> | null
    /**
     * Filter, which Cancellation to fetch.
     */
    where?: CancellationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cancellations to fetch.
     */
    orderBy?: CancellationOrderByWithRelationInput | CancellationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cancellations.
     */
    cursor?: CancellationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cancellations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cancellations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cancellations.
     */
    distinct?: CancellationScalarFieldEnum | CancellationScalarFieldEnum[]
  }

  /**
   * Cancellation findFirstOrThrow
   */
  export type CancellationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cancellation
     */
    select?: CancellationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cancellation
     */
    omit?: CancellationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationInclude<ExtArgs> | null
    /**
     * Filter, which Cancellation to fetch.
     */
    where?: CancellationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cancellations to fetch.
     */
    orderBy?: CancellationOrderByWithRelationInput | CancellationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cancellations.
     */
    cursor?: CancellationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cancellations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cancellations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cancellations.
     */
    distinct?: CancellationScalarFieldEnum | CancellationScalarFieldEnum[]
  }

  /**
   * Cancellation findMany
   */
  export type CancellationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cancellation
     */
    select?: CancellationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cancellation
     */
    omit?: CancellationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationInclude<ExtArgs> | null
    /**
     * Filter, which Cancellations to fetch.
     */
    where?: CancellationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cancellations to fetch.
     */
    orderBy?: CancellationOrderByWithRelationInput | CancellationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cancellations.
     */
    cursor?: CancellationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cancellations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cancellations.
     */
    skip?: number
    distinct?: CancellationScalarFieldEnum | CancellationScalarFieldEnum[]
  }

  /**
   * Cancellation create
   */
  export type CancellationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cancellation
     */
    select?: CancellationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cancellation
     */
    omit?: CancellationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationInclude<ExtArgs> | null
    /**
     * The data needed to create a Cancellation.
     */
    data: XOR<CancellationCreateInput, CancellationUncheckedCreateInput>
  }

  /**
   * Cancellation createMany
   */
  export type CancellationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cancellations.
     */
    data: CancellationCreateManyInput | CancellationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cancellation createManyAndReturn
   */
  export type CancellationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cancellation
     */
    select?: CancellationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cancellation
     */
    omit?: CancellationOmit<ExtArgs> | null
    /**
     * The data used to create many Cancellations.
     */
    data: CancellationCreateManyInput | CancellationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cancellation update
   */
  export type CancellationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cancellation
     */
    select?: CancellationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cancellation
     */
    omit?: CancellationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationInclude<ExtArgs> | null
    /**
     * The data needed to update a Cancellation.
     */
    data: XOR<CancellationUpdateInput, CancellationUncheckedUpdateInput>
    /**
     * Choose, which Cancellation to update.
     */
    where: CancellationWhereUniqueInput
  }

  /**
   * Cancellation updateMany
   */
  export type CancellationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cancellations.
     */
    data: XOR<CancellationUpdateManyMutationInput, CancellationUncheckedUpdateManyInput>
    /**
     * Filter which Cancellations to update
     */
    where?: CancellationWhereInput
    /**
     * Limit how many Cancellations to update.
     */
    limit?: number
  }

  /**
   * Cancellation updateManyAndReturn
   */
  export type CancellationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cancellation
     */
    select?: CancellationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cancellation
     */
    omit?: CancellationOmit<ExtArgs> | null
    /**
     * The data used to update Cancellations.
     */
    data: XOR<CancellationUpdateManyMutationInput, CancellationUncheckedUpdateManyInput>
    /**
     * Filter which Cancellations to update
     */
    where?: CancellationWhereInput
    /**
     * Limit how many Cancellations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cancellation upsert
   */
  export type CancellationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cancellation
     */
    select?: CancellationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cancellation
     */
    omit?: CancellationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationInclude<ExtArgs> | null
    /**
     * The filter to search for the Cancellation to update in case it exists.
     */
    where: CancellationWhereUniqueInput
    /**
     * In case the Cancellation found by the `where` argument doesn't exist, create a new Cancellation with this data.
     */
    create: XOR<CancellationCreateInput, CancellationUncheckedCreateInput>
    /**
     * In case the Cancellation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CancellationUpdateInput, CancellationUncheckedUpdateInput>
  }

  /**
   * Cancellation delete
   */
  export type CancellationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cancellation
     */
    select?: CancellationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cancellation
     */
    omit?: CancellationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationInclude<ExtArgs> | null
    /**
     * Filter which Cancellation to delete.
     */
    where: CancellationWhereUniqueInput
  }

  /**
   * Cancellation deleteMany
   */
  export type CancellationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cancellations to delete
     */
    where?: CancellationWhereInput
    /**
     * Limit how many Cancellations to delete.
     */
    limit?: number
  }

  /**
   * Cancellation.User
   */
  export type Cancellation$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Cancellation without action
   */
  export type CancellationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cancellation
     */
    select?: CancellationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cancellation
     */
    omit?: CancellationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationInclude<ExtArgs> | null
  }


  /**
   * Model PromotionHotel
   */

  export type AggregatePromotionHotel = {
    _count: PromotionHotelCountAggregateOutputType | null
    _avg: PromotionHotelAvgAggregateOutputType | null
    _sum: PromotionHotelSumAggregateOutputType | null
    _min: PromotionHotelMinAggregateOutputType | null
    _max: PromotionHotelMaxAggregateOutputType | null
  }

  export type PromotionHotelAvgAggregateOutputType = {
    id: number | null
    promotionId: number | null
    hotelId: number | null
  }

  export type PromotionHotelSumAggregateOutputType = {
    id: number | null
    promotionId: number | null
    hotelId: number | null
  }

  export type PromotionHotelMinAggregateOutputType = {
    id: number | null
    promotionId: number | null
    hotelId: number | null
    createdAt: Date | null
  }

  export type PromotionHotelMaxAggregateOutputType = {
    id: number | null
    promotionId: number | null
    hotelId: number | null
    createdAt: Date | null
  }

  export type PromotionHotelCountAggregateOutputType = {
    id: number
    promotionId: number
    hotelId: number
    createdAt: number
    _all: number
  }


  export type PromotionHotelAvgAggregateInputType = {
    id?: true
    promotionId?: true
    hotelId?: true
  }

  export type PromotionHotelSumAggregateInputType = {
    id?: true
    promotionId?: true
    hotelId?: true
  }

  export type PromotionHotelMinAggregateInputType = {
    id?: true
    promotionId?: true
    hotelId?: true
    createdAt?: true
  }

  export type PromotionHotelMaxAggregateInputType = {
    id?: true
    promotionId?: true
    hotelId?: true
    createdAt?: true
  }

  export type PromotionHotelCountAggregateInputType = {
    id?: true
    promotionId?: true
    hotelId?: true
    createdAt?: true
    _all?: true
  }

  export type PromotionHotelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromotionHotel to aggregate.
     */
    where?: PromotionHotelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionHotels to fetch.
     */
    orderBy?: PromotionHotelOrderByWithRelationInput | PromotionHotelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromotionHotelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionHotels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionHotels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PromotionHotels
    **/
    _count?: true | PromotionHotelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PromotionHotelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PromotionHotelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromotionHotelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromotionHotelMaxAggregateInputType
  }

  export type GetPromotionHotelAggregateType<T extends PromotionHotelAggregateArgs> = {
        [P in keyof T & keyof AggregatePromotionHotel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromotionHotel[P]>
      : GetScalarType<T[P], AggregatePromotionHotel[P]>
  }




  export type PromotionHotelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionHotelWhereInput
    orderBy?: PromotionHotelOrderByWithAggregationInput | PromotionHotelOrderByWithAggregationInput[]
    by: PromotionHotelScalarFieldEnum[] | PromotionHotelScalarFieldEnum
    having?: PromotionHotelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromotionHotelCountAggregateInputType | true
    _avg?: PromotionHotelAvgAggregateInputType
    _sum?: PromotionHotelSumAggregateInputType
    _min?: PromotionHotelMinAggregateInputType
    _max?: PromotionHotelMaxAggregateInputType
  }

  export type PromotionHotelGroupByOutputType = {
    id: number
    promotionId: number
    hotelId: number
    createdAt: Date
    _count: PromotionHotelCountAggregateOutputType | null
    _avg: PromotionHotelAvgAggregateOutputType | null
    _sum: PromotionHotelSumAggregateOutputType | null
    _min: PromotionHotelMinAggregateOutputType | null
    _max: PromotionHotelMaxAggregateOutputType | null
  }

  type GetPromotionHotelGroupByPayload<T extends PromotionHotelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromotionHotelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromotionHotelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromotionHotelGroupByOutputType[P]>
            : GetScalarType<T[P], PromotionHotelGroupByOutputType[P]>
        }
      >
    >


  export type PromotionHotelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    promotionId?: boolean
    hotelId?: boolean
    createdAt?: boolean
    Promotion?: boolean | PromotionDefaultArgs<ExtArgs>
    Hotel?: boolean | HotelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promotionHotel"]>

  export type PromotionHotelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    promotionId?: boolean
    hotelId?: boolean
    createdAt?: boolean
    Promotion?: boolean | PromotionDefaultArgs<ExtArgs>
    Hotel?: boolean | HotelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promotionHotel"]>

  export type PromotionHotelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    promotionId?: boolean
    hotelId?: boolean
    createdAt?: boolean
    Promotion?: boolean | PromotionDefaultArgs<ExtArgs>
    Hotel?: boolean | HotelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promotionHotel"]>

  export type PromotionHotelSelectScalar = {
    id?: boolean
    promotionId?: boolean
    hotelId?: boolean
    createdAt?: boolean
  }

  export type PromotionHotelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "promotionId" | "hotelId" | "createdAt", ExtArgs["result"]["promotionHotel"]>
  export type PromotionHotelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Promotion?: boolean | PromotionDefaultArgs<ExtArgs>
    Hotel?: boolean | HotelDefaultArgs<ExtArgs>
  }
  export type PromotionHotelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Promotion?: boolean | PromotionDefaultArgs<ExtArgs>
    Hotel?: boolean | HotelDefaultArgs<ExtArgs>
  }
  export type PromotionHotelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Promotion?: boolean | PromotionDefaultArgs<ExtArgs>
    Hotel?: boolean | HotelDefaultArgs<ExtArgs>
  }

  export type $PromotionHotelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PromotionHotel"
    objects: {
      Promotion: Prisma.$PromotionPayload<ExtArgs>
      Hotel: Prisma.$HotelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      promotionId: number
      hotelId: number
      createdAt: Date
    }, ExtArgs["result"]["promotionHotel"]>
    composites: {}
  }

  type PromotionHotelGetPayload<S extends boolean | null | undefined | PromotionHotelDefaultArgs> = $Result.GetResult<Prisma.$PromotionHotelPayload, S>

  type PromotionHotelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PromotionHotelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PromotionHotelCountAggregateInputType | true
    }

  export interface PromotionHotelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PromotionHotel'], meta: { name: 'PromotionHotel' } }
    /**
     * Find zero or one PromotionHotel that matches the filter.
     * @param {PromotionHotelFindUniqueArgs} args - Arguments to find a PromotionHotel
     * @example
     * // Get one PromotionHotel
     * const promotionHotel = await prisma.promotionHotel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromotionHotelFindUniqueArgs>(args: SelectSubset<T, PromotionHotelFindUniqueArgs<ExtArgs>>): Prisma__PromotionHotelClient<$Result.GetResult<Prisma.$PromotionHotelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PromotionHotel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PromotionHotelFindUniqueOrThrowArgs} args - Arguments to find a PromotionHotel
     * @example
     * // Get one PromotionHotel
     * const promotionHotel = await prisma.promotionHotel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromotionHotelFindUniqueOrThrowArgs>(args: SelectSubset<T, PromotionHotelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromotionHotelClient<$Result.GetResult<Prisma.$PromotionHotelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PromotionHotel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionHotelFindFirstArgs} args - Arguments to find a PromotionHotel
     * @example
     * // Get one PromotionHotel
     * const promotionHotel = await prisma.promotionHotel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromotionHotelFindFirstArgs>(args?: SelectSubset<T, PromotionHotelFindFirstArgs<ExtArgs>>): Prisma__PromotionHotelClient<$Result.GetResult<Prisma.$PromotionHotelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PromotionHotel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionHotelFindFirstOrThrowArgs} args - Arguments to find a PromotionHotel
     * @example
     * // Get one PromotionHotel
     * const promotionHotel = await prisma.promotionHotel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromotionHotelFindFirstOrThrowArgs>(args?: SelectSubset<T, PromotionHotelFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromotionHotelClient<$Result.GetResult<Prisma.$PromotionHotelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PromotionHotels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionHotelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PromotionHotels
     * const promotionHotels = await prisma.promotionHotel.findMany()
     * 
     * // Get first 10 PromotionHotels
     * const promotionHotels = await prisma.promotionHotel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promotionHotelWithIdOnly = await prisma.promotionHotel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromotionHotelFindManyArgs>(args?: SelectSubset<T, PromotionHotelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionHotelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PromotionHotel.
     * @param {PromotionHotelCreateArgs} args - Arguments to create a PromotionHotel.
     * @example
     * // Create one PromotionHotel
     * const PromotionHotel = await prisma.promotionHotel.create({
     *   data: {
     *     // ... data to create a PromotionHotel
     *   }
     * })
     * 
     */
    create<T extends PromotionHotelCreateArgs>(args: SelectSubset<T, PromotionHotelCreateArgs<ExtArgs>>): Prisma__PromotionHotelClient<$Result.GetResult<Prisma.$PromotionHotelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PromotionHotels.
     * @param {PromotionHotelCreateManyArgs} args - Arguments to create many PromotionHotels.
     * @example
     * // Create many PromotionHotels
     * const promotionHotel = await prisma.promotionHotel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromotionHotelCreateManyArgs>(args?: SelectSubset<T, PromotionHotelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PromotionHotels and returns the data saved in the database.
     * @param {PromotionHotelCreateManyAndReturnArgs} args - Arguments to create many PromotionHotels.
     * @example
     * // Create many PromotionHotels
     * const promotionHotel = await prisma.promotionHotel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PromotionHotels and only return the `id`
     * const promotionHotelWithIdOnly = await prisma.promotionHotel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PromotionHotelCreateManyAndReturnArgs>(args?: SelectSubset<T, PromotionHotelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionHotelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PromotionHotel.
     * @param {PromotionHotelDeleteArgs} args - Arguments to delete one PromotionHotel.
     * @example
     * // Delete one PromotionHotel
     * const PromotionHotel = await prisma.promotionHotel.delete({
     *   where: {
     *     // ... filter to delete one PromotionHotel
     *   }
     * })
     * 
     */
    delete<T extends PromotionHotelDeleteArgs>(args: SelectSubset<T, PromotionHotelDeleteArgs<ExtArgs>>): Prisma__PromotionHotelClient<$Result.GetResult<Prisma.$PromotionHotelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PromotionHotel.
     * @param {PromotionHotelUpdateArgs} args - Arguments to update one PromotionHotel.
     * @example
     * // Update one PromotionHotel
     * const promotionHotel = await prisma.promotionHotel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromotionHotelUpdateArgs>(args: SelectSubset<T, PromotionHotelUpdateArgs<ExtArgs>>): Prisma__PromotionHotelClient<$Result.GetResult<Prisma.$PromotionHotelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PromotionHotels.
     * @param {PromotionHotelDeleteManyArgs} args - Arguments to filter PromotionHotels to delete.
     * @example
     * // Delete a few PromotionHotels
     * const { count } = await prisma.promotionHotel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromotionHotelDeleteManyArgs>(args?: SelectSubset<T, PromotionHotelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromotionHotels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionHotelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PromotionHotels
     * const promotionHotel = await prisma.promotionHotel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromotionHotelUpdateManyArgs>(args: SelectSubset<T, PromotionHotelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromotionHotels and returns the data updated in the database.
     * @param {PromotionHotelUpdateManyAndReturnArgs} args - Arguments to update many PromotionHotels.
     * @example
     * // Update many PromotionHotels
     * const promotionHotel = await prisma.promotionHotel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PromotionHotels and only return the `id`
     * const promotionHotelWithIdOnly = await prisma.promotionHotel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PromotionHotelUpdateManyAndReturnArgs>(args: SelectSubset<T, PromotionHotelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionHotelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PromotionHotel.
     * @param {PromotionHotelUpsertArgs} args - Arguments to update or create a PromotionHotel.
     * @example
     * // Update or create a PromotionHotel
     * const promotionHotel = await prisma.promotionHotel.upsert({
     *   create: {
     *     // ... data to create a PromotionHotel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PromotionHotel we want to update
     *   }
     * })
     */
    upsert<T extends PromotionHotelUpsertArgs>(args: SelectSubset<T, PromotionHotelUpsertArgs<ExtArgs>>): Prisma__PromotionHotelClient<$Result.GetResult<Prisma.$PromotionHotelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PromotionHotels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionHotelCountArgs} args - Arguments to filter PromotionHotels to count.
     * @example
     * // Count the number of PromotionHotels
     * const count = await prisma.promotionHotel.count({
     *   where: {
     *     // ... the filter for the PromotionHotels we want to count
     *   }
     * })
    **/
    count<T extends PromotionHotelCountArgs>(
      args?: Subset<T, PromotionHotelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromotionHotelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PromotionHotel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionHotelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromotionHotelAggregateArgs>(args: Subset<T, PromotionHotelAggregateArgs>): Prisma.PrismaPromise<GetPromotionHotelAggregateType<T>>

    /**
     * Group by PromotionHotel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionHotelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromotionHotelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromotionHotelGroupByArgs['orderBy'] }
        : { orderBy?: PromotionHotelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromotionHotelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromotionHotelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PromotionHotel model
   */
  readonly fields: PromotionHotelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PromotionHotel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromotionHotelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Promotion<T extends PromotionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PromotionDefaultArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Hotel<T extends HotelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HotelDefaultArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PromotionHotel model
   */
  interface PromotionHotelFieldRefs {
    readonly id: FieldRef<"PromotionHotel", 'Int'>
    readonly promotionId: FieldRef<"PromotionHotel", 'Int'>
    readonly hotelId: FieldRef<"PromotionHotel", 'Int'>
    readonly createdAt: FieldRef<"PromotionHotel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PromotionHotel findUnique
   */
  export type PromotionHotelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionHotel
     */
    select?: PromotionHotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionHotel
     */
    omit?: PromotionHotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionHotelInclude<ExtArgs> | null
    /**
     * Filter, which PromotionHotel to fetch.
     */
    where: PromotionHotelWhereUniqueInput
  }

  /**
   * PromotionHotel findUniqueOrThrow
   */
  export type PromotionHotelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionHotel
     */
    select?: PromotionHotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionHotel
     */
    omit?: PromotionHotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionHotelInclude<ExtArgs> | null
    /**
     * Filter, which PromotionHotel to fetch.
     */
    where: PromotionHotelWhereUniqueInput
  }

  /**
   * PromotionHotel findFirst
   */
  export type PromotionHotelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionHotel
     */
    select?: PromotionHotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionHotel
     */
    omit?: PromotionHotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionHotelInclude<ExtArgs> | null
    /**
     * Filter, which PromotionHotel to fetch.
     */
    where?: PromotionHotelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionHotels to fetch.
     */
    orderBy?: PromotionHotelOrderByWithRelationInput | PromotionHotelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromotionHotels.
     */
    cursor?: PromotionHotelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionHotels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionHotels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromotionHotels.
     */
    distinct?: PromotionHotelScalarFieldEnum | PromotionHotelScalarFieldEnum[]
  }

  /**
   * PromotionHotel findFirstOrThrow
   */
  export type PromotionHotelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionHotel
     */
    select?: PromotionHotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionHotel
     */
    omit?: PromotionHotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionHotelInclude<ExtArgs> | null
    /**
     * Filter, which PromotionHotel to fetch.
     */
    where?: PromotionHotelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionHotels to fetch.
     */
    orderBy?: PromotionHotelOrderByWithRelationInput | PromotionHotelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromotionHotels.
     */
    cursor?: PromotionHotelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionHotels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionHotels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromotionHotels.
     */
    distinct?: PromotionHotelScalarFieldEnum | PromotionHotelScalarFieldEnum[]
  }

  /**
   * PromotionHotel findMany
   */
  export type PromotionHotelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionHotel
     */
    select?: PromotionHotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionHotel
     */
    omit?: PromotionHotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionHotelInclude<ExtArgs> | null
    /**
     * Filter, which PromotionHotels to fetch.
     */
    where?: PromotionHotelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionHotels to fetch.
     */
    orderBy?: PromotionHotelOrderByWithRelationInput | PromotionHotelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PromotionHotels.
     */
    cursor?: PromotionHotelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionHotels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionHotels.
     */
    skip?: number
    distinct?: PromotionHotelScalarFieldEnum | PromotionHotelScalarFieldEnum[]
  }

  /**
   * PromotionHotel create
   */
  export type PromotionHotelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionHotel
     */
    select?: PromotionHotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionHotel
     */
    omit?: PromotionHotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionHotelInclude<ExtArgs> | null
    /**
     * The data needed to create a PromotionHotel.
     */
    data: XOR<PromotionHotelCreateInput, PromotionHotelUncheckedCreateInput>
  }

  /**
   * PromotionHotel createMany
   */
  export type PromotionHotelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PromotionHotels.
     */
    data: PromotionHotelCreateManyInput | PromotionHotelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PromotionHotel createManyAndReturn
   */
  export type PromotionHotelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionHotel
     */
    select?: PromotionHotelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionHotel
     */
    omit?: PromotionHotelOmit<ExtArgs> | null
    /**
     * The data used to create many PromotionHotels.
     */
    data: PromotionHotelCreateManyInput | PromotionHotelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionHotelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PromotionHotel update
   */
  export type PromotionHotelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionHotel
     */
    select?: PromotionHotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionHotel
     */
    omit?: PromotionHotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionHotelInclude<ExtArgs> | null
    /**
     * The data needed to update a PromotionHotel.
     */
    data: XOR<PromotionHotelUpdateInput, PromotionHotelUncheckedUpdateInput>
    /**
     * Choose, which PromotionHotel to update.
     */
    where: PromotionHotelWhereUniqueInput
  }

  /**
   * PromotionHotel updateMany
   */
  export type PromotionHotelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PromotionHotels.
     */
    data: XOR<PromotionHotelUpdateManyMutationInput, PromotionHotelUncheckedUpdateManyInput>
    /**
     * Filter which PromotionHotels to update
     */
    where?: PromotionHotelWhereInput
    /**
     * Limit how many PromotionHotels to update.
     */
    limit?: number
  }

  /**
   * PromotionHotel updateManyAndReturn
   */
  export type PromotionHotelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionHotel
     */
    select?: PromotionHotelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionHotel
     */
    omit?: PromotionHotelOmit<ExtArgs> | null
    /**
     * The data used to update PromotionHotels.
     */
    data: XOR<PromotionHotelUpdateManyMutationInput, PromotionHotelUncheckedUpdateManyInput>
    /**
     * Filter which PromotionHotels to update
     */
    where?: PromotionHotelWhereInput
    /**
     * Limit how many PromotionHotels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionHotelIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PromotionHotel upsert
   */
  export type PromotionHotelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionHotel
     */
    select?: PromotionHotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionHotel
     */
    omit?: PromotionHotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionHotelInclude<ExtArgs> | null
    /**
     * The filter to search for the PromotionHotel to update in case it exists.
     */
    where: PromotionHotelWhereUniqueInput
    /**
     * In case the PromotionHotel found by the `where` argument doesn't exist, create a new PromotionHotel with this data.
     */
    create: XOR<PromotionHotelCreateInput, PromotionHotelUncheckedCreateInput>
    /**
     * In case the PromotionHotel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromotionHotelUpdateInput, PromotionHotelUncheckedUpdateInput>
  }

  /**
   * PromotionHotel delete
   */
  export type PromotionHotelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionHotel
     */
    select?: PromotionHotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionHotel
     */
    omit?: PromotionHotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionHotelInclude<ExtArgs> | null
    /**
     * Filter which PromotionHotel to delete.
     */
    where: PromotionHotelWhereUniqueInput
  }

  /**
   * PromotionHotel deleteMany
   */
  export type PromotionHotelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromotionHotels to delete
     */
    where?: PromotionHotelWhereInput
    /**
     * Limit how many PromotionHotels to delete.
     */
    limit?: number
  }

  /**
   * PromotionHotel without action
   */
  export type PromotionHotelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionHotel
     */
    select?: PromotionHotelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionHotel
     */
    omit?: PromotionHotelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionHotelInclude<ExtArgs> | null
  }


  /**
   * Model PromotionRoomType
   */

  export type AggregatePromotionRoomType = {
    _count: PromotionRoomTypeCountAggregateOutputType | null
    _avg: PromotionRoomTypeAvgAggregateOutputType | null
    _sum: PromotionRoomTypeSumAggregateOutputType | null
    _min: PromotionRoomTypeMinAggregateOutputType | null
    _max: PromotionRoomTypeMaxAggregateOutputType | null
  }

  export type PromotionRoomTypeAvgAggregateOutputType = {
    id: number | null
    promotionId: number | null
    roomTypeId: number | null
  }

  export type PromotionRoomTypeSumAggregateOutputType = {
    id: number | null
    promotionId: number | null
    roomTypeId: number | null
  }

  export type PromotionRoomTypeMinAggregateOutputType = {
    id: number | null
    promotionId: number | null
    roomTypeId: number | null
    createdAt: Date | null
  }

  export type PromotionRoomTypeMaxAggregateOutputType = {
    id: number | null
    promotionId: number | null
    roomTypeId: number | null
    createdAt: Date | null
  }

  export type PromotionRoomTypeCountAggregateOutputType = {
    id: number
    promotionId: number
    roomTypeId: number
    createdAt: number
    _all: number
  }


  export type PromotionRoomTypeAvgAggregateInputType = {
    id?: true
    promotionId?: true
    roomTypeId?: true
  }

  export type PromotionRoomTypeSumAggregateInputType = {
    id?: true
    promotionId?: true
    roomTypeId?: true
  }

  export type PromotionRoomTypeMinAggregateInputType = {
    id?: true
    promotionId?: true
    roomTypeId?: true
    createdAt?: true
  }

  export type PromotionRoomTypeMaxAggregateInputType = {
    id?: true
    promotionId?: true
    roomTypeId?: true
    createdAt?: true
  }

  export type PromotionRoomTypeCountAggregateInputType = {
    id?: true
    promotionId?: true
    roomTypeId?: true
    createdAt?: true
    _all?: true
  }

  export type PromotionRoomTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromotionRoomType to aggregate.
     */
    where?: PromotionRoomTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionRoomTypes to fetch.
     */
    orderBy?: PromotionRoomTypeOrderByWithRelationInput | PromotionRoomTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromotionRoomTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionRoomTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionRoomTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PromotionRoomTypes
    **/
    _count?: true | PromotionRoomTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PromotionRoomTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PromotionRoomTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromotionRoomTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromotionRoomTypeMaxAggregateInputType
  }

  export type GetPromotionRoomTypeAggregateType<T extends PromotionRoomTypeAggregateArgs> = {
        [P in keyof T & keyof AggregatePromotionRoomType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromotionRoomType[P]>
      : GetScalarType<T[P], AggregatePromotionRoomType[P]>
  }




  export type PromotionRoomTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromotionRoomTypeWhereInput
    orderBy?: PromotionRoomTypeOrderByWithAggregationInput | PromotionRoomTypeOrderByWithAggregationInput[]
    by: PromotionRoomTypeScalarFieldEnum[] | PromotionRoomTypeScalarFieldEnum
    having?: PromotionRoomTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromotionRoomTypeCountAggregateInputType | true
    _avg?: PromotionRoomTypeAvgAggregateInputType
    _sum?: PromotionRoomTypeSumAggregateInputType
    _min?: PromotionRoomTypeMinAggregateInputType
    _max?: PromotionRoomTypeMaxAggregateInputType
  }

  export type PromotionRoomTypeGroupByOutputType = {
    id: number
    promotionId: number
    roomTypeId: number
    createdAt: Date
    _count: PromotionRoomTypeCountAggregateOutputType | null
    _avg: PromotionRoomTypeAvgAggregateOutputType | null
    _sum: PromotionRoomTypeSumAggregateOutputType | null
    _min: PromotionRoomTypeMinAggregateOutputType | null
    _max: PromotionRoomTypeMaxAggregateOutputType | null
  }

  type GetPromotionRoomTypeGroupByPayload<T extends PromotionRoomTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromotionRoomTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromotionRoomTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromotionRoomTypeGroupByOutputType[P]>
            : GetScalarType<T[P], PromotionRoomTypeGroupByOutputType[P]>
        }
      >
    >


  export type PromotionRoomTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    promotionId?: boolean
    roomTypeId?: boolean
    createdAt?: boolean
    Promotion?: boolean | PromotionDefaultArgs<ExtArgs>
    RoomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promotionRoomType"]>

  export type PromotionRoomTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    promotionId?: boolean
    roomTypeId?: boolean
    createdAt?: boolean
    Promotion?: boolean | PromotionDefaultArgs<ExtArgs>
    RoomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promotionRoomType"]>

  export type PromotionRoomTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    promotionId?: boolean
    roomTypeId?: boolean
    createdAt?: boolean
    Promotion?: boolean | PromotionDefaultArgs<ExtArgs>
    RoomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promotionRoomType"]>

  export type PromotionRoomTypeSelectScalar = {
    id?: boolean
    promotionId?: boolean
    roomTypeId?: boolean
    createdAt?: boolean
  }

  export type PromotionRoomTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "promotionId" | "roomTypeId" | "createdAt", ExtArgs["result"]["promotionRoomType"]>
  export type PromotionRoomTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Promotion?: boolean | PromotionDefaultArgs<ExtArgs>
    RoomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
  }
  export type PromotionRoomTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Promotion?: boolean | PromotionDefaultArgs<ExtArgs>
    RoomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
  }
  export type PromotionRoomTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Promotion?: boolean | PromotionDefaultArgs<ExtArgs>
    RoomType?: boolean | RoomTypeDefaultArgs<ExtArgs>
  }

  export type $PromotionRoomTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PromotionRoomType"
    objects: {
      Promotion: Prisma.$PromotionPayload<ExtArgs>
      RoomType: Prisma.$RoomTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      promotionId: number
      roomTypeId: number
      createdAt: Date
    }, ExtArgs["result"]["promotionRoomType"]>
    composites: {}
  }

  type PromotionRoomTypeGetPayload<S extends boolean | null | undefined | PromotionRoomTypeDefaultArgs> = $Result.GetResult<Prisma.$PromotionRoomTypePayload, S>

  type PromotionRoomTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PromotionRoomTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PromotionRoomTypeCountAggregateInputType | true
    }

  export interface PromotionRoomTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PromotionRoomType'], meta: { name: 'PromotionRoomType' } }
    /**
     * Find zero or one PromotionRoomType that matches the filter.
     * @param {PromotionRoomTypeFindUniqueArgs} args - Arguments to find a PromotionRoomType
     * @example
     * // Get one PromotionRoomType
     * const promotionRoomType = await prisma.promotionRoomType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromotionRoomTypeFindUniqueArgs>(args: SelectSubset<T, PromotionRoomTypeFindUniqueArgs<ExtArgs>>): Prisma__PromotionRoomTypeClient<$Result.GetResult<Prisma.$PromotionRoomTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PromotionRoomType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PromotionRoomTypeFindUniqueOrThrowArgs} args - Arguments to find a PromotionRoomType
     * @example
     * // Get one PromotionRoomType
     * const promotionRoomType = await prisma.promotionRoomType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromotionRoomTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, PromotionRoomTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromotionRoomTypeClient<$Result.GetResult<Prisma.$PromotionRoomTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PromotionRoomType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionRoomTypeFindFirstArgs} args - Arguments to find a PromotionRoomType
     * @example
     * // Get one PromotionRoomType
     * const promotionRoomType = await prisma.promotionRoomType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromotionRoomTypeFindFirstArgs>(args?: SelectSubset<T, PromotionRoomTypeFindFirstArgs<ExtArgs>>): Prisma__PromotionRoomTypeClient<$Result.GetResult<Prisma.$PromotionRoomTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PromotionRoomType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionRoomTypeFindFirstOrThrowArgs} args - Arguments to find a PromotionRoomType
     * @example
     * // Get one PromotionRoomType
     * const promotionRoomType = await prisma.promotionRoomType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromotionRoomTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, PromotionRoomTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromotionRoomTypeClient<$Result.GetResult<Prisma.$PromotionRoomTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PromotionRoomTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionRoomTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PromotionRoomTypes
     * const promotionRoomTypes = await prisma.promotionRoomType.findMany()
     * 
     * // Get first 10 PromotionRoomTypes
     * const promotionRoomTypes = await prisma.promotionRoomType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promotionRoomTypeWithIdOnly = await prisma.promotionRoomType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromotionRoomTypeFindManyArgs>(args?: SelectSubset<T, PromotionRoomTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionRoomTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PromotionRoomType.
     * @param {PromotionRoomTypeCreateArgs} args - Arguments to create a PromotionRoomType.
     * @example
     * // Create one PromotionRoomType
     * const PromotionRoomType = await prisma.promotionRoomType.create({
     *   data: {
     *     // ... data to create a PromotionRoomType
     *   }
     * })
     * 
     */
    create<T extends PromotionRoomTypeCreateArgs>(args: SelectSubset<T, PromotionRoomTypeCreateArgs<ExtArgs>>): Prisma__PromotionRoomTypeClient<$Result.GetResult<Prisma.$PromotionRoomTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PromotionRoomTypes.
     * @param {PromotionRoomTypeCreateManyArgs} args - Arguments to create many PromotionRoomTypes.
     * @example
     * // Create many PromotionRoomTypes
     * const promotionRoomType = await prisma.promotionRoomType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromotionRoomTypeCreateManyArgs>(args?: SelectSubset<T, PromotionRoomTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PromotionRoomTypes and returns the data saved in the database.
     * @param {PromotionRoomTypeCreateManyAndReturnArgs} args - Arguments to create many PromotionRoomTypes.
     * @example
     * // Create many PromotionRoomTypes
     * const promotionRoomType = await prisma.promotionRoomType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PromotionRoomTypes and only return the `id`
     * const promotionRoomTypeWithIdOnly = await prisma.promotionRoomType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PromotionRoomTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, PromotionRoomTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionRoomTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PromotionRoomType.
     * @param {PromotionRoomTypeDeleteArgs} args - Arguments to delete one PromotionRoomType.
     * @example
     * // Delete one PromotionRoomType
     * const PromotionRoomType = await prisma.promotionRoomType.delete({
     *   where: {
     *     // ... filter to delete one PromotionRoomType
     *   }
     * })
     * 
     */
    delete<T extends PromotionRoomTypeDeleteArgs>(args: SelectSubset<T, PromotionRoomTypeDeleteArgs<ExtArgs>>): Prisma__PromotionRoomTypeClient<$Result.GetResult<Prisma.$PromotionRoomTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PromotionRoomType.
     * @param {PromotionRoomTypeUpdateArgs} args - Arguments to update one PromotionRoomType.
     * @example
     * // Update one PromotionRoomType
     * const promotionRoomType = await prisma.promotionRoomType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromotionRoomTypeUpdateArgs>(args: SelectSubset<T, PromotionRoomTypeUpdateArgs<ExtArgs>>): Prisma__PromotionRoomTypeClient<$Result.GetResult<Prisma.$PromotionRoomTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PromotionRoomTypes.
     * @param {PromotionRoomTypeDeleteManyArgs} args - Arguments to filter PromotionRoomTypes to delete.
     * @example
     * // Delete a few PromotionRoomTypes
     * const { count } = await prisma.promotionRoomType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromotionRoomTypeDeleteManyArgs>(args?: SelectSubset<T, PromotionRoomTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromotionRoomTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionRoomTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PromotionRoomTypes
     * const promotionRoomType = await prisma.promotionRoomType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromotionRoomTypeUpdateManyArgs>(args: SelectSubset<T, PromotionRoomTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromotionRoomTypes and returns the data updated in the database.
     * @param {PromotionRoomTypeUpdateManyAndReturnArgs} args - Arguments to update many PromotionRoomTypes.
     * @example
     * // Update many PromotionRoomTypes
     * const promotionRoomType = await prisma.promotionRoomType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PromotionRoomTypes and only return the `id`
     * const promotionRoomTypeWithIdOnly = await prisma.promotionRoomType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PromotionRoomTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, PromotionRoomTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromotionRoomTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PromotionRoomType.
     * @param {PromotionRoomTypeUpsertArgs} args - Arguments to update or create a PromotionRoomType.
     * @example
     * // Update or create a PromotionRoomType
     * const promotionRoomType = await prisma.promotionRoomType.upsert({
     *   create: {
     *     // ... data to create a PromotionRoomType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PromotionRoomType we want to update
     *   }
     * })
     */
    upsert<T extends PromotionRoomTypeUpsertArgs>(args: SelectSubset<T, PromotionRoomTypeUpsertArgs<ExtArgs>>): Prisma__PromotionRoomTypeClient<$Result.GetResult<Prisma.$PromotionRoomTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PromotionRoomTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionRoomTypeCountArgs} args - Arguments to filter PromotionRoomTypes to count.
     * @example
     * // Count the number of PromotionRoomTypes
     * const count = await prisma.promotionRoomType.count({
     *   where: {
     *     // ... the filter for the PromotionRoomTypes we want to count
     *   }
     * })
    **/
    count<T extends PromotionRoomTypeCountArgs>(
      args?: Subset<T, PromotionRoomTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromotionRoomTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PromotionRoomType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionRoomTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromotionRoomTypeAggregateArgs>(args: Subset<T, PromotionRoomTypeAggregateArgs>): Prisma.PrismaPromise<GetPromotionRoomTypeAggregateType<T>>

    /**
     * Group by PromotionRoomType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromotionRoomTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromotionRoomTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromotionRoomTypeGroupByArgs['orderBy'] }
        : { orderBy?: PromotionRoomTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromotionRoomTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromotionRoomTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PromotionRoomType model
   */
  readonly fields: PromotionRoomTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PromotionRoomType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromotionRoomTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Promotion<T extends PromotionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PromotionDefaultArgs<ExtArgs>>): Prisma__PromotionClient<$Result.GetResult<Prisma.$PromotionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    RoomType<T extends RoomTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomTypeDefaultArgs<ExtArgs>>): Prisma__RoomTypeClient<$Result.GetResult<Prisma.$RoomTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PromotionRoomType model
   */
  interface PromotionRoomTypeFieldRefs {
    readonly id: FieldRef<"PromotionRoomType", 'Int'>
    readonly promotionId: FieldRef<"PromotionRoomType", 'Int'>
    readonly roomTypeId: FieldRef<"PromotionRoomType", 'Int'>
    readonly createdAt: FieldRef<"PromotionRoomType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PromotionRoomType findUnique
   */
  export type PromotionRoomTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRoomType
     */
    select?: PromotionRoomTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRoomType
     */
    omit?: PromotionRoomTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRoomTypeInclude<ExtArgs> | null
    /**
     * Filter, which PromotionRoomType to fetch.
     */
    where: PromotionRoomTypeWhereUniqueInput
  }

  /**
   * PromotionRoomType findUniqueOrThrow
   */
  export type PromotionRoomTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRoomType
     */
    select?: PromotionRoomTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRoomType
     */
    omit?: PromotionRoomTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRoomTypeInclude<ExtArgs> | null
    /**
     * Filter, which PromotionRoomType to fetch.
     */
    where: PromotionRoomTypeWhereUniqueInput
  }

  /**
   * PromotionRoomType findFirst
   */
  export type PromotionRoomTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRoomType
     */
    select?: PromotionRoomTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRoomType
     */
    omit?: PromotionRoomTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRoomTypeInclude<ExtArgs> | null
    /**
     * Filter, which PromotionRoomType to fetch.
     */
    where?: PromotionRoomTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionRoomTypes to fetch.
     */
    orderBy?: PromotionRoomTypeOrderByWithRelationInput | PromotionRoomTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromotionRoomTypes.
     */
    cursor?: PromotionRoomTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionRoomTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionRoomTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromotionRoomTypes.
     */
    distinct?: PromotionRoomTypeScalarFieldEnum | PromotionRoomTypeScalarFieldEnum[]
  }

  /**
   * PromotionRoomType findFirstOrThrow
   */
  export type PromotionRoomTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRoomType
     */
    select?: PromotionRoomTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRoomType
     */
    omit?: PromotionRoomTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRoomTypeInclude<ExtArgs> | null
    /**
     * Filter, which PromotionRoomType to fetch.
     */
    where?: PromotionRoomTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionRoomTypes to fetch.
     */
    orderBy?: PromotionRoomTypeOrderByWithRelationInput | PromotionRoomTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromotionRoomTypes.
     */
    cursor?: PromotionRoomTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionRoomTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionRoomTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromotionRoomTypes.
     */
    distinct?: PromotionRoomTypeScalarFieldEnum | PromotionRoomTypeScalarFieldEnum[]
  }

  /**
   * PromotionRoomType findMany
   */
  export type PromotionRoomTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRoomType
     */
    select?: PromotionRoomTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRoomType
     */
    omit?: PromotionRoomTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRoomTypeInclude<ExtArgs> | null
    /**
     * Filter, which PromotionRoomTypes to fetch.
     */
    where?: PromotionRoomTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromotionRoomTypes to fetch.
     */
    orderBy?: PromotionRoomTypeOrderByWithRelationInput | PromotionRoomTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PromotionRoomTypes.
     */
    cursor?: PromotionRoomTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromotionRoomTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromotionRoomTypes.
     */
    skip?: number
    distinct?: PromotionRoomTypeScalarFieldEnum | PromotionRoomTypeScalarFieldEnum[]
  }

  /**
   * PromotionRoomType create
   */
  export type PromotionRoomTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRoomType
     */
    select?: PromotionRoomTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRoomType
     */
    omit?: PromotionRoomTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRoomTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a PromotionRoomType.
     */
    data: XOR<PromotionRoomTypeCreateInput, PromotionRoomTypeUncheckedCreateInput>
  }

  /**
   * PromotionRoomType createMany
   */
  export type PromotionRoomTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PromotionRoomTypes.
     */
    data: PromotionRoomTypeCreateManyInput | PromotionRoomTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PromotionRoomType createManyAndReturn
   */
  export type PromotionRoomTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRoomType
     */
    select?: PromotionRoomTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRoomType
     */
    omit?: PromotionRoomTypeOmit<ExtArgs> | null
    /**
     * The data used to create many PromotionRoomTypes.
     */
    data: PromotionRoomTypeCreateManyInput | PromotionRoomTypeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRoomTypeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PromotionRoomType update
   */
  export type PromotionRoomTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRoomType
     */
    select?: PromotionRoomTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRoomType
     */
    omit?: PromotionRoomTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRoomTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a PromotionRoomType.
     */
    data: XOR<PromotionRoomTypeUpdateInput, PromotionRoomTypeUncheckedUpdateInput>
    /**
     * Choose, which PromotionRoomType to update.
     */
    where: PromotionRoomTypeWhereUniqueInput
  }

  /**
   * PromotionRoomType updateMany
   */
  export type PromotionRoomTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PromotionRoomTypes.
     */
    data: XOR<PromotionRoomTypeUpdateManyMutationInput, PromotionRoomTypeUncheckedUpdateManyInput>
    /**
     * Filter which PromotionRoomTypes to update
     */
    where?: PromotionRoomTypeWhereInput
    /**
     * Limit how many PromotionRoomTypes to update.
     */
    limit?: number
  }

  /**
   * PromotionRoomType updateManyAndReturn
   */
  export type PromotionRoomTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRoomType
     */
    select?: PromotionRoomTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRoomType
     */
    omit?: PromotionRoomTypeOmit<ExtArgs> | null
    /**
     * The data used to update PromotionRoomTypes.
     */
    data: XOR<PromotionRoomTypeUpdateManyMutationInput, PromotionRoomTypeUncheckedUpdateManyInput>
    /**
     * Filter which PromotionRoomTypes to update
     */
    where?: PromotionRoomTypeWhereInput
    /**
     * Limit how many PromotionRoomTypes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRoomTypeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PromotionRoomType upsert
   */
  export type PromotionRoomTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRoomType
     */
    select?: PromotionRoomTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRoomType
     */
    omit?: PromotionRoomTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRoomTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the PromotionRoomType to update in case it exists.
     */
    where: PromotionRoomTypeWhereUniqueInput
    /**
     * In case the PromotionRoomType found by the `where` argument doesn't exist, create a new PromotionRoomType with this data.
     */
    create: XOR<PromotionRoomTypeCreateInput, PromotionRoomTypeUncheckedCreateInput>
    /**
     * In case the PromotionRoomType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromotionRoomTypeUpdateInput, PromotionRoomTypeUncheckedUpdateInput>
  }

  /**
   * PromotionRoomType delete
   */
  export type PromotionRoomTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRoomType
     */
    select?: PromotionRoomTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRoomType
     */
    omit?: PromotionRoomTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRoomTypeInclude<ExtArgs> | null
    /**
     * Filter which PromotionRoomType to delete.
     */
    where: PromotionRoomTypeWhereUniqueInput
  }

  /**
   * PromotionRoomType deleteMany
   */
  export type PromotionRoomTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromotionRoomTypes to delete
     */
    where?: PromotionRoomTypeWhereInput
    /**
     * Limit how many PromotionRoomTypes to delete.
     */
    limit?: number
  }

  /**
   * PromotionRoomType without action
   */
  export type PromotionRoomTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromotionRoomType
     */
    select?: PromotionRoomTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PromotionRoomType
     */
    omit?: PromotionRoomTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromotionRoomTypeInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const HotelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    addressId: 'addressId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HotelScalarFieldEnum = (typeof HotelScalarFieldEnum)[keyof typeof HotelScalarFieldEnum]


  export const AddressScalarFieldEnum: {
    id: 'id',
    streetAddress: 'streetAddress',
    city: 'city',
    stateProvince: 'stateProvince',
    postalCode: 'postalCode',
    countryCode: 'countryCode',
    latitude: 'latitude',
    longitude: 'longitude',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const ImageScalarFieldEnum: {
    id: 'id',
    url: 'url',
    altText: 'altText',
    order: 'order',
    hotelId: 'hotelId',
    roomTypeId: 'roomTypeId',
    createdAt: 'createdAt'
  };

  export type ImageScalarFieldEnum = (typeof ImageScalarFieldEnum)[keyof typeof ImageScalarFieldEnum]


  export const AmenityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    category: 'category',
    createdAt: 'createdAt'
  };

  export type AmenityScalarFieldEnum = (typeof AmenityScalarFieldEnum)[keyof typeof AmenityScalarFieldEnum]


  export const HotelAmenityScalarFieldEnum: {
    hotelId: 'hotelId',
    amenityId: 'amenityId',
    details: 'details',
    createdAt: 'createdAt'
  };

  export type HotelAmenityScalarFieldEnum = (typeof HotelAmenityScalarFieldEnum)[keyof typeof HotelAmenityScalarFieldEnum]


  export const RoomTypeScalarFieldEnum: {
    id: 'id',
    hotelId: 'hotelId',
    name: 'name',
    description: 'description',
    maxGuests: 'maxGuests',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoomTypeScalarFieldEnum = (typeof RoomTypeScalarFieldEnum)[keyof typeof RoomTypeScalarFieldEnum]


  export const RoomTypeAmenityScalarFieldEnum: {
    roomTypeId: 'roomTypeId',
    amenityId: 'amenityId',
    createdAt: 'createdAt'
  };

  export type RoomTypeAmenityScalarFieldEnum = (typeof RoomTypeAmenityScalarFieldEnum)[keyof typeof RoomTypeAmenityScalarFieldEnum]


  export const RoomScalarFieldEnum: {
    id: 'id',
    roomTypeId: 'roomTypeId',
    roomNumber: 'roomNumber',
    floor: 'floor',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    hotelId: 'hotelId'
  };

  export type RoomScalarFieldEnum = (typeof RoomScalarFieldEnum)[keyof typeof RoomScalarFieldEnum]


  export const RoomInventoryScalarFieldEnum: {
    id: 'id',
    roomTypeId: 'roomTypeId',
    date: 'date',
    totalInventory: 'totalInventory',
    bookedCount: 'bookedCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    hotelId: 'hotelId'
  };

  export type RoomInventoryScalarFieldEnum = (typeof RoomInventoryScalarFieldEnum)[keyof typeof RoomInventoryScalarFieldEnum]


  export const RoomPriceScalarFieldEnum: {
    id: 'id',
    roomTypeId: 'roomTypeId',
    date: 'date',
    price: 'price',
    currency: 'currency',
    priceType: 'priceType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    hotelId: 'hotelId'
  };

  export type RoomPriceScalarFieldEnum = (typeof RoomPriceScalarFieldEnum)[keyof typeof RoomPriceScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    password: 'password',
    firstName: 'firstName',
    lastName: 'lastName',
    phoneNumber: 'phoneNumber',
    roleId: 'roleId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const BookingScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    roomTypeId: 'roomTypeId',
    numberOfRooms: 'numberOfRooms',
    checkIn: 'checkIn',
    checkOut: 'checkOut',
    totalAmount: 'totalAmount',
    currency: 'currency',
    status: 'status',
    guestName: 'guestName',
    guestSurname: 'guestSurname',
    guestEmail: 'guestEmail',
    guestPhone: 'guestPhone',
    guestIdentity: 'guestIdentity',
    promotionId: 'promotionId',
    cancellationPolicyId: 'cancellationPolicyId',
    promotionSnapshot: 'promotionSnapshot',
    policySnapshot: 'policySnapshot',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    hotelId: 'hotelId'
  };

  export type BookingScalarFieldEnum = (typeof BookingScalarFieldEnum)[keyof typeof BookingScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    amount: 'amount',
    currency: 'currency',
    paymentMethod: 'paymentMethod',
    paymentGatewayId: 'paymentGatewayId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    paymentId: 'paymentId',
    type: 'type',
    amount: 'amount',
    currency: 'currency',
    gatewayResponse: 'gatewayResponse',
    timestamp: 'timestamp',
    status: 'status'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    userId: 'userId',
    rating: 'rating',
    title: 'title',
    comment: 'comment',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    hotelId: 'hotelId'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const PromotionScalarFieldEnum: {
    id: 'id',
    code: 'code',
    description: 'description',
    discountType: 'discountType',
    discountValue: 'discountValue',
    validFrom: 'validFrom',
    validUntil: 'validUntil',
    maxUses: 'maxUses',
    usesPerUser: 'usesPerUser',
    currentUses: 'currentUses',
    minNights: 'minNights',
    minAmount: 'minAmount',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PromotionScalarFieldEnum = (typeof PromotionScalarFieldEnum)[keyof typeof PromotionScalarFieldEnum]


  export const CancellationPolicyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    rules: 'rules',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    hotelId: 'hotelId'
  };

  export type CancellationPolicyScalarFieldEnum = (typeof CancellationPolicyScalarFieldEnum)[keyof typeof CancellationPolicyScalarFieldEnum]


  export const CancellationScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    reason: 'reason',
    cancelledAt: 'cancelledAt',
    processedByUserId: 'processedByUserId',
    refundAmount: 'refundAmount',
    refundStatus: 'refundStatus',
    notes: 'notes'
  };

  export type CancellationScalarFieldEnum = (typeof CancellationScalarFieldEnum)[keyof typeof CancellationScalarFieldEnum]


  export const PromotionHotelScalarFieldEnum: {
    id: 'id',
    promotionId: 'promotionId',
    hotelId: 'hotelId',
    createdAt: 'createdAt'
  };

  export type PromotionHotelScalarFieldEnum = (typeof PromotionHotelScalarFieldEnum)[keyof typeof PromotionHotelScalarFieldEnum]


  export const PromotionRoomTypeScalarFieldEnum: {
    id: 'id',
    promotionId: 'promotionId',
    roomTypeId: 'roomTypeId',
    createdAt: 'createdAt'
  };

  export type PromotionRoomTypeScalarFieldEnum = (typeof PromotionRoomTypeScalarFieldEnum)[keyof typeof PromotionRoomTypeScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'RoomStatus'
   */
  export type EnumRoomStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoomStatus'>
    


  /**
   * Reference to a field of type 'RoomStatus[]'
   */
  export type ListEnumRoomStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoomStatus[]'>
    


  /**
   * Reference to a field of type 'CurrencyCode'
   */
  export type EnumCurrencyCodeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CurrencyCode'>
    


  /**
   * Reference to a field of type 'CurrencyCode[]'
   */
  export type ListEnumCurrencyCodeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CurrencyCode[]'>
    


  /**
   * Reference to a field of type 'PriceType'
   */
  export type EnumPriceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PriceType'>
    


  /**
   * Reference to a field of type 'PriceType[]'
   */
  export type ListEnumPriceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PriceType[]'>
    


  /**
   * Reference to a field of type 'BookingStatus'
   */
  export type EnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus'>
    


  /**
   * Reference to a field of type 'BookingStatus[]'
   */
  export type ListEnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    


  /**
   * Reference to a field of type 'TransactionType[]'
   */
  export type ListEnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType[]'>
    


  /**
   * Reference to a field of type 'TransactionStatus'
   */
  export type EnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus'>
    


  /**
   * Reference to a field of type 'TransactionStatus[]'
   */
  export type ListEnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus[]'>
    


  /**
   * Reference to a field of type 'DiscountType'
   */
  export type EnumDiscountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountType'>
    


  /**
   * Reference to a field of type 'DiscountType[]'
   */
  export type ListEnumDiscountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountType[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type HotelWhereInput = {
    AND?: HotelWhereInput | HotelWhereInput[]
    OR?: HotelWhereInput[]
    NOT?: HotelWhereInput | HotelWhereInput[]
    id?: IntFilter<"Hotel"> | number
    name?: StringFilter<"Hotel"> | string
    description?: StringNullableFilter<"Hotel"> | string | null
    addressId?: IntNullableFilter<"Hotel"> | number | null
    createdAt?: DateTimeFilter<"Hotel"> | Date | string
    updatedAt?: DateTimeFilter<"Hotel"> | Date | string
    Address?: XOR<AddressNullableScalarRelationFilter, AddressWhereInput> | null
    images?: ImageListRelationFilter
    amenities?: HotelAmenityListRelationFilter
    roomTypes?: RoomTypeListRelationFilter
    rooms?: RoomListRelationFilter
    bookings?: BookingListRelationFilter
    reviews?: ReviewListRelationFilter
    inventory?: RoomInventoryListRelationFilter
    prices?: RoomPriceListRelationFilter
    policies?: CancellationPolicyListRelationFilter
    PromotionHotel?: PromotionHotelListRelationFilter
  }

  export type HotelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    addressId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Address?: AddressOrderByWithRelationInput
    images?: ImageOrderByRelationAggregateInput
    amenities?: HotelAmenityOrderByRelationAggregateInput
    roomTypes?: RoomTypeOrderByRelationAggregateInput
    rooms?: RoomOrderByRelationAggregateInput
    bookings?: BookingOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    inventory?: RoomInventoryOrderByRelationAggregateInput
    prices?: RoomPriceOrderByRelationAggregateInput
    policies?: CancellationPolicyOrderByRelationAggregateInput
    PromotionHotel?: PromotionHotelOrderByRelationAggregateInput
  }

  export type HotelWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    addressId?: number
    AND?: HotelWhereInput | HotelWhereInput[]
    OR?: HotelWhereInput[]
    NOT?: HotelWhereInput | HotelWhereInput[]
    name?: StringFilter<"Hotel"> | string
    description?: StringNullableFilter<"Hotel"> | string | null
    createdAt?: DateTimeFilter<"Hotel"> | Date | string
    updatedAt?: DateTimeFilter<"Hotel"> | Date | string
    Address?: XOR<AddressNullableScalarRelationFilter, AddressWhereInput> | null
    images?: ImageListRelationFilter
    amenities?: HotelAmenityListRelationFilter
    roomTypes?: RoomTypeListRelationFilter
    rooms?: RoomListRelationFilter
    bookings?: BookingListRelationFilter
    reviews?: ReviewListRelationFilter
    inventory?: RoomInventoryListRelationFilter
    prices?: RoomPriceListRelationFilter
    policies?: CancellationPolicyListRelationFilter
    PromotionHotel?: PromotionHotelListRelationFilter
  }, "id" | "addressId">

  export type HotelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    addressId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HotelCountOrderByAggregateInput
    _avg?: HotelAvgOrderByAggregateInput
    _max?: HotelMaxOrderByAggregateInput
    _min?: HotelMinOrderByAggregateInput
    _sum?: HotelSumOrderByAggregateInput
  }

  export type HotelScalarWhereWithAggregatesInput = {
    AND?: HotelScalarWhereWithAggregatesInput | HotelScalarWhereWithAggregatesInput[]
    OR?: HotelScalarWhereWithAggregatesInput[]
    NOT?: HotelScalarWhereWithAggregatesInput | HotelScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Hotel"> | number
    name?: StringWithAggregatesFilter<"Hotel"> | string
    description?: StringNullableWithAggregatesFilter<"Hotel"> | string | null
    addressId?: IntNullableWithAggregatesFilter<"Hotel"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Hotel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Hotel"> | Date | string
  }

  export type AddressWhereInput = {
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    id?: IntFilter<"Address"> | number
    streetAddress?: StringFilter<"Address"> | string
    city?: StringFilter<"Address"> | string
    stateProvince?: StringNullableFilter<"Address"> | string | null
    postalCode?: StringFilter<"Address"> | string
    countryCode?: StringFilter<"Address"> | string
    latitude?: FloatNullableFilter<"Address"> | number | null
    longitude?: FloatNullableFilter<"Address"> | number | null
    createdAt?: DateTimeFilter<"Address"> | Date | string
    updatedAt?: DateTimeFilter<"Address"> | Date | string
    hotel?: XOR<HotelNullableScalarRelationFilter, HotelWhereInput> | null
  }

  export type AddressOrderByWithRelationInput = {
    id?: SortOrder
    streetAddress?: SortOrder
    city?: SortOrder
    stateProvince?: SortOrderInput | SortOrder
    postalCode?: SortOrder
    countryCode?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotel?: HotelOrderByWithRelationInput
  }

  export type AddressWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    streetAddress?: StringFilter<"Address"> | string
    city?: StringFilter<"Address"> | string
    stateProvince?: StringNullableFilter<"Address"> | string | null
    postalCode?: StringFilter<"Address"> | string
    countryCode?: StringFilter<"Address"> | string
    latitude?: FloatNullableFilter<"Address"> | number | null
    longitude?: FloatNullableFilter<"Address"> | number | null
    createdAt?: DateTimeFilter<"Address"> | Date | string
    updatedAt?: DateTimeFilter<"Address"> | Date | string
    hotel?: XOR<HotelNullableScalarRelationFilter, HotelWhereInput> | null
  }, "id">

  export type AddressOrderByWithAggregationInput = {
    id?: SortOrder
    streetAddress?: SortOrder
    city?: SortOrder
    stateProvince?: SortOrderInput | SortOrder
    postalCode?: SortOrder
    countryCode?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AddressCountOrderByAggregateInput
    _avg?: AddressAvgOrderByAggregateInput
    _max?: AddressMaxOrderByAggregateInput
    _min?: AddressMinOrderByAggregateInput
    _sum?: AddressSumOrderByAggregateInput
  }

  export type AddressScalarWhereWithAggregatesInput = {
    AND?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    OR?: AddressScalarWhereWithAggregatesInput[]
    NOT?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Address"> | number
    streetAddress?: StringWithAggregatesFilter<"Address"> | string
    city?: StringWithAggregatesFilter<"Address"> | string
    stateProvince?: StringNullableWithAggregatesFilter<"Address"> | string | null
    postalCode?: StringWithAggregatesFilter<"Address"> | string
    countryCode?: StringWithAggregatesFilter<"Address"> | string
    latitude?: FloatNullableWithAggregatesFilter<"Address"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"Address"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Address"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Address"> | Date | string
  }

  export type ImageWhereInput = {
    AND?: ImageWhereInput | ImageWhereInput[]
    OR?: ImageWhereInput[]
    NOT?: ImageWhereInput | ImageWhereInput[]
    id?: IntFilter<"Image"> | number
    url?: StringFilter<"Image"> | string
    altText?: StringNullableFilter<"Image"> | string | null
    order?: IntNullableFilter<"Image"> | number | null
    hotelId?: IntNullableFilter<"Image"> | number | null
    roomTypeId?: IntNullableFilter<"Image"> | number | null
    createdAt?: DateTimeFilter<"Image"> | Date | string
    Hotel?: XOR<HotelNullableScalarRelationFilter, HotelWhereInput> | null
    RoomType?: XOR<RoomTypeNullableScalarRelationFilter, RoomTypeWhereInput> | null
  }

  export type ImageOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    altText?: SortOrderInput | SortOrder
    order?: SortOrderInput | SortOrder
    hotelId?: SortOrderInput | SortOrder
    roomTypeId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    Hotel?: HotelOrderByWithRelationInput
    RoomType?: RoomTypeOrderByWithRelationInput
  }

  export type ImageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ImageWhereInput | ImageWhereInput[]
    OR?: ImageWhereInput[]
    NOT?: ImageWhereInput | ImageWhereInput[]
    url?: StringFilter<"Image"> | string
    altText?: StringNullableFilter<"Image"> | string | null
    order?: IntNullableFilter<"Image"> | number | null
    hotelId?: IntNullableFilter<"Image"> | number | null
    roomTypeId?: IntNullableFilter<"Image"> | number | null
    createdAt?: DateTimeFilter<"Image"> | Date | string
    Hotel?: XOR<HotelNullableScalarRelationFilter, HotelWhereInput> | null
    RoomType?: XOR<RoomTypeNullableScalarRelationFilter, RoomTypeWhereInput> | null
  }, "id">

  export type ImageOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    altText?: SortOrderInput | SortOrder
    order?: SortOrderInput | SortOrder
    hotelId?: SortOrderInput | SortOrder
    roomTypeId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ImageCountOrderByAggregateInput
    _avg?: ImageAvgOrderByAggregateInput
    _max?: ImageMaxOrderByAggregateInput
    _min?: ImageMinOrderByAggregateInput
    _sum?: ImageSumOrderByAggregateInput
  }

  export type ImageScalarWhereWithAggregatesInput = {
    AND?: ImageScalarWhereWithAggregatesInput | ImageScalarWhereWithAggregatesInput[]
    OR?: ImageScalarWhereWithAggregatesInput[]
    NOT?: ImageScalarWhereWithAggregatesInput | ImageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Image"> | number
    url?: StringWithAggregatesFilter<"Image"> | string
    altText?: StringNullableWithAggregatesFilter<"Image"> | string | null
    order?: IntNullableWithAggregatesFilter<"Image"> | number | null
    hotelId?: IntNullableWithAggregatesFilter<"Image"> | number | null
    roomTypeId?: IntNullableWithAggregatesFilter<"Image"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Image"> | Date | string
  }

  export type AmenityWhereInput = {
    AND?: AmenityWhereInput | AmenityWhereInput[]
    OR?: AmenityWhereInput[]
    NOT?: AmenityWhereInput | AmenityWhereInput[]
    id?: IntFilter<"Amenity"> | number
    name?: StringFilter<"Amenity"> | string
    description?: StringNullableFilter<"Amenity"> | string | null
    category?: StringNullableFilter<"Amenity"> | string | null
    createdAt?: DateTimeFilter<"Amenity"> | Date | string
    hotels?: HotelAmenityListRelationFilter
    roomTypes?: RoomTypeAmenityListRelationFilter
  }

  export type AmenityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    hotels?: HotelAmenityOrderByRelationAggregateInput
    roomTypes?: RoomTypeAmenityOrderByRelationAggregateInput
  }

  export type AmenityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: AmenityWhereInput | AmenityWhereInput[]
    OR?: AmenityWhereInput[]
    NOT?: AmenityWhereInput | AmenityWhereInput[]
    description?: StringNullableFilter<"Amenity"> | string | null
    category?: StringNullableFilter<"Amenity"> | string | null
    createdAt?: DateTimeFilter<"Amenity"> | Date | string
    hotels?: HotelAmenityListRelationFilter
    roomTypes?: RoomTypeAmenityListRelationFilter
  }, "id" | "name">

  export type AmenityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AmenityCountOrderByAggregateInput
    _avg?: AmenityAvgOrderByAggregateInput
    _max?: AmenityMaxOrderByAggregateInput
    _min?: AmenityMinOrderByAggregateInput
    _sum?: AmenitySumOrderByAggregateInput
  }

  export type AmenityScalarWhereWithAggregatesInput = {
    AND?: AmenityScalarWhereWithAggregatesInput | AmenityScalarWhereWithAggregatesInput[]
    OR?: AmenityScalarWhereWithAggregatesInput[]
    NOT?: AmenityScalarWhereWithAggregatesInput | AmenityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Amenity"> | number
    name?: StringWithAggregatesFilter<"Amenity"> | string
    description?: StringNullableWithAggregatesFilter<"Amenity"> | string | null
    category?: StringNullableWithAggregatesFilter<"Amenity"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Amenity"> | Date | string
  }

  export type HotelAmenityWhereInput = {
    AND?: HotelAmenityWhereInput | HotelAmenityWhereInput[]
    OR?: HotelAmenityWhereInput[]
    NOT?: HotelAmenityWhereInput | HotelAmenityWhereInput[]
    hotelId?: IntFilter<"HotelAmenity"> | number
    amenityId?: IntFilter<"HotelAmenity"> | number
    details?: JsonNullableFilter<"HotelAmenity">
    createdAt?: DateTimeFilter<"HotelAmenity"> | Date | string
    Hotel?: XOR<HotelScalarRelationFilter, HotelWhereInput>
    Amenity?: XOR<AmenityScalarRelationFilter, AmenityWhereInput>
  }

  export type HotelAmenityOrderByWithRelationInput = {
    hotelId?: SortOrder
    amenityId?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    Hotel?: HotelOrderByWithRelationInput
    Amenity?: AmenityOrderByWithRelationInput
  }

  export type HotelAmenityWhereUniqueInput = Prisma.AtLeast<{
    hotelId_amenityId?: HotelAmenityHotelIdAmenityIdCompoundUniqueInput
    AND?: HotelAmenityWhereInput | HotelAmenityWhereInput[]
    OR?: HotelAmenityWhereInput[]
    NOT?: HotelAmenityWhereInput | HotelAmenityWhereInput[]
    hotelId?: IntFilter<"HotelAmenity"> | number
    amenityId?: IntFilter<"HotelAmenity"> | number
    details?: JsonNullableFilter<"HotelAmenity">
    createdAt?: DateTimeFilter<"HotelAmenity"> | Date | string
    Hotel?: XOR<HotelScalarRelationFilter, HotelWhereInput>
    Amenity?: XOR<AmenityScalarRelationFilter, AmenityWhereInput>
  }, "hotelId_amenityId">

  export type HotelAmenityOrderByWithAggregationInput = {
    hotelId?: SortOrder
    amenityId?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: HotelAmenityCountOrderByAggregateInput
    _avg?: HotelAmenityAvgOrderByAggregateInput
    _max?: HotelAmenityMaxOrderByAggregateInput
    _min?: HotelAmenityMinOrderByAggregateInput
    _sum?: HotelAmenitySumOrderByAggregateInput
  }

  export type HotelAmenityScalarWhereWithAggregatesInput = {
    AND?: HotelAmenityScalarWhereWithAggregatesInput | HotelAmenityScalarWhereWithAggregatesInput[]
    OR?: HotelAmenityScalarWhereWithAggregatesInput[]
    NOT?: HotelAmenityScalarWhereWithAggregatesInput | HotelAmenityScalarWhereWithAggregatesInput[]
    hotelId?: IntWithAggregatesFilter<"HotelAmenity"> | number
    amenityId?: IntWithAggregatesFilter<"HotelAmenity"> | number
    details?: JsonNullableWithAggregatesFilter<"HotelAmenity">
    createdAt?: DateTimeWithAggregatesFilter<"HotelAmenity"> | Date | string
  }

  export type RoomTypeWhereInput = {
    AND?: RoomTypeWhereInput | RoomTypeWhereInput[]
    OR?: RoomTypeWhereInput[]
    NOT?: RoomTypeWhereInput | RoomTypeWhereInput[]
    id?: IntFilter<"RoomType"> | number
    hotelId?: IntFilter<"RoomType"> | number
    name?: StringFilter<"RoomType"> | string
    description?: StringNullableFilter<"RoomType"> | string | null
    maxGuests?: IntFilter<"RoomType"> | number
    createdAt?: DateTimeFilter<"RoomType"> | Date | string
    updatedAt?: DateTimeFilter<"RoomType"> | Date | string
    Hotel?: XOR<HotelScalarRelationFilter, HotelWhereInput>
    images?: ImageListRelationFilter
    amenities?: RoomTypeAmenityListRelationFilter
    rooms?: RoomListRelationFilter
    inventory?: RoomInventoryListRelationFilter
    prices?: RoomPriceListRelationFilter
    bookings?: BookingListRelationFilter
    PromotionRoomType?: PromotionRoomTypeListRelationFilter
  }

  export type RoomTypeOrderByWithRelationInput = {
    id?: SortOrder
    hotelId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    maxGuests?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Hotel?: HotelOrderByWithRelationInput
    images?: ImageOrderByRelationAggregateInput
    amenities?: RoomTypeAmenityOrderByRelationAggregateInput
    rooms?: RoomOrderByRelationAggregateInput
    inventory?: RoomInventoryOrderByRelationAggregateInput
    prices?: RoomPriceOrderByRelationAggregateInput
    bookings?: BookingOrderByRelationAggregateInput
    PromotionRoomType?: PromotionRoomTypeOrderByRelationAggregateInput
  }

  export type RoomTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    hotelId_name?: RoomTypeHotelIdNameCompoundUniqueInput
    AND?: RoomTypeWhereInput | RoomTypeWhereInput[]
    OR?: RoomTypeWhereInput[]
    NOT?: RoomTypeWhereInput | RoomTypeWhereInput[]
    hotelId?: IntFilter<"RoomType"> | number
    name?: StringFilter<"RoomType"> | string
    description?: StringNullableFilter<"RoomType"> | string | null
    maxGuests?: IntFilter<"RoomType"> | number
    createdAt?: DateTimeFilter<"RoomType"> | Date | string
    updatedAt?: DateTimeFilter<"RoomType"> | Date | string
    Hotel?: XOR<HotelScalarRelationFilter, HotelWhereInput>
    images?: ImageListRelationFilter
    amenities?: RoomTypeAmenityListRelationFilter
    rooms?: RoomListRelationFilter
    inventory?: RoomInventoryListRelationFilter
    prices?: RoomPriceListRelationFilter
    bookings?: BookingListRelationFilter
    PromotionRoomType?: PromotionRoomTypeListRelationFilter
  }, "id" | "hotelId_name">

  export type RoomTypeOrderByWithAggregationInput = {
    id?: SortOrder
    hotelId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    maxGuests?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoomTypeCountOrderByAggregateInput
    _avg?: RoomTypeAvgOrderByAggregateInput
    _max?: RoomTypeMaxOrderByAggregateInput
    _min?: RoomTypeMinOrderByAggregateInput
    _sum?: RoomTypeSumOrderByAggregateInput
  }

  export type RoomTypeScalarWhereWithAggregatesInput = {
    AND?: RoomTypeScalarWhereWithAggregatesInput | RoomTypeScalarWhereWithAggregatesInput[]
    OR?: RoomTypeScalarWhereWithAggregatesInput[]
    NOT?: RoomTypeScalarWhereWithAggregatesInput | RoomTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RoomType"> | number
    hotelId?: IntWithAggregatesFilter<"RoomType"> | number
    name?: StringWithAggregatesFilter<"RoomType"> | string
    description?: StringNullableWithAggregatesFilter<"RoomType"> | string | null
    maxGuests?: IntWithAggregatesFilter<"RoomType"> | number
    createdAt?: DateTimeWithAggregatesFilter<"RoomType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RoomType"> | Date | string
  }

  export type RoomTypeAmenityWhereInput = {
    AND?: RoomTypeAmenityWhereInput | RoomTypeAmenityWhereInput[]
    OR?: RoomTypeAmenityWhereInput[]
    NOT?: RoomTypeAmenityWhereInput | RoomTypeAmenityWhereInput[]
    roomTypeId?: IntFilter<"RoomTypeAmenity"> | number
    amenityId?: IntFilter<"RoomTypeAmenity"> | number
    createdAt?: DateTimeFilter<"RoomTypeAmenity"> | Date | string
    RoomType?: XOR<RoomTypeScalarRelationFilter, RoomTypeWhereInput>
    Amenity?: XOR<AmenityScalarRelationFilter, AmenityWhereInput>
  }

  export type RoomTypeAmenityOrderByWithRelationInput = {
    roomTypeId?: SortOrder
    amenityId?: SortOrder
    createdAt?: SortOrder
    RoomType?: RoomTypeOrderByWithRelationInput
    Amenity?: AmenityOrderByWithRelationInput
  }

  export type RoomTypeAmenityWhereUniqueInput = Prisma.AtLeast<{
    roomTypeId_amenityId?: RoomTypeAmenityRoomTypeIdAmenityIdCompoundUniqueInput
    AND?: RoomTypeAmenityWhereInput | RoomTypeAmenityWhereInput[]
    OR?: RoomTypeAmenityWhereInput[]
    NOT?: RoomTypeAmenityWhereInput | RoomTypeAmenityWhereInput[]
    roomTypeId?: IntFilter<"RoomTypeAmenity"> | number
    amenityId?: IntFilter<"RoomTypeAmenity"> | number
    createdAt?: DateTimeFilter<"RoomTypeAmenity"> | Date | string
    RoomType?: XOR<RoomTypeScalarRelationFilter, RoomTypeWhereInput>
    Amenity?: XOR<AmenityScalarRelationFilter, AmenityWhereInput>
  }, "roomTypeId_amenityId">

  export type RoomTypeAmenityOrderByWithAggregationInput = {
    roomTypeId?: SortOrder
    amenityId?: SortOrder
    createdAt?: SortOrder
    _count?: RoomTypeAmenityCountOrderByAggregateInput
    _avg?: RoomTypeAmenityAvgOrderByAggregateInput
    _max?: RoomTypeAmenityMaxOrderByAggregateInput
    _min?: RoomTypeAmenityMinOrderByAggregateInput
    _sum?: RoomTypeAmenitySumOrderByAggregateInput
  }

  export type RoomTypeAmenityScalarWhereWithAggregatesInput = {
    AND?: RoomTypeAmenityScalarWhereWithAggregatesInput | RoomTypeAmenityScalarWhereWithAggregatesInput[]
    OR?: RoomTypeAmenityScalarWhereWithAggregatesInput[]
    NOT?: RoomTypeAmenityScalarWhereWithAggregatesInput | RoomTypeAmenityScalarWhereWithAggregatesInput[]
    roomTypeId?: IntWithAggregatesFilter<"RoomTypeAmenity"> | number
    amenityId?: IntWithAggregatesFilter<"RoomTypeAmenity"> | number
    createdAt?: DateTimeWithAggregatesFilter<"RoomTypeAmenity"> | Date | string
  }

  export type RoomWhereInput = {
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    id?: IntFilter<"Room"> | number
    roomTypeId?: IntFilter<"Room"> | number
    roomNumber?: StringFilter<"Room"> | string
    floor?: StringNullableFilter<"Room"> | string | null
    status?: EnumRoomStatusFilter<"Room"> | $Enums.RoomStatus
    createdAt?: DateTimeFilter<"Room"> | Date | string
    updatedAt?: DateTimeFilter<"Room"> | Date | string
    hotelId?: IntNullableFilter<"Room"> | number | null
    RoomType?: XOR<RoomTypeScalarRelationFilter, RoomTypeWhereInput>
    Hotel?: XOR<HotelNullableScalarRelationFilter, HotelWhereInput> | null
  }

  export type RoomOrderByWithRelationInput = {
    id?: SortOrder
    roomTypeId?: SortOrder
    roomNumber?: SortOrder
    floor?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelId?: SortOrderInput | SortOrder
    RoomType?: RoomTypeOrderByWithRelationInput
    Hotel?: HotelOrderByWithRelationInput
  }

  export type RoomWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    roomTypeId?: IntFilter<"Room"> | number
    roomNumber?: StringFilter<"Room"> | string
    floor?: StringNullableFilter<"Room"> | string | null
    status?: EnumRoomStatusFilter<"Room"> | $Enums.RoomStatus
    createdAt?: DateTimeFilter<"Room"> | Date | string
    updatedAt?: DateTimeFilter<"Room"> | Date | string
    hotelId?: IntNullableFilter<"Room"> | number | null
    RoomType?: XOR<RoomTypeScalarRelationFilter, RoomTypeWhereInput>
    Hotel?: XOR<HotelNullableScalarRelationFilter, HotelWhereInput> | null
  }, "id">

  export type RoomOrderByWithAggregationInput = {
    id?: SortOrder
    roomTypeId?: SortOrder
    roomNumber?: SortOrder
    floor?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelId?: SortOrderInput | SortOrder
    _count?: RoomCountOrderByAggregateInput
    _avg?: RoomAvgOrderByAggregateInput
    _max?: RoomMaxOrderByAggregateInput
    _min?: RoomMinOrderByAggregateInput
    _sum?: RoomSumOrderByAggregateInput
  }

  export type RoomScalarWhereWithAggregatesInput = {
    AND?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    OR?: RoomScalarWhereWithAggregatesInput[]
    NOT?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Room"> | number
    roomTypeId?: IntWithAggregatesFilter<"Room"> | number
    roomNumber?: StringWithAggregatesFilter<"Room"> | string
    floor?: StringNullableWithAggregatesFilter<"Room"> | string | null
    status?: EnumRoomStatusWithAggregatesFilter<"Room"> | $Enums.RoomStatus
    createdAt?: DateTimeWithAggregatesFilter<"Room"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Room"> | Date | string
    hotelId?: IntNullableWithAggregatesFilter<"Room"> | number | null
  }

  export type RoomInventoryWhereInput = {
    AND?: RoomInventoryWhereInput | RoomInventoryWhereInput[]
    OR?: RoomInventoryWhereInput[]
    NOT?: RoomInventoryWhereInput | RoomInventoryWhereInput[]
    id?: IntFilter<"RoomInventory"> | number
    roomTypeId?: IntFilter<"RoomInventory"> | number
    date?: DateTimeFilter<"RoomInventory"> | Date | string
    totalInventory?: IntFilter<"RoomInventory"> | number
    bookedCount?: IntFilter<"RoomInventory"> | number
    createdAt?: DateTimeFilter<"RoomInventory"> | Date | string
    updatedAt?: DateTimeFilter<"RoomInventory"> | Date | string
    hotelId?: IntNullableFilter<"RoomInventory"> | number | null
    RoomType?: XOR<RoomTypeScalarRelationFilter, RoomTypeWhereInput>
    Hotel?: XOR<HotelNullableScalarRelationFilter, HotelWhereInput> | null
  }

  export type RoomInventoryOrderByWithRelationInput = {
    id?: SortOrder
    roomTypeId?: SortOrder
    date?: SortOrder
    totalInventory?: SortOrder
    bookedCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelId?: SortOrderInput | SortOrder
    RoomType?: RoomTypeOrderByWithRelationInput
    Hotel?: HotelOrderByWithRelationInput
  }

  export type RoomInventoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    roomTypeId_date?: RoomInventoryRoomTypeIdDateCompoundUniqueInput
    AND?: RoomInventoryWhereInput | RoomInventoryWhereInput[]
    OR?: RoomInventoryWhereInput[]
    NOT?: RoomInventoryWhereInput | RoomInventoryWhereInput[]
    roomTypeId?: IntFilter<"RoomInventory"> | number
    date?: DateTimeFilter<"RoomInventory"> | Date | string
    totalInventory?: IntFilter<"RoomInventory"> | number
    bookedCount?: IntFilter<"RoomInventory"> | number
    createdAt?: DateTimeFilter<"RoomInventory"> | Date | string
    updatedAt?: DateTimeFilter<"RoomInventory"> | Date | string
    hotelId?: IntNullableFilter<"RoomInventory"> | number | null
    RoomType?: XOR<RoomTypeScalarRelationFilter, RoomTypeWhereInput>
    Hotel?: XOR<HotelNullableScalarRelationFilter, HotelWhereInput> | null
  }, "id" | "roomTypeId_date">

  export type RoomInventoryOrderByWithAggregationInput = {
    id?: SortOrder
    roomTypeId?: SortOrder
    date?: SortOrder
    totalInventory?: SortOrder
    bookedCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelId?: SortOrderInput | SortOrder
    _count?: RoomInventoryCountOrderByAggregateInput
    _avg?: RoomInventoryAvgOrderByAggregateInput
    _max?: RoomInventoryMaxOrderByAggregateInput
    _min?: RoomInventoryMinOrderByAggregateInput
    _sum?: RoomInventorySumOrderByAggregateInput
  }

  export type RoomInventoryScalarWhereWithAggregatesInput = {
    AND?: RoomInventoryScalarWhereWithAggregatesInput | RoomInventoryScalarWhereWithAggregatesInput[]
    OR?: RoomInventoryScalarWhereWithAggregatesInput[]
    NOT?: RoomInventoryScalarWhereWithAggregatesInput | RoomInventoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RoomInventory"> | number
    roomTypeId?: IntWithAggregatesFilter<"RoomInventory"> | number
    date?: DateTimeWithAggregatesFilter<"RoomInventory"> | Date | string
    totalInventory?: IntWithAggregatesFilter<"RoomInventory"> | number
    bookedCount?: IntWithAggregatesFilter<"RoomInventory"> | number
    createdAt?: DateTimeWithAggregatesFilter<"RoomInventory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RoomInventory"> | Date | string
    hotelId?: IntNullableWithAggregatesFilter<"RoomInventory"> | number | null
  }

  export type RoomPriceWhereInput = {
    AND?: RoomPriceWhereInput | RoomPriceWhereInput[]
    OR?: RoomPriceWhereInput[]
    NOT?: RoomPriceWhereInput | RoomPriceWhereInput[]
    id?: IntFilter<"RoomPrice"> | number
    roomTypeId?: IntFilter<"RoomPrice"> | number
    date?: DateTimeFilter<"RoomPrice"> | Date | string
    price?: FloatFilter<"RoomPrice"> | number
    currency?: EnumCurrencyCodeFilter<"RoomPrice"> | $Enums.CurrencyCode
    priceType?: EnumPriceTypeNullableFilter<"RoomPrice"> | $Enums.PriceType | null
    createdAt?: DateTimeFilter<"RoomPrice"> | Date | string
    updatedAt?: DateTimeFilter<"RoomPrice"> | Date | string
    hotelId?: IntNullableFilter<"RoomPrice"> | number | null
    RoomType?: XOR<RoomTypeScalarRelationFilter, RoomTypeWhereInput>
    Hotel?: XOR<HotelNullableScalarRelationFilter, HotelWhereInput> | null
  }

  export type RoomPriceOrderByWithRelationInput = {
    id?: SortOrder
    roomTypeId?: SortOrder
    date?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    priceType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelId?: SortOrderInput | SortOrder
    RoomType?: RoomTypeOrderByWithRelationInput
    Hotel?: HotelOrderByWithRelationInput
  }

  export type RoomPriceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    roomTypeId_date?: RoomPriceRoomTypeIdDateCompoundUniqueInput
    AND?: RoomPriceWhereInput | RoomPriceWhereInput[]
    OR?: RoomPriceWhereInput[]
    NOT?: RoomPriceWhereInput | RoomPriceWhereInput[]
    roomTypeId?: IntFilter<"RoomPrice"> | number
    date?: DateTimeFilter<"RoomPrice"> | Date | string
    price?: FloatFilter<"RoomPrice"> | number
    currency?: EnumCurrencyCodeFilter<"RoomPrice"> | $Enums.CurrencyCode
    priceType?: EnumPriceTypeNullableFilter<"RoomPrice"> | $Enums.PriceType | null
    createdAt?: DateTimeFilter<"RoomPrice"> | Date | string
    updatedAt?: DateTimeFilter<"RoomPrice"> | Date | string
    hotelId?: IntNullableFilter<"RoomPrice"> | number | null
    RoomType?: XOR<RoomTypeScalarRelationFilter, RoomTypeWhereInput>
    Hotel?: XOR<HotelNullableScalarRelationFilter, HotelWhereInput> | null
  }, "id" | "roomTypeId_date">

  export type RoomPriceOrderByWithAggregationInput = {
    id?: SortOrder
    roomTypeId?: SortOrder
    date?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    priceType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelId?: SortOrderInput | SortOrder
    _count?: RoomPriceCountOrderByAggregateInput
    _avg?: RoomPriceAvgOrderByAggregateInput
    _max?: RoomPriceMaxOrderByAggregateInput
    _min?: RoomPriceMinOrderByAggregateInput
    _sum?: RoomPriceSumOrderByAggregateInput
  }

  export type RoomPriceScalarWhereWithAggregatesInput = {
    AND?: RoomPriceScalarWhereWithAggregatesInput | RoomPriceScalarWhereWithAggregatesInput[]
    OR?: RoomPriceScalarWhereWithAggregatesInput[]
    NOT?: RoomPriceScalarWhereWithAggregatesInput | RoomPriceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RoomPrice"> | number
    roomTypeId?: IntWithAggregatesFilter<"RoomPrice"> | number
    date?: DateTimeWithAggregatesFilter<"RoomPrice"> | Date | string
    price?: FloatWithAggregatesFilter<"RoomPrice"> | number
    currency?: EnumCurrencyCodeWithAggregatesFilter<"RoomPrice"> | $Enums.CurrencyCode
    priceType?: EnumPriceTypeNullableWithAggregatesFilter<"RoomPrice"> | $Enums.PriceType | null
    createdAt?: DateTimeWithAggregatesFilter<"RoomPrice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RoomPrice"> | Date | string
    hotelId?: IntNullableWithAggregatesFilter<"RoomPrice"> | number | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    phoneNumber?: StringNullableFilter<"User"> | string | null
    roleId?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    Role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    bookings?: BookingListRelationFilter
    reviews?: ReviewListRelationFilter
    cancellations?: CancellationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Role?: RoleOrderByWithRelationInput
    bookings?: BookingOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    cancellations?: CancellationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    email?: string
    phoneNumber?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringNullableFilter<"User"> | string | null
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    roleId?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    Role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    bookings?: BookingListRelationFilter
    reviews?: ReviewListRelationFilter
    cancellations?: CancellationListRelationFilter
  }, "id" | "username" | "email" | "phoneNumber">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    username?: StringWithAggregatesFilter<"User"> | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    phoneNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    roleId?: IntWithAggregatesFilter<"User"> | number
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: IntFilter<"Role"> | number
    name?: StringFilter<"Role"> | string
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    users?: UserListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    users?: UserListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _avg?: RoleAvgOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
    _sum?: RoleSumOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Role"> | number
    name?: StringWithAggregatesFilter<"Role"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
  }

  export type BookingWhereInput = {
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    id?: IntFilter<"Booking"> | number
    userId?: IntNullableFilter<"Booking"> | number | null
    roomTypeId?: IntFilter<"Booking"> | number
    numberOfRooms?: IntFilter<"Booking"> | number
    checkIn?: DateTimeFilter<"Booking"> | Date | string
    checkOut?: DateTimeFilter<"Booking"> | Date | string
    totalAmount?: FloatNullableFilter<"Booking"> | number | null
    currency?: EnumCurrencyCodeFilter<"Booking"> | $Enums.CurrencyCode
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    guestName?: StringNullableFilter<"Booking"> | string | null
    guestSurname?: StringNullableFilter<"Booking"> | string | null
    guestEmail?: StringNullableFilter<"Booking"> | string | null
    guestPhone?: StringNullableFilter<"Booking"> | string | null
    guestIdentity?: StringNullableFilter<"Booking"> | string | null
    promotionId?: IntNullableFilter<"Booking"> | number | null
    cancellationPolicyId?: IntNullableFilter<"Booking"> | number | null
    promotionSnapshot?: JsonNullableFilter<"Booking">
    policySnapshot?: JsonNullableFilter<"Booking">
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    hotelId?: IntNullableFilter<"Booking"> | number | null
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    RoomType?: XOR<RoomTypeScalarRelationFilter, RoomTypeWhereInput>
    payment?: XOR<PaymentNullableScalarRelationFilter, PaymentWhereInput> | null
    review?: XOR<ReviewNullableScalarRelationFilter, ReviewWhereInput> | null
    Promotion?: XOR<PromotionNullableScalarRelationFilter, PromotionWhereInput> | null
    CancellationPolicy?: XOR<CancellationPolicyNullableScalarRelationFilter, CancellationPolicyWhereInput> | null
    cancellation?: XOR<CancellationNullableScalarRelationFilter, CancellationWhereInput> | null
    Hotel?: XOR<HotelNullableScalarRelationFilter, HotelWhereInput> | null
  }

  export type BookingOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    roomTypeId?: SortOrder
    numberOfRooms?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
    totalAmount?: SortOrderInput | SortOrder
    currency?: SortOrder
    status?: SortOrder
    guestName?: SortOrderInput | SortOrder
    guestSurname?: SortOrderInput | SortOrder
    guestEmail?: SortOrderInput | SortOrder
    guestPhone?: SortOrderInput | SortOrder
    guestIdentity?: SortOrderInput | SortOrder
    promotionId?: SortOrderInput | SortOrder
    cancellationPolicyId?: SortOrderInput | SortOrder
    promotionSnapshot?: SortOrderInput | SortOrder
    policySnapshot?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelId?: SortOrderInput | SortOrder
    User?: UserOrderByWithRelationInput
    RoomType?: RoomTypeOrderByWithRelationInput
    payment?: PaymentOrderByWithRelationInput
    review?: ReviewOrderByWithRelationInput
    Promotion?: PromotionOrderByWithRelationInput
    CancellationPolicy?: CancellationPolicyOrderByWithRelationInput
    cancellation?: CancellationOrderByWithRelationInput
    Hotel?: HotelOrderByWithRelationInput
  }

  export type BookingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    userId?: IntNullableFilter<"Booking"> | number | null
    roomTypeId?: IntFilter<"Booking"> | number
    numberOfRooms?: IntFilter<"Booking"> | number
    checkIn?: DateTimeFilter<"Booking"> | Date | string
    checkOut?: DateTimeFilter<"Booking"> | Date | string
    totalAmount?: FloatNullableFilter<"Booking"> | number | null
    currency?: EnumCurrencyCodeFilter<"Booking"> | $Enums.CurrencyCode
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    guestName?: StringNullableFilter<"Booking"> | string | null
    guestSurname?: StringNullableFilter<"Booking"> | string | null
    guestEmail?: StringNullableFilter<"Booking"> | string | null
    guestPhone?: StringNullableFilter<"Booking"> | string | null
    guestIdentity?: StringNullableFilter<"Booking"> | string | null
    promotionId?: IntNullableFilter<"Booking"> | number | null
    cancellationPolicyId?: IntNullableFilter<"Booking"> | number | null
    promotionSnapshot?: JsonNullableFilter<"Booking">
    policySnapshot?: JsonNullableFilter<"Booking">
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    hotelId?: IntNullableFilter<"Booking"> | number | null
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    RoomType?: XOR<RoomTypeScalarRelationFilter, RoomTypeWhereInput>
    payment?: XOR<PaymentNullableScalarRelationFilter, PaymentWhereInput> | null
    review?: XOR<ReviewNullableScalarRelationFilter, ReviewWhereInput> | null
    Promotion?: XOR<PromotionNullableScalarRelationFilter, PromotionWhereInput> | null
    CancellationPolicy?: XOR<CancellationPolicyNullableScalarRelationFilter, CancellationPolicyWhereInput> | null
    cancellation?: XOR<CancellationNullableScalarRelationFilter, CancellationWhereInput> | null
    Hotel?: XOR<HotelNullableScalarRelationFilter, HotelWhereInput> | null
  }, "id">

  export type BookingOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    roomTypeId?: SortOrder
    numberOfRooms?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
    totalAmount?: SortOrderInput | SortOrder
    currency?: SortOrder
    status?: SortOrder
    guestName?: SortOrderInput | SortOrder
    guestSurname?: SortOrderInput | SortOrder
    guestEmail?: SortOrderInput | SortOrder
    guestPhone?: SortOrderInput | SortOrder
    guestIdentity?: SortOrderInput | SortOrder
    promotionId?: SortOrderInput | SortOrder
    cancellationPolicyId?: SortOrderInput | SortOrder
    promotionSnapshot?: SortOrderInput | SortOrder
    policySnapshot?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelId?: SortOrderInput | SortOrder
    _count?: BookingCountOrderByAggregateInput
    _avg?: BookingAvgOrderByAggregateInput
    _max?: BookingMaxOrderByAggregateInput
    _min?: BookingMinOrderByAggregateInput
    _sum?: BookingSumOrderByAggregateInput
  }

  export type BookingScalarWhereWithAggregatesInput = {
    AND?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    OR?: BookingScalarWhereWithAggregatesInput[]
    NOT?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Booking"> | number
    userId?: IntNullableWithAggregatesFilter<"Booking"> | number | null
    roomTypeId?: IntWithAggregatesFilter<"Booking"> | number
    numberOfRooms?: IntWithAggregatesFilter<"Booking"> | number
    checkIn?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    checkOut?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    totalAmount?: FloatNullableWithAggregatesFilter<"Booking"> | number | null
    currency?: EnumCurrencyCodeWithAggregatesFilter<"Booking"> | $Enums.CurrencyCode
    status?: EnumBookingStatusWithAggregatesFilter<"Booking"> | $Enums.BookingStatus
    guestName?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    guestSurname?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    guestEmail?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    guestPhone?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    guestIdentity?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    promotionId?: IntNullableWithAggregatesFilter<"Booking"> | number | null
    cancellationPolicyId?: IntNullableWithAggregatesFilter<"Booking"> | number | null
    promotionSnapshot?: JsonNullableWithAggregatesFilter<"Booking">
    policySnapshot?: JsonNullableWithAggregatesFilter<"Booking">
    createdAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    hotelId?: IntNullableWithAggregatesFilter<"Booking"> | number | null
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    bookingId?: IntFilter<"Payment"> | number
    amount?: FloatFilter<"Payment"> | number
    currency?: EnumCurrencyCodeFilter<"Payment"> | $Enums.CurrencyCode
    paymentMethod?: EnumPaymentMethodNullableFilter<"Payment"> | $Enums.PaymentMethod | null
    paymentGatewayId?: StringNullableFilter<"Payment"> | string | null
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    Booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    transactions?: TransactionListRelationFilter
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    paymentGatewayId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Booking?: BookingOrderByWithRelationInput
    transactions?: TransactionOrderByRelationAggregateInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    bookingId?: number
    paymentGatewayId?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    amount?: FloatFilter<"Payment"> | number
    currency?: EnumCurrencyCodeFilter<"Payment"> | $Enums.CurrencyCode
    paymentMethod?: EnumPaymentMethodNullableFilter<"Payment"> | $Enums.PaymentMethod | null
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    Booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    transactions?: TransactionListRelationFilter
  }, "id" | "bookingId" | "paymentGatewayId">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    paymentGatewayId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    bookingId?: IntWithAggregatesFilter<"Payment"> | number
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    currency?: EnumCurrencyCodeWithAggregatesFilter<"Payment"> | $Enums.CurrencyCode
    paymentMethod?: EnumPaymentMethodNullableWithAggregatesFilter<"Payment"> | $Enums.PaymentMethod | null
    paymentGatewayId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    status?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    paymentId?: StringFilter<"Transaction"> | string
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    amount?: FloatFilter<"Transaction"> | number
    currency?: EnumCurrencyCodeFilter<"Transaction"> | $Enums.CurrencyCode
    gatewayResponse?: JsonNullableFilter<"Transaction">
    timestamp?: DateTimeFilter<"Transaction"> | Date | string
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    Payment?: XOR<PaymentScalarRelationFilter, PaymentWhereInput>
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    paymentId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    gatewayResponse?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    status?: SortOrder
    Payment?: PaymentOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    paymentId?: StringFilter<"Transaction"> | string
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    amount?: FloatFilter<"Transaction"> | number
    currency?: EnumCurrencyCodeFilter<"Transaction"> | $Enums.CurrencyCode
    gatewayResponse?: JsonNullableFilter<"Transaction">
    timestamp?: DateTimeFilter<"Transaction"> | Date | string
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    Payment?: XOR<PaymentScalarRelationFilter, PaymentWhereInput>
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    paymentId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    gatewayResponse?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    status?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    paymentId?: StringWithAggregatesFilter<"Transaction"> | string
    type?: EnumTransactionTypeWithAggregatesFilter<"Transaction"> | $Enums.TransactionType
    amount?: FloatWithAggregatesFilter<"Transaction"> | number
    currency?: EnumCurrencyCodeWithAggregatesFilter<"Transaction"> | $Enums.CurrencyCode
    gatewayResponse?: JsonNullableWithAggregatesFilter<"Transaction">
    timestamp?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    status?: EnumTransactionStatusWithAggregatesFilter<"Transaction"> | $Enums.TransactionStatus
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: IntFilter<"Review"> | number
    bookingId?: IntFilter<"Review"> | number
    userId?: IntFilter<"Review"> | number
    rating?: IntFilter<"Review"> | number
    title?: StringNullableFilter<"Review"> | string | null
    comment?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    hotelId?: IntNullableFilter<"Review"> | number | null
    Booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    Hotel?: XOR<HotelNullableScalarRelationFilter, HotelWhereInput> | null
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    title?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelId?: SortOrderInput | SortOrder
    Booking?: BookingOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
    Hotel?: HotelOrderByWithRelationInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    bookingId?: number
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    userId?: IntFilter<"Review"> | number
    rating?: IntFilter<"Review"> | number
    title?: StringNullableFilter<"Review"> | string | null
    comment?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    hotelId?: IntNullableFilter<"Review"> | number | null
    Booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    Hotel?: XOR<HotelNullableScalarRelationFilter, HotelWhereInput> | null
  }, "id" | "bookingId">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    title?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelId?: SortOrderInput | SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Review"> | number
    bookingId?: IntWithAggregatesFilter<"Review"> | number
    userId?: IntWithAggregatesFilter<"Review"> | number
    rating?: IntWithAggregatesFilter<"Review"> | number
    title?: StringNullableWithAggregatesFilter<"Review"> | string | null
    comment?: StringNullableWithAggregatesFilter<"Review"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    hotelId?: IntNullableWithAggregatesFilter<"Review"> | number | null
  }

  export type PromotionWhereInput = {
    AND?: PromotionWhereInput | PromotionWhereInput[]
    OR?: PromotionWhereInput[]
    NOT?: PromotionWhereInput | PromotionWhereInput[]
    id?: IntFilter<"Promotion"> | number
    code?: StringFilter<"Promotion"> | string
    description?: StringNullableFilter<"Promotion"> | string | null
    discountType?: EnumDiscountTypeFilter<"Promotion"> | $Enums.DiscountType
    discountValue?: FloatFilter<"Promotion"> | number
    validFrom?: DateTimeNullableFilter<"Promotion"> | Date | string | null
    validUntil?: DateTimeNullableFilter<"Promotion"> | Date | string | null
    maxUses?: IntNullableFilter<"Promotion"> | number | null
    usesPerUser?: IntNullableFilter<"Promotion"> | number | null
    currentUses?: IntFilter<"Promotion"> | number
    minNights?: IntNullableFilter<"Promotion"> | number | null
    minAmount?: FloatNullableFilter<"Promotion"> | number | null
    isActive?: BoolFilter<"Promotion"> | boolean
    createdAt?: DateTimeFilter<"Promotion"> | Date | string
    updatedAt?: DateTimeFilter<"Promotion"> | Date | string
    bookings?: BookingListRelationFilter
    PromotionHotel?: PromotionHotelListRelationFilter
    PromotionRoomType?: PromotionRoomTypeListRelationFilter
  }

  export type PromotionOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    validFrom?: SortOrderInput | SortOrder
    validUntil?: SortOrderInput | SortOrder
    maxUses?: SortOrderInput | SortOrder
    usesPerUser?: SortOrderInput | SortOrder
    currentUses?: SortOrder
    minNights?: SortOrderInput | SortOrder
    minAmount?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bookings?: BookingOrderByRelationAggregateInput
    PromotionHotel?: PromotionHotelOrderByRelationAggregateInput
    PromotionRoomType?: PromotionRoomTypeOrderByRelationAggregateInput
  }

  export type PromotionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: PromotionWhereInput | PromotionWhereInput[]
    OR?: PromotionWhereInput[]
    NOT?: PromotionWhereInput | PromotionWhereInput[]
    description?: StringNullableFilter<"Promotion"> | string | null
    discountType?: EnumDiscountTypeFilter<"Promotion"> | $Enums.DiscountType
    discountValue?: FloatFilter<"Promotion"> | number
    validFrom?: DateTimeNullableFilter<"Promotion"> | Date | string | null
    validUntil?: DateTimeNullableFilter<"Promotion"> | Date | string | null
    maxUses?: IntNullableFilter<"Promotion"> | number | null
    usesPerUser?: IntNullableFilter<"Promotion"> | number | null
    currentUses?: IntFilter<"Promotion"> | number
    minNights?: IntNullableFilter<"Promotion"> | number | null
    minAmount?: FloatNullableFilter<"Promotion"> | number | null
    isActive?: BoolFilter<"Promotion"> | boolean
    createdAt?: DateTimeFilter<"Promotion"> | Date | string
    updatedAt?: DateTimeFilter<"Promotion"> | Date | string
    bookings?: BookingListRelationFilter
    PromotionHotel?: PromotionHotelListRelationFilter
    PromotionRoomType?: PromotionRoomTypeListRelationFilter
  }, "id" | "code">

  export type PromotionOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    validFrom?: SortOrderInput | SortOrder
    validUntil?: SortOrderInput | SortOrder
    maxUses?: SortOrderInput | SortOrder
    usesPerUser?: SortOrderInput | SortOrder
    currentUses?: SortOrder
    minNights?: SortOrderInput | SortOrder
    minAmount?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PromotionCountOrderByAggregateInput
    _avg?: PromotionAvgOrderByAggregateInput
    _max?: PromotionMaxOrderByAggregateInput
    _min?: PromotionMinOrderByAggregateInput
    _sum?: PromotionSumOrderByAggregateInput
  }

  export type PromotionScalarWhereWithAggregatesInput = {
    AND?: PromotionScalarWhereWithAggregatesInput | PromotionScalarWhereWithAggregatesInput[]
    OR?: PromotionScalarWhereWithAggregatesInput[]
    NOT?: PromotionScalarWhereWithAggregatesInput | PromotionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Promotion"> | number
    code?: StringWithAggregatesFilter<"Promotion"> | string
    description?: StringNullableWithAggregatesFilter<"Promotion"> | string | null
    discountType?: EnumDiscountTypeWithAggregatesFilter<"Promotion"> | $Enums.DiscountType
    discountValue?: FloatWithAggregatesFilter<"Promotion"> | number
    validFrom?: DateTimeNullableWithAggregatesFilter<"Promotion"> | Date | string | null
    validUntil?: DateTimeNullableWithAggregatesFilter<"Promotion"> | Date | string | null
    maxUses?: IntNullableWithAggregatesFilter<"Promotion"> | number | null
    usesPerUser?: IntNullableWithAggregatesFilter<"Promotion"> | number | null
    currentUses?: IntWithAggregatesFilter<"Promotion"> | number
    minNights?: IntNullableWithAggregatesFilter<"Promotion"> | number | null
    minAmount?: FloatNullableWithAggregatesFilter<"Promotion"> | number | null
    isActive?: BoolWithAggregatesFilter<"Promotion"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Promotion"> | Date | string
  }

  export type CancellationPolicyWhereInput = {
    AND?: CancellationPolicyWhereInput | CancellationPolicyWhereInput[]
    OR?: CancellationPolicyWhereInput[]
    NOT?: CancellationPolicyWhereInput | CancellationPolicyWhereInput[]
    id?: IntFilter<"CancellationPolicy"> | number
    name?: StringFilter<"CancellationPolicy"> | string
    description?: StringNullableFilter<"CancellationPolicy"> | string | null
    rules?: JsonNullableFilter<"CancellationPolicy">
    createdAt?: DateTimeFilter<"CancellationPolicy"> | Date | string
    updatedAt?: DateTimeFilter<"CancellationPolicy"> | Date | string
    hotelId?: IntNullableFilter<"CancellationPolicy"> | number | null
    bookings?: BookingListRelationFilter
    Hotel?: XOR<HotelNullableScalarRelationFilter, HotelWhereInput> | null
  }

  export type CancellationPolicyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    rules?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelId?: SortOrderInput | SortOrder
    bookings?: BookingOrderByRelationAggregateInput
    Hotel?: HotelOrderByWithRelationInput
  }

  export type CancellationPolicyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CancellationPolicyWhereInput | CancellationPolicyWhereInput[]
    OR?: CancellationPolicyWhereInput[]
    NOT?: CancellationPolicyWhereInput | CancellationPolicyWhereInput[]
    name?: StringFilter<"CancellationPolicy"> | string
    description?: StringNullableFilter<"CancellationPolicy"> | string | null
    rules?: JsonNullableFilter<"CancellationPolicy">
    createdAt?: DateTimeFilter<"CancellationPolicy"> | Date | string
    updatedAt?: DateTimeFilter<"CancellationPolicy"> | Date | string
    hotelId?: IntNullableFilter<"CancellationPolicy"> | number | null
    bookings?: BookingListRelationFilter
    Hotel?: XOR<HotelNullableScalarRelationFilter, HotelWhereInput> | null
  }, "id">

  export type CancellationPolicyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    rules?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelId?: SortOrderInput | SortOrder
    _count?: CancellationPolicyCountOrderByAggregateInput
    _avg?: CancellationPolicyAvgOrderByAggregateInput
    _max?: CancellationPolicyMaxOrderByAggregateInput
    _min?: CancellationPolicyMinOrderByAggregateInput
    _sum?: CancellationPolicySumOrderByAggregateInput
  }

  export type CancellationPolicyScalarWhereWithAggregatesInput = {
    AND?: CancellationPolicyScalarWhereWithAggregatesInput | CancellationPolicyScalarWhereWithAggregatesInput[]
    OR?: CancellationPolicyScalarWhereWithAggregatesInput[]
    NOT?: CancellationPolicyScalarWhereWithAggregatesInput | CancellationPolicyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CancellationPolicy"> | number
    name?: StringWithAggregatesFilter<"CancellationPolicy"> | string
    description?: StringNullableWithAggregatesFilter<"CancellationPolicy"> | string | null
    rules?: JsonNullableWithAggregatesFilter<"CancellationPolicy">
    createdAt?: DateTimeWithAggregatesFilter<"CancellationPolicy"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CancellationPolicy"> | Date | string
    hotelId?: IntNullableWithAggregatesFilter<"CancellationPolicy"> | number | null
  }

  export type CancellationWhereInput = {
    AND?: CancellationWhereInput | CancellationWhereInput[]
    OR?: CancellationWhereInput[]
    NOT?: CancellationWhereInput | CancellationWhereInput[]
    id?: IntFilter<"Cancellation"> | number
    bookingId?: IntFilter<"Cancellation"> | number
    reason?: StringNullableFilter<"Cancellation"> | string | null
    cancelledAt?: DateTimeFilter<"Cancellation"> | Date | string
    processedByUserId?: IntNullableFilter<"Cancellation"> | number | null
    refundAmount?: FloatNullableFilter<"Cancellation"> | number | null
    refundStatus?: StringNullableFilter<"Cancellation"> | string | null
    notes?: StringNullableFilter<"Cancellation"> | string | null
    Booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type CancellationOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    reason?: SortOrderInput | SortOrder
    cancelledAt?: SortOrder
    processedByUserId?: SortOrderInput | SortOrder
    refundAmount?: SortOrderInput | SortOrder
    refundStatus?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    Booking?: BookingOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type CancellationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    bookingId?: number
    AND?: CancellationWhereInput | CancellationWhereInput[]
    OR?: CancellationWhereInput[]
    NOT?: CancellationWhereInput | CancellationWhereInput[]
    reason?: StringNullableFilter<"Cancellation"> | string | null
    cancelledAt?: DateTimeFilter<"Cancellation"> | Date | string
    processedByUserId?: IntNullableFilter<"Cancellation"> | number | null
    refundAmount?: FloatNullableFilter<"Cancellation"> | number | null
    refundStatus?: StringNullableFilter<"Cancellation"> | string | null
    notes?: StringNullableFilter<"Cancellation"> | string | null
    Booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "bookingId">

  export type CancellationOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    reason?: SortOrderInput | SortOrder
    cancelledAt?: SortOrder
    processedByUserId?: SortOrderInput | SortOrder
    refundAmount?: SortOrderInput | SortOrder
    refundStatus?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: CancellationCountOrderByAggregateInput
    _avg?: CancellationAvgOrderByAggregateInput
    _max?: CancellationMaxOrderByAggregateInput
    _min?: CancellationMinOrderByAggregateInput
    _sum?: CancellationSumOrderByAggregateInput
  }

  export type CancellationScalarWhereWithAggregatesInput = {
    AND?: CancellationScalarWhereWithAggregatesInput | CancellationScalarWhereWithAggregatesInput[]
    OR?: CancellationScalarWhereWithAggregatesInput[]
    NOT?: CancellationScalarWhereWithAggregatesInput | CancellationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Cancellation"> | number
    bookingId?: IntWithAggregatesFilter<"Cancellation"> | number
    reason?: StringNullableWithAggregatesFilter<"Cancellation"> | string | null
    cancelledAt?: DateTimeWithAggregatesFilter<"Cancellation"> | Date | string
    processedByUserId?: IntNullableWithAggregatesFilter<"Cancellation"> | number | null
    refundAmount?: FloatNullableWithAggregatesFilter<"Cancellation"> | number | null
    refundStatus?: StringNullableWithAggregatesFilter<"Cancellation"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Cancellation"> | string | null
  }

  export type PromotionHotelWhereInput = {
    AND?: PromotionHotelWhereInput | PromotionHotelWhereInput[]
    OR?: PromotionHotelWhereInput[]
    NOT?: PromotionHotelWhereInput | PromotionHotelWhereInput[]
    id?: IntFilter<"PromotionHotel"> | number
    promotionId?: IntFilter<"PromotionHotel"> | number
    hotelId?: IntFilter<"PromotionHotel"> | number
    createdAt?: DateTimeFilter<"PromotionHotel"> | Date | string
    Promotion?: XOR<PromotionScalarRelationFilter, PromotionWhereInput>
    Hotel?: XOR<HotelScalarRelationFilter, HotelWhereInput>
  }

  export type PromotionHotelOrderByWithRelationInput = {
    id?: SortOrder
    promotionId?: SortOrder
    hotelId?: SortOrder
    createdAt?: SortOrder
    Promotion?: PromotionOrderByWithRelationInput
    Hotel?: HotelOrderByWithRelationInput
  }

  export type PromotionHotelWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    promotionId_hotelId?: PromotionHotelPromotionIdHotelIdCompoundUniqueInput
    AND?: PromotionHotelWhereInput | PromotionHotelWhereInput[]
    OR?: PromotionHotelWhereInput[]
    NOT?: PromotionHotelWhereInput | PromotionHotelWhereInput[]
    promotionId?: IntFilter<"PromotionHotel"> | number
    hotelId?: IntFilter<"PromotionHotel"> | number
    createdAt?: DateTimeFilter<"PromotionHotel"> | Date | string
    Promotion?: XOR<PromotionScalarRelationFilter, PromotionWhereInput>
    Hotel?: XOR<HotelScalarRelationFilter, HotelWhereInput>
  }, "id" | "promotionId_hotelId">

  export type PromotionHotelOrderByWithAggregationInput = {
    id?: SortOrder
    promotionId?: SortOrder
    hotelId?: SortOrder
    createdAt?: SortOrder
    _count?: PromotionHotelCountOrderByAggregateInput
    _avg?: PromotionHotelAvgOrderByAggregateInput
    _max?: PromotionHotelMaxOrderByAggregateInput
    _min?: PromotionHotelMinOrderByAggregateInput
    _sum?: PromotionHotelSumOrderByAggregateInput
  }

  export type PromotionHotelScalarWhereWithAggregatesInput = {
    AND?: PromotionHotelScalarWhereWithAggregatesInput | PromotionHotelScalarWhereWithAggregatesInput[]
    OR?: PromotionHotelScalarWhereWithAggregatesInput[]
    NOT?: PromotionHotelScalarWhereWithAggregatesInput | PromotionHotelScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PromotionHotel"> | number
    promotionId?: IntWithAggregatesFilter<"PromotionHotel"> | number
    hotelId?: IntWithAggregatesFilter<"PromotionHotel"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PromotionHotel"> | Date | string
  }

  export type PromotionRoomTypeWhereInput = {
    AND?: PromotionRoomTypeWhereInput | PromotionRoomTypeWhereInput[]
    OR?: PromotionRoomTypeWhereInput[]
    NOT?: PromotionRoomTypeWhereInput | PromotionRoomTypeWhereInput[]
    id?: IntFilter<"PromotionRoomType"> | number
    promotionId?: IntFilter<"PromotionRoomType"> | number
    roomTypeId?: IntFilter<"PromotionRoomType"> | number
    createdAt?: DateTimeFilter<"PromotionRoomType"> | Date | string
    Promotion?: XOR<PromotionScalarRelationFilter, PromotionWhereInput>
    RoomType?: XOR<RoomTypeScalarRelationFilter, RoomTypeWhereInput>
  }

  export type PromotionRoomTypeOrderByWithRelationInput = {
    id?: SortOrder
    promotionId?: SortOrder
    roomTypeId?: SortOrder
    createdAt?: SortOrder
    Promotion?: PromotionOrderByWithRelationInput
    RoomType?: RoomTypeOrderByWithRelationInput
  }

  export type PromotionRoomTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    promotionId_roomTypeId?: PromotionRoomTypePromotionIdRoomTypeIdCompoundUniqueInput
    AND?: PromotionRoomTypeWhereInput | PromotionRoomTypeWhereInput[]
    OR?: PromotionRoomTypeWhereInput[]
    NOT?: PromotionRoomTypeWhereInput | PromotionRoomTypeWhereInput[]
    promotionId?: IntFilter<"PromotionRoomType"> | number
    roomTypeId?: IntFilter<"PromotionRoomType"> | number
    createdAt?: DateTimeFilter<"PromotionRoomType"> | Date | string
    Promotion?: XOR<PromotionScalarRelationFilter, PromotionWhereInput>
    RoomType?: XOR<RoomTypeScalarRelationFilter, RoomTypeWhereInput>
  }, "id" | "promotionId_roomTypeId">

  export type PromotionRoomTypeOrderByWithAggregationInput = {
    id?: SortOrder
    promotionId?: SortOrder
    roomTypeId?: SortOrder
    createdAt?: SortOrder
    _count?: PromotionRoomTypeCountOrderByAggregateInput
    _avg?: PromotionRoomTypeAvgOrderByAggregateInput
    _max?: PromotionRoomTypeMaxOrderByAggregateInput
    _min?: PromotionRoomTypeMinOrderByAggregateInput
    _sum?: PromotionRoomTypeSumOrderByAggregateInput
  }

  export type PromotionRoomTypeScalarWhereWithAggregatesInput = {
    AND?: PromotionRoomTypeScalarWhereWithAggregatesInput | PromotionRoomTypeScalarWhereWithAggregatesInput[]
    OR?: PromotionRoomTypeScalarWhereWithAggregatesInput[]
    NOT?: PromotionRoomTypeScalarWhereWithAggregatesInput | PromotionRoomTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PromotionRoomType"> | number
    promotionId?: IntWithAggregatesFilter<"PromotionRoomType"> | number
    roomTypeId?: IntWithAggregatesFilter<"PromotionRoomType"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PromotionRoomType"> | Date | string
  }

  export type HotelCreateInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Address?: AddressCreateNestedOneWithoutHotelInput
    images?: ImageCreateNestedManyWithoutHotelInput
    amenities?: HotelAmenityCreateNestedManyWithoutHotelInput
    roomTypes?: RoomTypeCreateNestedManyWithoutHotelInput
    rooms?: RoomCreateNestedManyWithoutHotelInput
    bookings?: BookingCreateNestedManyWithoutHotelInput
    reviews?: ReviewCreateNestedManyWithoutHotelInput
    inventory?: RoomInventoryCreateNestedManyWithoutHotelInput
    prices?: RoomPriceCreateNestedManyWithoutHotelInput
    policies?: CancellationPolicyCreateNestedManyWithoutHotelInput
    PromotionHotel?: PromotionHotelCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    addressId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ImageUncheckedCreateNestedManyWithoutHotelInput
    amenities?: HotelAmenityUncheckedCreateNestedManyWithoutHotelInput
    roomTypes?: RoomTypeUncheckedCreateNestedManyWithoutHotelInput
    rooms?: RoomUncheckedCreateNestedManyWithoutHotelInput
    bookings?: BookingUncheckedCreateNestedManyWithoutHotelInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutHotelInput
    inventory?: RoomInventoryUncheckedCreateNestedManyWithoutHotelInput
    prices?: RoomPriceUncheckedCreateNestedManyWithoutHotelInput
    policies?: CancellationPolicyUncheckedCreateNestedManyWithoutHotelInput
    PromotionHotel?: PromotionHotelUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Address?: AddressUpdateOneWithoutHotelNestedInput
    images?: ImageUpdateManyWithoutHotelNestedInput
    amenities?: HotelAmenityUpdateManyWithoutHotelNestedInput
    roomTypes?: RoomTypeUpdateManyWithoutHotelNestedInput
    rooms?: RoomUpdateManyWithoutHotelNestedInput
    bookings?: BookingUpdateManyWithoutHotelNestedInput
    reviews?: ReviewUpdateManyWithoutHotelNestedInput
    inventory?: RoomInventoryUpdateManyWithoutHotelNestedInput
    prices?: RoomPriceUpdateManyWithoutHotelNestedInput
    policies?: CancellationPolicyUpdateManyWithoutHotelNestedInput
    PromotionHotel?: PromotionHotelUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ImageUncheckedUpdateManyWithoutHotelNestedInput
    amenities?: HotelAmenityUncheckedUpdateManyWithoutHotelNestedInput
    roomTypes?: RoomTypeUncheckedUpdateManyWithoutHotelNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutHotelNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutHotelNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutHotelNestedInput
    inventory?: RoomInventoryUncheckedUpdateManyWithoutHotelNestedInput
    prices?: RoomPriceUncheckedUpdateManyWithoutHotelNestedInput
    policies?: CancellationPolicyUncheckedUpdateManyWithoutHotelNestedInput
    PromotionHotel?: PromotionHotelUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type HotelCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    addressId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HotelUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCreateInput = {
    streetAddress: string
    city: string
    stateProvince?: string | null
    postalCode: string
    countryCode: string
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hotel?: HotelCreateNestedOneWithoutAddressInput
  }

  export type AddressUncheckedCreateInput = {
    id?: number
    streetAddress: string
    city: string
    stateProvince?: string | null
    postalCode: string
    countryCode: string
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hotel?: HotelUncheckedCreateNestedOneWithoutAddressInput
  }

  export type AddressUpdateInput = {
    streetAddress?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    stateProvince?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotel?: HotelUpdateOneWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    streetAddress?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    stateProvince?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotel?: HotelUncheckedUpdateOneWithoutAddressNestedInput
  }

  export type AddressCreateManyInput = {
    id?: number
    streetAddress: string
    city: string
    stateProvince?: string | null
    postalCode: string
    countryCode: string
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUpdateManyMutationInput = {
    streetAddress?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    stateProvince?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    streetAddress?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    stateProvince?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageCreateInput = {
    url: string
    altText?: string | null
    order?: number | null
    createdAt?: Date | string
    Hotel?: HotelCreateNestedOneWithoutImagesInput
    RoomType?: RoomTypeCreateNestedOneWithoutImagesInput
  }

  export type ImageUncheckedCreateInput = {
    id?: number
    url: string
    altText?: string | null
    order?: number | null
    hotelId?: number | null
    roomTypeId?: number | null
    createdAt?: Date | string
  }

  export type ImageUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Hotel?: HotelUpdateOneWithoutImagesNestedInput
    RoomType?: RoomTypeUpdateOneWithoutImagesNestedInput
  }

  export type ImageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageCreateManyInput = {
    id?: number
    url: string
    altText?: string | null
    order?: number | null
    hotelId?: number | null
    roomTypeId?: number | null
    createdAt?: Date | string
  }

  export type ImageUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenityCreateInput = {
    name: string
    description?: string | null
    category?: string | null
    createdAt?: Date | string
    hotels?: HotelAmenityCreateNestedManyWithoutAmenityInput
    roomTypes?: RoomTypeAmenityCreateNestedManyWithoutAmenityInput
  }

  export type AmenityUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    category?: string | null
    createdAt?: Date | string
    hotels?: HotelAmenityUncheckedCreateNestedManyWithoutAmenityInput
    roomTypes?: RoomTypeAmenityUncheckedCreateNestedManyWithoutAmenityInput
  }

  export type AmenityUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotels?: HotelAmenityUpdateManyWithoutAmenityNestedInput
    roomTypes?: RoomTypeAmenityUpdateManyWithoutAmenityNestedInput
  }

  export type AmenityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotels?: HotelAmenityUncheckedUpdateManyWithoutAmenityNestedInput
    roomTypes?: RoomTypeAmenityUncheckedUpdateManyWithoutAmenityNestedInput
  }

  export type AmenityCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    category?: string | null
    createdAt?: Date | string
  }

  export type AmenityUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelAmenityCreateInput = {
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    Hotel: HotelCreateNestedOneWithoutAmenitiesInput
    Amenity: AmenityCreateNestedOneWithoutHotelsInput
  }

  export type HotelAmenityUncheckedCreateInput = {
    hotelId: number
    amenityId: number
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type HotelAmenityUpdateInput = {
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Hotel?: HotelUpdateOneRequiredWithoutAmenitiesNestedInput
    Amenity?: AmenityUpdateOneRequiredWithoutHotelsNestedInput
  }

  export type HotelAmenityUncheckedUpdateInput = {
    hotelId?: IntFieldUpdateOperationsInput | number
    amenityId?: IntFieldUpdateOperationsInput | number
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelAmenityCreateManyInput = {
    hotelId: number
    amenityId: number
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type HotelAmenityUpdateManyMutationInput = {
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelAmenityUncheckedUpdateManyInput = {
    hotelId?: IntFieldUpdateOperationsInput | number
    amenityId?: IntFieldUpdateOperationsInput | number
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomTypeCreateInput = {
    name: string
    description?: string | null
    maxGuests: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Hotel: HotelCreateNestedOneWithoutRoomTypesInput
    images?: ImageCreateNestedManyWithoutRoomTypeInput
    amenities?: RoomTypeAmenityCreateNestedManyWithoutRoomTypeInput
    rooms?: RoomCreateNestedManyWithoutRoomTypeInput
    inventory?: RoomInventoryCreateNestedManyWithoutRoomTypeInput
    prices?: RoomPriceCreateNestedManyWithoutRoomTypeInput
    bookings?: BookingCreateNestedManyWithoutRoomTypeInput
    PromotionRoomType?: PromotionRoomTypeCreateNestedManyWithoutRoomTypeInput
  }

  export type RoomTypeUncheckedCreateInput = {
    id?: number
    hotelId: number
    name: string
    description?: string | null
    maxGuests: number
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ImageUncheckedCreateNestedManyWithoutRoomTypeInput
    amenities?: RoomTypeAmenityUncheckedCreateNestedManyWithoutRoomTypeInput
    rooms?: RoomUncheckedCreateNestedManyWithoutRoomTypeInput
    inventory?: RoomInventoryUncheckedCreateNestedManyWithoutRoomTypeInput
    prices?: RoomPriceUncheckedCreateNestedManyWithoutRoomTypeInput
    bookings?: BookingUncheckedCreateNestedManyWithoutRoomTypeInput
    PromotionRoomType?: PromotionRoomTypeUncheckedCreateNestedManyWithoutRoomTypeInput
  }

  export type RoomTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Hotel?: HotelUpdateOneRequiredWithoutRoomTypesNestedInput
    images?: ImageUpdateManyWithoutRoomTypeNestedInput
    amenities?: RoomTypeAmenityUpdateManyWithoutRoomTypeNestedInput
    rooms?: RoomUpdateManyWithoutRoomTypeNestedInput
    inventory?: RoomInventoryUpdateManyWithoutRoomTypeNestedInput
    prices?: RoomPriceUpdateManyWithoutRoomTypeNestedInput
    bookings?: BookingUpdateManyWithoutRoomTypeNestedInput
    PromotionRoomType?: PromotionRoomTypeUpdateManyWithoutRoomTypeNestedInput
  }

  export type RoomTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ImageUncheckedUpdateManyWithoutRoomTypeNestedInput
    amenities?: RoomTypeAmenityUncheckedUpdateManyWithoutRoomTypeNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutRoomTypeNestedInput
    inventory?: RoomInventoryUncheckedUpdateManyWithoutRoomTypeNestedInput
    prices?: RoomPriceUncheckedUpdateManyWithoutRoomTypeNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutRoomTypeNestedInput
    PromotionRoomType?: PromotionRoomTypeUncheckedUpdateManyWithoutRoomTypeNestedInput
  }

  export type RoomTypeCreateManyInput = {
    id?: number
    hotelId: number
    name: string
    description?: string | null
    maxGuests: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomTypeAmenityCreateInput = {
    createdAt?: Date | string
    RoomType: RoomTypeCreateNestedOneWithoutAmenitiesInput
    Amenity: AmenityCreateNestedOneWithoutRoomTypesInput
  }

  export type RoomTypeAmenityUncheckedCreateInput = {
    roomTypeId: number
    amenityId: number
    createdAt?: Date | string
  }

  export type RoomTypeAmenityUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RoomType?: RoomTypeUpdateOneRequiredWithoutAmenitiesNestedInput
    Amenity?: AmenityUpdateOneRequiredWithoutRoomTypesNestedInput
  }

  export type RoomTypeAmenityUncheckedUpdateInput = {
    roomTypeId?: IntFieldUpdateOperationsInput | number
    amenityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomTypeAmenityCreateManyInput = {
    roomTypeId: number
    amenityId: number
    createdAt?: Date | string
  }

  export type RoomTypeAmenityUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomTypeAmenityUncheckedUpdateManyInput = {
    roomTypeId?: IntFieldUpdateOperationsInput | number
    amenityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomCreateInput = {
    roomNumber: string
    floor?: string | null
    status?: $Enums.RoomStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    RoomType: RoomTypeCreateNestedOneWithoutRoomsInput
    Hotel?: HotelCreateNestedOneWithoutRoomsInput
  }

  export type RoomUncheckedCreateInput = {
    id?: number
    roomTypeId: number
    roomNumber: string
    floor?: string | null
    status?: $Enums.RoomStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelId?: number | null
  }

  export type RoomUpdateInput = {
    roomNumber?: StringFieldUpdateOperationsInput | string
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RoomType?: RoomTypeUpdateOneRequiredWithoutRoomsNestedInput
    Hotel?: HotelUpdateOneWithoutRoomsNestedInput
  }

  export type RoomUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomTypeId?: IntFieldUpdateOperationsInput | number
    roomNumber?: StringFieldUpdateOperationsInput | string
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RoomCreateManyInput = {
    id?: number
    roomTypeId: number
    roomNumber: string
    floor?: string | null
    status?: $Enums.RoomStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelId?: number | null
  }

  export type RoomUpdateManyMutationInput = {
    roomNumber?: StringFieldUpdateOperationsInput | string
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomTypeId?: IntFieldUpdateOperationsInput | number
    roomNumber?: StringFieldUpdateOperationsInput | string
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RoomInventoryCreateInput = {
    date: Date | string
    totalInventory: number
    bookedCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    RoomType: RoomTypeCreateNestedOneWithoutInventoryInput
    Hotel?: HotelCreateNestedOneWithoutInventoryInput
  }

  export type RoomInventoryUncheckedCreateInput = {
    id?: number
    roomTypeId: number
    date: Date | string
    totalInventory: number
    bookedCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelId?: number | null
  }

  export type RoomInventoryUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalInventory?: IntFieldUpdateOperationsInput | number
    bookedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RoomType?: RoomTypeUpdateOneRequiredWithoutInventoryNestedInput
    Hotel?: HotelUpdateOneWithoutInventoryNestedInput
  }

  export type RoomInventoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomTypeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalInventory?: IntFieldUpdateOperationsInput | number
    bookedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RoomInventoryCreateManyInput = {
    id?: number
    roomTypeId: number
    date: Date | string
    totalInventory: number
    bookedCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelId?: number | null
  }

  export type RoomInventoryUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalInventory?: IntFieldUpdateOperationsInput | number
    bookedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomInventoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomTypeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalInventory?: IntFieldUpdateOperationsInput | number
    bookedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RoomPriceCreateInput = {
    date: Date | string
    price: number
    currency?: $Enums.CurrencyCode
    priceType?: $Enums.PriceType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    RoomType: RoomTypeCreateNestedOneWithoutPricesInput
    Hotel?: HotelCreateNestedOneWithoutPricesInput
  }

  export type RoomPriceUncheckedCreateInput = {
    id?: number
    roomTypeId: number
    date: Date | string
    price: number
    currency?: $Enums.CurrencyCode
    priceType?: $Enums.PriceType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelId?: number | null
  }

  export type RoomPriceUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    priceType?: NullableEnumPriceTypeFieldUpdateOperationsInput | $Enums.PriceType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RoomType?: RoomTypeUpdateOneRequiredWithoutPricesNestedInput
    Hotel?: HotelUpdateOneWithoutPricesNestedInput
  }

  export type RoomPriceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomTypeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    priceType?: NullableEnumPriceTypeFieldUpdateOperationsInput | $Enums.PriceType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RoomPriceCreateManyInput = {
    id?: number
    roomTypeId: number
    date: Date | string
    price: number
    currency?: $Enums.CurrencyCode
    priceType?: $Enums.PriceType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelId?: number | null
  }

  export type RoomPriceUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    priceType?: NullableEnumPriceTypeFieldUpdateOperationsInput | $Enums.PriceType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomPriceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomTypeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    priceType?: NullableEnumPriceTypeFieldUpdateOperationsInput | $Enums.PriceType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserCreateInput = {
    username: string
    email?: string | null
    password?: string | null
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Role: RoleCreateNestedOneWithoutUsersInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    cancellations?: CancellationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    username: string
    email?: string | null
    password?: string | null
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    roleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    cancellations?: CancellationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    cancellations?: CancellationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    cancellations?: CancellationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    username: string
    email?: string | null
    password?: string | null
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    roleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateInput = {
    numberOfRooms?: number
    checkIn: Date | string
    checkOut: Date | string
    totalAmount?: number | null
    currency?: $Enums.CurrencyCode
    status?: $Enums.BookingStatus
    guestName?: string | null
    guestSurname?: string | null
    guestEmail?: string | null
    guestPhone?: string | null
    guestIdentity?: string | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    User?: UserCreateNestedOneWithoutBookingsInput
    RoomType: RoomTypeCreateNestedOneWithoutBookingsInput
    payment?: PaymentCreateNestedOneWithoutBookingInput
    review?: ReviewCreateNestedOneWithoutBookingInput
    Promotion?: PromotionCreateNestedOneWithoutBookingsInput
    CancellationPolicy?: CancellationPolicyCreateNestedOneWithoutBookingsInput
    cancellation?: CancellationCreateNestedOneWithoutBookingInput
    Hotel?: HotelCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateInput = {
    id?: number
    userId?: number | null
    roomTypeId: number
    numberOfRooms?: number
    checkIn: Date | string
    checkOut: Date | string
    totalAmount?: number | null
    currency?: $Enums.CurrencyCode
    status?: $Enums.BookingStatus
    guestName?: string | null
    guestSurname?: string | null
    guestEmail?: string | null
    guestPhone?: string | null
    guestIdentity?: string | null
    promotionId?: number | null
    cancellationPolicyId?: number | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelId?: number | null
    payment?: PaymentUncheckedCreateNestedOneWithoutBookingInput
    review?: ReviewUncheckedCreateNestedOneWithoutBookingInput
    cancellation?: CancellationUncheckedCreateNestedOneWithoutBookingInput
  }

  export type BookingUpdateInput = {
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestSurname?: NullableStringFieldUpdateOperationsInput | string | null
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestIdentity?: NullableStringFieldUpdateOperationsInput | string | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneWithoutBookingsNestedInput
    RoomType?: RoomTypeUpdateOneRequiredWithoutBookingsNestedInput
    payment?: PaymentUpdateOneWithoutBookingNestedInput
    review?: ReviewUpdateOneWithoutBookingNestedInput
    Promotion?: PromotionUpdateOneWithoutBookingsNestedInput
    CancellationPolicy?: CancellationPolicyUpdateOneWithoutBookingsNestedInput
    cancellation?: CancellationUpdateOneWithoutBookingNestedInput
    Hotel?: HotelUpdateOneWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypeId?: IntFieldUpdateOperationsInput | number
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestSurname?: NullableStringFieldUpdateOperationsInput | string | null
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestIdentity?: NullableStringFieldUpdateOperationsInput | string | null
    promotionId?: NullableIntFieldUpdateOperationsInput | number | null
    cancellationPolicyId?: NullableIntFieldUpdateOperationsInput | number | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
    payment?: PaymentUncheckedUpdateOneWithoutBookingNestedInput
    review?: ReviewUncheckedUpdateOneWithoutBookingNestedInput
    cancellation?: CancellationUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type BookingCreateManyInput = {
    id?: number
    userId?: number | null
    roomTypeId: number
    numberOfRooms?: number
    checkIn: Date | string
    checkOut: Date | string
    totalAmount?: number | null
    currency?: $Enums.CurrencyCode
    status?: $Enums.BookingStatus
    guestName?: string | null
    guestSurname?: string | null
    guestEmail?: string | null
    guestPhone?: string | null
    guestIdentity?: string | null
    promotionId?: number | null
    cancellationPolicyId?: number | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelId?: number | null
  }

  export type BookingUpdateManyMutationInput = {
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestSurname?: NullableStringFieldUpdateOperationsInput | string | null
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestIdentity?: NullableStringFieldUpdateOperationsInput | string | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypeId?: IntFieldUpdateOperationsInput | number
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestSurname?: NullableStringFieldUpdateOperationsInput | string | null
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestIdentity?: NullableStringFieldUpdateOperationsInput | string | null
    promotionId?: NullableIntFieldUpdateOperationsInput | number | null
    cancellationPolicyId?: NullableIntFieldUpdateOperationsInput | number | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PaymentCreateInput = {
    id?: string
    amount: number
    currency?: $Enums.CurrencyCode
    paymentMethod?: $Enums.PaymentMethod | null
    paymentGatewayId?: string | null
    status?: $Enums.PaymentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Booking: BookingCreateNestedOneWithoutPaymentInput
    transactions?: TransactionCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    bookingId: number
    amount: number
    currency?: $Enums.CurrencyCode
    paymentMethod?: $Enums.PaymentMethod | null
    paymentGatewayId?: string | null
    status?: $Enums.PaymentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    paymentGatewayId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Booking?: BookingUpdateOneRequiredWithoutPaymentNestedInput
    transactions?: TransactionUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    paymentGatewayId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentCreateManyInput = {
    id?: string
    bookingId: number
    amount: number
    currency?: $Enums.CurrencyCode
    paymentMethod?: $Enums.PaymentMethod | null
    paymentGatewayId?: string | null
    status?: $Enums.PaymentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    paymentGatewayId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    paymentGatewayId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    id?: string
    type: $Enums.TransactionType
    amount: number
    currency?: $Enums.CurrencyCode
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    status?: $Enums.TransactionStatus
    Payment: PaymentCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    paymentId: string
    type: $Enums.TransactionType
    amount: number
    currency?: $Enums.CurrencyCode
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    status?: $Enums.TransactionStatus
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    Payment?: PaymentUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
  }

  export type TransactionCreateManyInput = {
    id?: string
    paymentId: string
    type: $Enums.TransactionType
    amount: number
    currency?: $Enums.CurrencyCode
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    status?: $Enums.TransactionStatus
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
  }

  export type ReviewCreateInput = {
    rating: number
    title?: string | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Booking: BookingCreateNestedOneWithoutReviewInput
    User: UserCreateNestedOneWithoutReviewsInput
    Hotel?: HotelCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: number
    bookingId: number
    userId: number
    rating: number
    title?: string | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelId?: number | null
  }

  export type ReviewUpdateInput = {
    rating?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Booking?: BookingUpdateOneRequiredWithoutReviewNestedInput
    User?: UserUpdateOneRequiredWithoutReviewsNestedInput
    Hotel?: HotelUpdateOneWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReviewCreateManyInput = {
    id?: number
    bookingId: number
    userId: number
    rating: number
    title?: string | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelId?: number | null
  }

  export type ReviewUpdateManyMutationInput = {
    rating?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PromotionCreateInput = {
    code: string
    description?: string | null
    discountType?: $Enums.DiscountType
    discountValue: number
    validFrom?: Date | string | null
    validUntil?: Date | string | null
    maxUses?: number | null
    usesPerUser?: number | null
    currentUses?: number
    minNights?: number | null
    minAmount?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutPromotionInput
    PromotionHotel?: PromotionHotelCreateNestedManyWithoutPromotionInput
    PromotionRoomType?: PromotionRoomTypeCreateNestedManyWithoutPromotionInput
  }

  export type PromotionUncheckedCreateInput = {
    id?: number
    code: string
    description?: string | null
    discountType?: $Enums.DiscountType
    discountValue: number
    validFrom?: Date | string | null
    validUntil?: Date | string | null
    maxUses?: number | null
    usesPerUser?: number | null
    currentUses?: number
    minNights?: number | null
    minAmount?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutPromotionInput
    PromotionHotel?: PromotionHotelUncheckedCreateNestedManyWithoutPromotionInput
    PromotionRoomType?: PromotionRoomTypeUncheckedCreateNestedManyWithoutPromotionInput
  }

  export type PromotionUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usesPerUser?: NullableIntFieldUpdateOperationsInput | number | null
    currentUses?: IntFieldUpdateOperationsInput | number
    minNights?: NullableIntFieldUpdateOperationsInput | number | null
    minAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutPromotionNestedInput
    PromotionHotel?: PromotionHotelUpdateManyWithoutPromotionNestedInput
    PromotionRoomType?: PromotionRoomTypeUpdateManyWithoutPromotionNestedInput
  }

  export type PromotionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usesPerUser?: NullableIntFieldUpdateOperationsInput | number | null
    currentUses?: IntFieldUpdateOperationsInput | number
    minNights?: NullableIntFieldUpdateOperationsInput | number | null
    minAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutPromotionNestedInput
    PromotionHotel?: PromotionHotelUncheckedUpdateManyWithoutPromotionNestedInput
    PromotionRoomType?: PromotionRoomTypeUncheckedUpdateManyWithoutPromotionNestedInput
  }

  export type PromotionCreateManyInput = {
    id?: number
    code: string
    description?: string | null
    discountType?: $Enums.DiscountType
    discountValue: number
    validFrom?: Date | string | null
    validUntil?: Date | string | null
    maxUses?: number | null
    usesPerUser?: number | null
    currentUses?: number
    minNights?: number | null
    minAmount?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromotionUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usesPerUser?: NullableIntFieldUpdateOperationsInput | number | null
    currentUses?: IntFieldUpdateOperationsInput | number
    minNights?: NullableIntFieldUpdateOperationsInput | number | null
    minAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usesPerUser?: NullableIntFieldUpdateOperationsInput | number | null
    currentUses?: IntFieldUpdateOperationsInput | number
    minNights?: NullableIntFieldUpdateOperationsInput | number | null
    minAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CancellationPolicyCreateInput = {
    name: string
    description?: string | null
    rules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutCancellationPolicyInput
    Hotel?: HotelCreateNestedOneWithoutPoliciesInput
  }

  export type CancellationPolicyUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    rules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelId?: number | null
    bookings?: BookingUncheckedCreateNestedManyWithoutCancellationPolicyInput
  }

  export type CancellationPolicyUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutCancellationPolicyNestedInput
    Hotel?: HotelUpdateOneWithoutPoliciesNestedInput
  }

  export type CancellationPolicyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
    bookings?: BookingUncheckedUpdateManyWithoutCancellationPolicyNestedInput
  }

  export type CancellationPolicyCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    rules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelId?: number | null
  }

  export type CancellationPolicyUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CancellationPolicyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CancellationCreateInput = {
    reason?: string | null
    cancelledAt?: Date | string
    refundAmount?: number | null
    refundStatus?: string | null
    notes?: string | null
    Booking: BookingCreateNestedOneWithoutCancellationInput
    User?: UserCreateNestedOneWithoutCancellationsInput
  }

  export type CancellationUncheckedCreateInput = {
    id?: number
    bookingId: number
    reason?: string | null
    cancelledAt?: Date | string
    processedByUserId?: number | null
    refundAmount?: number | null
    refundStatus?: string | null
    notes?: string | null
  }

  export type CancellationUpdateInput = {
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundStatus?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    Booking?: BookingUpdateOneRequiredWithoutCancellationNestedInput
    User?: UserUpdateOneWithoutCancellationsNestedInput
  }

  export type CancellationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundStatus?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CancellationCreateManyInput = {
    id?: number
    bookingId: number
    reason?: string | null
    cancelledAt?: Date | string
    processedByUserId?: number | null
    refundAmount?: number | null
    refundStatus?: string | null
    notes?: string | null
  }

  export type CancellationUpdateManyMutationInput = {
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundStatus?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CancellationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundStatus?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PromotionHotelCreateInput = {
    createdAt?: Date | string
    Promotion: PromotionCreateNestedOneWithoutPromotionHotelInput
    Hotel: HotelCreateNestedOneWithoutPromotionHotelInput
  }

  export type PromotionHotelUncheckedCreateInput = {
    id?: number
    promotionId: number
    hotelId: number
    createdAt?: Date | string
  }

  export type PromotionHotelUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Promotion?: PromotionUpdateOneRequiredWithoutPromotionHotelNestedInput
    Hotel?: HotelUpdateOneRequiredWithoutPromotionHotelNestedInput
  }

  export type PromotionHotelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    promotionId?: IntFieldUpdateOperationsInput | number
    hotelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionHotelCreateManyInput = {
    id?: number
    promotionId: number
    hotelId: number
    createdAt?: Date | string
  }

  export type PromotionHotelUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionHotelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    promotionId?: IntFieldUpdateOperationsInput | number
    hotelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionRoomTypeCreateInput = {
    createdAt?: Date | string
    Promotion: PromotionCreateNestedOneWithoutPromotionRoomTypeInput
    RoomType: RoomTypeCreateNestedOneWithoutPromotionRoomTypeInput
  }

  export type PromotionRoomTypeUncheckedCreateInput = {
    id?: number
    promotionId: number
    roomTypeId: number
    createdAt?: Date | string
  }

  export type PromotionRoomTypeUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Promotion?: PromotionUpdateOneRequiredWithoutPromotionRoomTypeNestedInput
    RoomType?: RoomTypeUpdateOneRequiredWithoutPromotionRoomTypeNestedInput
  }

  export type PromotionRoomTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    promotionId?: IntFieldUpdateOperationsInput | number
    roomTypeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionRoomTypeCreateManyInput = {
    id?: number
    promotionId: number
    roomTypeId: number
    createdAt?: Date | string
  }

  export type PromotionRoomTypeUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionRoomTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    promotionId?: IntFieldUpdateOperationsInput | number
    roomTypeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AddressNullableScalarRelationFilter = {
    is?: AddressWhereInput | null
    isNot?: AddressWhereInput | null
  }

  export type ImageListRelationFilter = {
    every?: ImageWhereInput
    some?: ImageWhereInput
    none?: ImageWhereInput
  }

  export type HotelAmenityListRelationFilter = {
    every?: HotelAmenityWhereInput
    some?: HotelAmenityWhereInput
    none?: HotelAmenityWhereInput
  }

  export type RoomTypeListRelationFilter = {
    every?: RoomTypeWhereInput
    some?: RoomTypeWhereInput
    none?: RoomTypeWhereInput
  }

  export type RoomListRelationFilter = {
    every?: RoomWhereInput
    some?: RoomWhereInput
    none?: RoomWhereInput
  }

  export type BookingListRelationFilter = {
    every?: BookingWhereInput
    some?: BookingWhereInput
    none?: BookingWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type RoomInventoryListRelationFilter = {
    every?: RoomInventoryWhereInput
    some?: RoomInventoryWhereInput
    none?: RoomInventoryWhereInput
  }

  export type RoomPriceListRelationFilter = {
    every?: RoomPriceWhereInput
    some?: RoomPriceWhereInput
    none?: RoomPriceWhereInput
  }

  export type CancellationPolicyListRelationFilter = {
    every?: CancellationPolicyWhereInput
    some?: CancellationPolicyWhereInput
    none?: CancellationPolicyWhereInput
  }

  export type PromotionHotelListRelationFilter = {
    every?: PromotionHotelWhereInput
    some?: PromotionHotelWhereInput
    none?: PromotionHotelWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HotelAmenityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomInventoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomPriceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CancellationPolicyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PromotionHotelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HotelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    addressId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelAvgOrderByAggregateInput = {
    id?: SortOrder
    addressId?: SortOrder
  }

  export type HotelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    addressId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    addressId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HotelSumOrderByAggregateInput = {
    id?: SortOrder
    addressId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type HotelNullableScalarRelationFilter = {
    is?: HotelWhereInput | null
    isNot?: HotelWhereInput | null
  }

  export type AddressCountOrderByAggregateInput = {
    id?: SortOrder
    streetAddress?: SortOrder
    city?: SortOrder
    stateProvince?: SortOrder
    postalCode?: SortOrder
    countryCode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressAvgOrderByAggregateInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type AddressMaxOrderByAggregateInput = {
    id?: SortOrder
    streetAddress?: SortOrder
    city?: SortOrder
    stateProvince?: SortOrder
    postalCode?: SortOrder
    countryCode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressMinOrderByAggregateInput = {
    id?: SortOrder
    streetAddress?: SortOrder
    city?: SortOrder
    stateProvince?: SortOrder
    postalCode?: SortOrder
    countryCode?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressSumOrderByAggregateInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type RoomTypeNullableScalarRelationFilter = {
    is?: RoomTypeWhereInput | null
    isNot?: RoomTypeWhereInput | null
  }

  export type ImageCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    altText?: SortOrder
    order?: SortOrder
    hotelId?: SortOrder
    roomTypeId?: SortOrder
    createdAt?: SortOrder
  }

  export type ImageAvgOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    hotelId?: SortOrder
    roomTypeId?: SortOrder
  }

  export type ImageMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    altText?: SortOrder
    order?: SortOrder
    hotelId?: SortOrder
    roomTypeId?: SortOrder
    createdAt?: SortOrder
  }

  export type ImageMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    altText?: SortOrder
    order?: SortOrder
    hotelId?: SortOrder
    roomTypeId?: SortOrder
    createdAt?: SortOrder
  }

  export type ImageSumOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    hotelId?: SortOrder
    roomTypeId?: SortOrder
  }

  export type RoomTypeAmenityListRelationFilter = {
    every?: RoomTypeAmenityWhereInput
    some?: RoomTypeAmenityWhereInput
    none?: RoomTypeAmenityWhereInput
  }

  export type RoomTypeAmenityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AmenityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type AmenityAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AmenityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type AmenityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type AmenitySumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type HotelScalarRelationFilter = {
    is?: HotelWhereInput
    isNot?: HotelWhereInput
  }

  export type AmenityScalarRelationFilter = {
    is?: AmenityWhereInput
    isNot?: AmenityWhereInput
  }

  export type HotelAmenityHotelIdAmenityIdCompoundUniqueInput = {
    hotelId: number
    amenityId: number
  }

  export type HotelAmenityCountOrderByAggregateInput = {
    hotelId?: SortOrder
    amenityId?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type HotelAmenityAvgOrderByAggregateInput = {
    hotelId?: SortOrder
    amenityId?: SortOrder
  }

  export type HotelAmenityMaxOrderByAggregateInput = {
    hotelId?: SortOrder
    amenityId?: SortOrder
    createdAt?: SortOrder
  }

  export type HotelAmenityMinOrderByAggregateInput = {
    hotelId?: SortOrder
    amenityId?: SortOrder
    createdAt?: SortOrder
  }

  export type HotelAmenitySumOrderByAggregateInput = {
    hotelId?: SortOrder
    amenityId?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type PromotionRoomTypeListRelationFilter = {
    every?: PromotionRoomTypeWhereInput
    some?: PromotionRoomTypeWhereInput
    none?: PromotionRoomTypeWhereInput
  }

  export type PromotionRoomTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomTypeHotelIdNameCompoundUniqueInput = {
    hotelId: number
    name: string
  }

  export type RoomTypeCountOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    maxGuests?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomTypeAvgOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    maxGuests?: SortOrder
  }

  export type RoomTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    maxGuests?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomTypeMinOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    maxGuests?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomTypeSumOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
    maxGuests?: SortOrder
  }

  export type RoomTypeScalarRelationFilter = {
    is?: RoomTypeWhereInput
    isNot?: RoomTypeWhereInput
  }

  export type RoomTypeAmenityRoomTypeIdAmenityIdCompoundUniqueInput = {
    roomTypeId: number
    amenityId: number
  }

  export type RoomTypeAmenityCountOrderByAggregateInput = {
    roomTypeId?: SortOrder
    amenityId?: SortOrder
    createdAt?: SortOrder
  }

  export type RoomTypeAmenityAvgOrderByAggregateInput = {
    roomTypeId?: SortOrder
    amenityId?: SortOrder
  }

  export type RoomTypeAmenityMaxOrderByAggregateInput = {
    roomTypeId?: SortOrder
    amenityId?: SortOrder
    createdAt?: SortOrder
  }

  export type RoomTypeAmenityMinOrderByAggregateInput = {
    roomTypeId?: SortOrder
    amenityId?: SortOrder
    createdAt?: SortOrder
  }

  export type RoomTypeAmenitySumOrderByAggregateInput = {
    roomTypeId?: SortOrder
    amenityId?: SortOrder
  }

  export type EnumRoomStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomStatus | EnumRoomStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RoomStatus[] | ListEnumRoomStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomStatus[] | ListEnumRoomStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomStatusFilter<$PrismaModel> | $Enums.RoomStatus
  }

  export type RoomCountOrderByAggregateInput = {
    id?: SortOrder
    roomTypeId?: SortOrder
    roomNumber?: SortOrder
    floor?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelId?: SortOrder
  }

  export type RoomAvgOrderByAggregateInput = {
    id?: SortOrder
    roomTypeId?: SortOrder
    hotelId?: SortOrder
  }

  export type RoomMaxOrderByAggregateInput = {
    id?: SortOrder
    roomTypeId?: SortOrder
    roomNumber?: SortOrder
    floor?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelId?: SortOrder
  }

  export type RoomMinOrderByAggregateInput = {
    id?: SortOrder
    roomTypeId?: SortOrder
    roomNumber?: SortOrder
    floor?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelId?: SortOrder
  }

  export type RoomSumOrderByAggregateInput = {
    id?: SortOrder
    roomTypeId?: SortOrder
    hotelId?: SortOrder
  }

  export type EnumRoomStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomStatus | EnumRoomStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RoomStatus[] | ListEnumRoomStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomStatus[] | ListEnumRoomStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomStatusWithAggregatesFilter<$PrismaModel> | $Enums.RoomStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoomStatusFilter<$PrismaModel>
    _max?: NestedEnumRoomStatusFilter<$PrismaModel>
  }

  export type RoomInventoryRoomTypeIdDateCompoundUniqueInput = {
    roomTypeId: number
    date: Date | string
  }

  export type RoomInventoryCountOrderByAggregateInput = {
    id?: SortOrder
    roomTypeId?: SortOrder
    date?: SortOrder
    totalInventory?: SortOrder
    bookedCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelId?: SortOrder
  }

  export type RoomInventoryAvgOrderByAggregateInput = {
    id?: SortOrder
    roomTypeId?: SortOrder
    totalInventory?: SortOrder
    bookedCount?: SortOrder
    hotelId?: SortOrder
  }

  export type RoomInventoryMaxOrderByAggregateInput = {
    id?: SortOrder
    roomTypeId?: SortOrder
    date?: SortOrder
    totalInventory?: SortOrder
    bookedCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelId?: SortOrder
  }

  export type RoomInventoryMinOrderByAggregateInput = {
    id?: SortOrder
    roomTypeId?: SortOrder
    date?: SortOrder
    totalInventory?: SortOrder
    bookedCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelId?: SortOrder
  }

  export type RoomInventorySumOrderByAggregateInput = {
    id?: SortOrder
    roomTypeId?: SortOrder
    totalInventory?: SortOrder
    bookedCount?: SortOrder
    hotelId?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumCurrencyCodeFilter<$PrismaModel = never> = {
    equals?: $Enums.CurrencyCode | EnumCurrencyCodeFieldRefInput<$PrismaModel>
    in?: $Enums.CurrencyCode[] | ListEnumCurrencyCodeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CurrencyCode[] | ListEnumCurrencyCodeFieldRefInput<$PrismaModel>
    not?: NestedEnumCurrencyCodeFilter<$PrismaModel> | $Enums.CurrencyCode
  }

  export type EnumPriceTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PriceType | EnumPriceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PriceType[] | ListEnumPriceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PriceType[] | ListEnumPriceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPriceTypeNullableFilter<$PrismaModel> | $Enums.PriceType | null
  }

  export type RoomPriceRoomTypeIdDateCompoundUniqueInput = {
    roomTypeId: number
    date: Date | string
  }

  export type RoomPriceCountOrderByAggregateInput = {
    id?: SortOrder
    roomTypeId?: SortOrder
    date?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    priceType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelId?: SortOrder
  }

  export type RoomPriceAvgOrderByAggregateInput = {
    id?: SortOrder
    roomTypeId?: SortOrder
    price?: SortOrder
    hotelId?: SortOrder
  }

  export type RoomPriceMaxOrderByAggregateInput = {
    id?: SortOrder
    roomTypeId?: SortOrder
    date?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    priceType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelId?: SortOrder
  }

  export type RoomPriceMinOrderByAggregateInput = {
    id?: SortOrder
    roomTypeId?: SortOrder
    date?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    priceType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelId?: SortOrder
  }

  export type RoomPriceSumOrderByAggregateInput = {
    id?: SortOrder
    roomTypeId?: SortOrder
    price?: SortOrder
    hotelId?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumCurrencyCodeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CurrencyCode | EnumCurrencyCodeFieldRefInput<$PrismaModel>
    in?: $Enums.CurrencyCode[] | ListEnumCurrencyCodeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CurrencyCode[] | ListEnumCurrencyCodeFieldRefInput<$PrismaModel>
    not?: NestedEnumCurrencyCodeWithAggregatesFilter<$PrismaModel> | $Enums.CurrencyCode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCurrencyCodeFilter<$PrismaModel>
    _max?: NestedEnumCurrencyCodeFilter<$PrismaModel>
  }

  export type EnumPriceTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PriceType | EnumPriceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PriceType[] | ListEnumPriceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PriceType[] | ListEnumPriceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPriceTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PriceType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPriceTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumPriceTypeNullableFilter<$PrismaModel>
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type CancellationListRelationFilter = {
    every?: CancellationWhereInput
    some?: CancellationWhereInput
    none?: CancellationWhereInput
  }

  export type CancellationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNumber?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNumber?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNumber?: SortOrder
    roleId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type PaymentNullableScalarRelationFilter = {
    is?: PaymentWhereInput | null
    isNot?: PaymentWhereInput | null
  }

  export type ReviewNullableScalarRelationFilter = {
    is?: ReviewWhereInput | null
    isNot?: ReviewWhereInput | null
  }

  export type PromotionNullableScalarRelationFilter = {
    is?: PromotionWhereInput | null
    isNot?: PromotionWhereInput | null
  }

  export type CancellationPolicyNullableScalarRelationFilter = {
    is?: CancellationPolicyWhereInput | null
    isNot?: CancellationPolicyWhereInput | null
  }

  export type CancellationNullableScalarRelationFilter = {
    is?: CancellationWhereInput | null
    isNot?: CancellationWhereInput | null
  }

  export type BookingCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roomTypeId?: SortOrder
    numberOfRooms?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    guestName?: SortOrder
    guestSurname?: SortOrder
    guestEmail?: SortOrder
    guestPhone?: SortOrder
    guestIdentity?: SortOrder
    promotionId?: SortOrder
    cancellationPolicyId?: SortOrder
    promotionSnapshot?: SortOrder
    policySnapshot?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelId?: SortOrder
  }

  export type BookingAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roomTypeId?: SortOrder
    numberOfRooms?: SortOrder
    totalAmount?: SortOrder
    promotionId?: SortOrder
    cancellationPolicyId?: SortOrder
    hotelId?: SortOrder
  }

  export type BookingMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roomTypeId?: SortOrder
    numberOfRooms?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    guestName?: SortOrder
    guestSurname?: SortOrder
    guestEmail?: SortOrder
    guestPhone?: SortOrder
    guestIdentity?: SortOrder
    promotionId?: SortOrder
    cancellationPolicyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelId?: SortOrder
  }

  export type BookingMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roomTypeId?: SortOrder
    numberOfRooms?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    guestName?: SortOrder
    guestSurname?: SortOrder
    guestEmail?: SortOrder
    guestPhone?: SortOrder
    guestIdentity?: SortOrder
    promotionId?: SortOrder
    cancellationPolicyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelId?: SortOrder
  }

  export type BookingSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roomTypeId?: SortOrder
    numberOfRooms?: SortOrder
    totalAmount?: SortOrder
    promotionId?: SortOrder
    cancellationPolicyId?: SortOrder
    hotelId?: SortOrder
  }

  export type EnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type EnumPaymentMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableFilter<$PrismaModel> | $Enums.PaymentMethod | null
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type BookingScalarRelationFilter = {
    is?: BookingWhereInput
    isNot?: BookingWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    paymentGatewayId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    bookingId?: SortOrder
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    paymentGatewayId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentMethod?: SortOrder
    paymentGatewayId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    bookingId?: SortOrder
    amount?: SortOrder
  }

  export type EnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type EnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type EnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type PaymentScalarRelationFilter = {
    is?: PaymentWhereInput
    isNot?: PaymentWhereInput
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    gatewayResponse?: SortOrder
    timestamp?: SortOrder
    status?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    timestamp?: SortOrder
    status?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    timestamp?: SortOrder
    status?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type EnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    title?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelId?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    hotelId?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    title?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelId?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    title?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelId?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    hotelId?: SortOrder
  }

  export type EnumDiscountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeFilter<$PrismaModel> | $Enums.DiscountType
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type PromotionCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    maxUses?: SortOrder
    usesPerUser?: SortOrder
    currentUses?: SortOrder
    minNights?: SortOrder
    minAmount?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromotionAvgOrderByAggregateInput = {
    id?: SortOrder
    discountValue?: SortOrder
    maxUses?: SortOrder
    usesPerUser?: SortOrder
    currentUses?: SortOrder
    minNights?: SortOrder
    minAmount?: SortOrder
  }

  export type PromotionMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    maxUses?: SortOrder
    usesPerUser?: SortOrder
    currentUses?: SortOrder
    minNights?: SortOrder
    minAmount?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromotionMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    validFrom?: SortOrder
    validUntil?: SortOrder
    maxUses?: SortOrder
    usesPerUser?: SortOrder
    currentUses?: SortOrder
    minNights?: SortOrder
    minAmount?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PromotionSumOrderByAggregateInput = {
    id?: SortOrder
    discountValue?: SortOrder
    maxUses?: SortOrder
    usesPerUser?: SortOrder
    currentUses?: SortOrder
    minNights?: SortOrder
    minAmount?: SortOrder
  }

  export type EnumDiscountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeWithAggregatesFilter<$PrismaModel> | $Enums.DiscountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscountTypeFilter<$PrismaModel>
    _max?: NestedEnumDiscountTypeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type CancellationPolicyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    rules?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelId?: SortOrder
  }

  export type CancellationPolicyAvgOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
  }

  export type CancellationPolicyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelId?: SortOrder
  }

  export type CancellationPolicyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    hotelId?: SortOrder
  }

  export type CancellationPolicySumOrderByAggregateInput = {
    id?: SortOrder
    hotelId?: SortOrder
  }

  export type CancellationCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    reason?: SortOrder
    cancelledAt?: SortOrder
    processedByUserId?: SortOrder
    refundAmount?: SortOrder
    refundStatus?: SortOrder
    notes?: SortOrder
  }

  export type CancellationAvgOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    processedByUserId?: SortOrder
    refundAmount?: SortOrder
  }

  export type CancellationMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    reason?: SortOrder
    cancelledAt?: SortOrder
    processedByUserId?: SortOrder
    refundAmount?: SortOrder
    refundStatus?: SortOrder
    notes?: SortOrder
  }

  export type CancellationMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    reason?: SortOrder
    cancelledAt?: SortOrder
    processedByUserId?: SortOrder
    refundAmount?: SortOrder
    refundStatus?: SortOrder
    notes?: SortOrder
  }

  export type CancellationSumOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    processedByUserId?: SortOrder
    refundAmount?: SortOrder
  }

  export type PromotionScalarRelationFilter = {
    is?: PromotionWhereInput
    isNot?: PromotionWhereInput
  }

  export type PromotionHotelPromotionIdHotelIdCompoundUniqueInput = {
    promotionId: number
    hotelId: number
  }

  export type PromotionHotelCountOrderByAggregateInput = {
    id?: SortOrder
    promotionId?: SortOrder
    hotelId?: SortOrder
    createdAt?: SortOrder
  }

  export type PromotionHotelAvgOrderByAggregateInput = {
    id?: SortOrder
    promotionId?: SortOrder
    hotelId?: SortOrder
  }

  export type PromotionHotelMaxOrderByAggregateInput = {
    id?: SortOrder
    promotionId?: SortOrder
    hotelId?: SortOrder
    createdAt?: SortOrder
  }

  export type PromotionHotelMinOrderByAggregateInput = {
    id?: SortOrder
    promotionId?: SortOrder
    hotelId?: SortOrder
    createdAt?: SortOrder
  }

  export type PromotionHotelSumOrderByAggregateInput = {
    id?: SortOrder
    promotionId?: SortOrder
    hotelId?: SortOrder
  }

  export type PromotionRoomTypePromotionIdRoomTypeIdCompoundUniqueInput = {
    promotionId: number
    roomTypeId: number
  }

  export type PromotionRoomTypeCountOrderByAggregateInput = {
    id?: SortOrder
    promotionId?: SortOrder
    roomTypeId?: SortOrder
    createdAt?: SortOrder
  }

  export type PromotionRoomTypeAvgOrderByAggregateInput = {
    id?: SortOrder
    promotionId?: SortOrder
    roomTypeId?: SortOrder
  }

  export type PromotionRoomTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    promotionId?: SortOrder
    roomTypeId?: SortOrder
    createdAt?: SortOrder
  }

  export type PromotionRoomTypeMinOrderByAggregateInput = {
    id?: SortOrder
    promotionId?: SortOrder
    roomTypeId?: SortOrder
    createdAt?: SortOrder
  }

  export type PromotionRoomTypeSumOrderByAggregateInput = {
    id?: SortOrder
    promotionId?: SortOrder
    roomTypeId?: SortOrder
  }

  export type AddressCreateNestedOneWithoutHotelInput = {
    create?: XOR<AddressCreateWithoutHotelInput, AddressUncheckedCreateWithoutHotelInput>
    connectOrCreate?: AddressCreateOrConnectWithoutHotelInput
    connect?: AddressWhereUniqueInput
  }

  export type ImageCreateNestedManyWithoutHotelInput = {
    create?: XOR<ImageCreateWithoutHotelInput, ImageUncheckedCreateWithoutHotelInput> | ImageCreateWithoutHotelInput[] | ImageUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutHotelInput | ImageCreateOrConnectWithoutHotelInput[]
    createMany?: ImageCreateManyHotelInputEnvelope
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
  }

  export type HotelAmenityCreateNestedManyWithoutHotelInput = {
    create?: XOR<HotelAmenityCreateWithoutHotelInput, HotelAmenityUncheckedCreateWithoutHotelInput> | HotelAmenityCreateWithoutHotelInput[] | HotelAmenityUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: HotelAmenityCreateOrConnectWithoutHotelInput | HotelAmenityCreateOrConnectWithoutHotelInput[]
    createMany?: HotelAmenityCreateManyHotelInputEnvelope
    connect?: HotelAmenityWhereUniqueInput | HotelAmenityWhereUniqueInput[]
  }

  export type RoomTypeCreateNestedManyWithoutHotelInput = {
    create?: XOR<RoomTypeCreateWithoutHotelInput, RoomTypeUncheckedCreateWithoutHotelInput> | RoomTypeCreateWithoutHotelInput[] | RoomTypeUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: RoomTypeCreateOrConnectWithoutHotelInput | RoomTypeCreateOrConnectWithoutHotelInput[]
    createMany?: RoomTypeCreateManyHotelInputEnvelope
    connect?: RoomTypeWhereUniqueInput | RoomTypeWhereUniqueInput[]
  }

  export type RoomCreateNestedManyWithoutHotelInput = {
    create?: XOR<RoomCreateWithoutHotelInput, RoomUncheckedCreateWithoutHotelInput> | RoomCreateWithoutHotelInput[] | RoomUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutHotelInput | RoomCreateOrConnectWithoutHotelInput[]
    createMany?: RoomCreateManyHotelInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutHotelInput = {
    create?: XOR<BookingCreateWithoutHotelInput, BookingUncheckedCreateWithoutHotelInput> | BookingCreateWithoutHotelInput[] | BookingUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutHotelInput | BookingCreateOrConnectWithoutHotelInput[]
    createMany?: BookingCreateManyHotelInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutHotelInput = {
    create?: XOR<ReviewCreateWithoutHotelInput, ReviewUncheckedCreateWithoutHotelInput> | ReviewCreateWithoutHotelInput[] | ReviewUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutHotelInput | ReviewCreateOrConnectWithoutHotelInput[]
    createMany?: ReviewCreateManyHotelInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type RoomInventoryCreateNestedManyWithoutHotelInput = {
    create?: XOR<RoomInventoryCreateWithoutHotelInput, RoomInventoryUncheckedCreateWithoutHotelInput> | RoomInventoryCreateWithoutHotelInput[] | RoomInventoryUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: RoomInventoryCreateOrConnectWithoutHotelInput | RoomInventoryCreateOrConnectWithoutHotelInput[]
    createMany?: RoomInventoryCreateManyHotelInputEnvelope
    connect?: RoomInventoryWhereUniqueInput | RoomInventoryWhereUniqueInput[]
  }

  export type RoomPriceCreateNestedManyWithoutHotelInput = {
    create?: XOR<RoomPriceCreateWithoutHotelInput, RoomPriceUncheckedCreateWithoutHotelInput> | RoomPriceCreateWithoutHotelInput[] | RoomPriceUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: RoomPriceCreateOrConnectWithoutHotelInput | RoomPriceCreateOrConnectWithoutHotelInput[]
    createMany?: RoomPriceCreateManyHotelInputEnvelope
    connect?: RoomPriceWhereUniqueInput | RoomPriceWhereUniqueInput[]
  }

  export type CancellationPolicyCreateNestedManyWithoutHotelInput = {
    create?: XOR<CancellationPolicyCreateWithoutHotelInput, CancellationPolicyUncheckedCreateWithoutHotelInput> | CancellationPolicyCreateWithoutHotelInput[] | CancellationPolicyUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: CancellationPolicyCreateOrConnectWithoutHotelInput | CancellationPolicyCreateOrConnectWithoutHotelInput[]
    createMany?: CancellationPolicyCreateManyHotelInputEnvelope
    connect?: CancellationPolicyWhereUniqueInput | CancellationPolicyWhereUniqueInput[]
  }

  export type PromotionHotelCreateNestedManyWithoutHotelInput = {
    create?: XOR<PromotionHotelCreateWithoutHotelInput, PromotionHotelUncheckedCreateWithoutHotelInput> | PromotionHotelCreateWithoutHotelInput[] | PromotionHotelUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: PromotionHotelCreateOrConnectWithoutHotelInput | PromotionHotelCreateOrConnectWithoutHotelInput[]
    createMany?: PromotionHotelCreateManyHotelInputEnvelope
    connect?: PromotionHotelWhereUniqueInput | PromotionHotelWhereUniqueInput[]
  }

  export type ImageUncheckedCreateNestedManyWithoutHotelInput = {
    create?: XOR<ImageCreateWithoutHotelInput, ImageUncheckedCreateWithoutHotelInput> | ImageCreateWithoutHotelInput[] | ImageUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutHotelInput | ImageCreateOrConnectWithoutHotelInput[]
    createMany?: ImageCreateManyHotelInputEnvelope
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
  }

  export type HotelAmenityUncheckedCreateNestedManyWithoutHotelInput = {
    create?: XOR<HotelAmenityCreateWithoutHotelInput, HotelAmenityUncheckedCreateWithoutHotelInput> | HotelAmenityCreateWithoutHotelInput[] | HotelAmenityUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: HotelAmenityCreateOrConnectWithoutHotelInput | HotelAmenityCreateOrConnectWithoutHotelInput[]
    createMany?: HotelAmenityCreateManyHotelInputEnvelope
    connect?: HotelAmenityWhereUniqueInput | HotelAmenityWhereUniqueInput[]
  }

  export type RoomTypeUncheckedCreateNestedManyWithoutHotelInput = {
    create?: XOR<RoomTypeCreateWithoutHotelInput, RoomTypeUncheckedCreateWithoutHotelInput> | RoomTypeCreateWithoutHotelInput[] | RoomTypeUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: RoomTypeCreateOrConnectWithoutHotelInput | RoomTypeCreateOrConnectWithoutHotelInput[]
    createMany?: RoomTypeCreateManyHotelInputEnvelope
    connect?: RoomTypeWhereUniqueInput | RoomTypeWhereUniqueInput[]
  }

  export type RoomUncheckedCreateNestedManyWithoutHotelInput = {
    create?: XOR<RoomCreateWithoutHotelInput, RoomUncheckedCreateWithoutHotelInput> | RoomCreateWithoutHotelInput[] | RoomUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutHotelInput | RoomCreateOrConnectWithoutHotelInput[]
    createMany?: RoomCreateManyHotelInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutHotelInput = {
    create?: XOR<BookingCreateWithoutHotelInput, BookingUncheckedCreateWithoutHotelInput> | BookingCreateWithoutHotelInput[] | BookingUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutHotelInput | BookingCreateOrConnectWithoutHotelInput[]
    createMany?: BookingCreateManyHotelInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutHotelInput = {
    create?: XOR<ReviewCreateWithoutHotelInput, ReviewUncheckedCreateWithoutHotelInput> | ReviewCreateWithoutHotelInput[] | ReviewUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutHotelInput | ReviewCreateOrConnectWithoutHotelInput[]
    createMany?: ReviewCreateManyHotelInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type RoomInventoryUncheckedCreateNestedManyWithoutHotelInput = {
    create?: XOR<RoomInventoryCreateWithoutHotelInput, RoomInventoryUncheckedCreateWithoutHotelInput> | RoomInventoryCreateWithoutHotelInput[] | RoomInventoryUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: RoomInventoryCreateOrConnectWithoutHotelInput | RoomInventoryCreateOrConnectWithoutHotelInput[]
    createMany?: RoomInventoryCreateManyHotelInputEnvelope
    connect?: RoomInventoryWhereUniqueInput | RoomInventoryWhereUniqueInput[]
  }

  export type RoomPriceUncheckedCreateNestedManyWithoutHotelInput = {
    create?: XOR<RoomPriceCreateWithoutHotelInput, RoomPriceUncheckedCreateWithoutHotelInput> | RoomPriceCreateWithoutHotelInput[] | RoomPriceUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: RoomPriceCreateOrConnectWithoutHotelInput | RoomPriceCreateOrConnectWithoutHotelInput[]
    createMany?: RoomPriceCreateManyHotelInputEnvelope
    connect?: RoomPriceWhereUniqueInput | RoomPriceWhereUniqueInput[]
  }

  export type CancellationPolicyUncheckedCreateNestedManyWithoutHotelInput = {
    create?: XOR<CancellationPolicyCreateWithoutHotelInput, CancellationPolicyUncheckedCreateWithoutHotelInput> | CancellationPolicyCreateWithoutHotelInput[] | CancellationPolicyUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: CancellationPolicyCreateOrConnectWithoutHotelInput | CancellationPolicyCreateOrConnectWithoutHotelInput[]
    createMany?: CancellationPolicyCreateManyHotelInputEnvelope
    connect?: CancellationPolicyWhereUniqueInput | CancellationPolicyWhereUniqueInput[]
  }

  export type PromotionHotelUncheckedCreateNestedManyWithoutHotelInput = {
    create?: XOR<PromotionHotelCreateWithoutHotelInput, PromotionHotelUncheckedCreateWithoutHotelInput> | PromotionHotelCreateWithoutHotelInput[] | PromotionHotelUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: PromotionHotelCreateOrConnectWithoutHotelInput | PromotionHotelCreateOrConnectWithoutHotelInput[]
    createMany?: PromotionHotelCreateManyHotelInputEnvelope
    connect?: PromotionHotelWhereUniqueInput | PromotionHotelWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AddressUpdateOneWithoutHotelNestedInput = {
    create?: XOR<AddressCreateWithoutHotelInput, AddressUncheckedCreateWithoutHotelInput>
    connectOrCreate?: AddressCreateOrConnectWithoutHotelInput
    upsert?: AddressUpsertWithoutHotelInput
    disconnect?: AddressWhereInput | boolean
    delete?: AddressWhereInput | boolean
    connect?: AddressWhereUniqueInput
    update?: XOR<XOR<AddressUpdateToOneWithWhereWithoutHotelInput, AddressUpdateWithoutHotelInput>, AddressUncheckedUpdateWithoutHotelInput>
  }

  export type ImageUpdateManyWithoutHotelNestedInput = {
    create?: XOR<ImageCreateWithoutHotelInput, ImageUncheckedCreateWithoutHotelInput> | ImageCreateWithoutHotelInput[] | ImageUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutHotelInput | ImageCreateOrConnectWithoutHotelInput[]
    upsert?: ImageUpsertWithWhereUniqueWithoutHotelInput | ImageUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: ImageCreateManyHotelInputEnvelope
    set?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    disconnect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    delete?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    update?: ImageUpdateWithWhereUniqueWithoutHotelInput | ImageUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: ImageUpdateManyWithWhereWithoutHotelInput | ImageUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: ImageScalarWhereInput | ImageScalarWhereInput[]
  }

  export type HotelAmenityUpdateManyWithoutHotelNestedInput = {
    create?: XOR<HotelAmenityCreateWithoutHotelInput, HotelAmenityUncheckedCreateWithoutHotelInput> | HotelAmenityCreateWithoutHotelInput[] | HotelAmenityUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: HotelAmenityCreateOrConnectWithoutHotelInput | HotelAmenityCreateOrConnectWithoutHotelInput[]
    upsert?: HotelAmenityUpsertWithWhereUniqueWithoutHotelInput | HotelAmenityUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: HotelAmenityCreateManyHotelInputEnvelope
    set?: HotelAmenityWhereUniqueInput | HotelAmenityWhereUniqueInput[]
    disconnect?: HotelAmenityWhereUniqueInput | HotelAmenityWhereUniqueInput[]
    delete?: HotelAmenityWhereUniqueInput | HotelAmenityWhereUniqueInput[]
    connect?: HotelAmenityWhereUniqueInput | HotelAmenityWhereUniqueInput[]
    update?: HotelAmenityUpdateWithWhereUniqueWithoutHotelInput | HotelAmenityUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: HotelAmenityUpdateManyWithWhereWithoutHotelInput | HotelAmenityUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: HotelAmenityScalarWhereInput | HotelAmenityScalarWhereInput[]
  }

  export type RoomTypeUpdateManyWithoutHotelNestedInput = {
    create?: XOR<RoomTypeCreateWithoutHotelInput, RoomTypeUncheckedCreateWithoutHotelInput> | RoomTypeCreateWithoutHotelInput[] | RoomTypeUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: RoomTypeCreateOrConnectWithoutHotelInput | RoomTypeCreateOrConnectWithoutHotelInput[]
    upsert?: RoomTypeUpsertWithWhereUniqueWithoutHotelInput | RoomTypeUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: RoomTypeCreateManyHotelInputEnvelope
    set?: RoomTypeWhereUniqueInput | RoomTypeWhereUniqueInput[]
    disconnect?: RoomTypeWhereUniqueInput | RoomTypeWhereUniqueInput[]
    delete?: RoomTypeWhereUniqueInput | RoomTypeWhereUniqueInput[]
    connect?: RoomTypeWhereUniqueInput | RoomTypeWhereUniqueInput[]
    update?: RoomTypeUpdateWithWhereUniqueWithoutHotelInput | RoomTypeUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: RoomTypeUpdateManyWithWhereWithoutHotelInput | RoomTypeUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: RoomTypeScalarWhereInput | RoomTypeScalarWhereInput[]
  }

  export type RoomUpdateManyWithoutHotelNestedInput = {
    create?: XOR<RoomCreateWithoutHotelInput, RoomUncheckedCreateWithoutHotelInput> | RoomCreateWithoutHotelInput[] | RoomUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutHotelInput | RoomCreateOrConnectWithoutHotelInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutHotelInput | RoomUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: RoomCreateManyHotelInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutHotelInput | RoomUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutHotelInput | RoomUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutHotelNestedInput = {
    create?: XOR<BookingCreateWithoutHotelInput, BookingUncheckedCreateWithoutHotelInput> | BookingCreateWithoutHotelInput[] | BookingUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutHotelInput | BookingCreateOrConnectWithoutHotelInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutHotelInput | BookingUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: BookingCreateManyHotelInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutHotelInput | BookingUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutHotelInput | BookingUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutHotelNestedInput = {
    create?: XOR<ReviewCreateWithoutHotelInput, ReviewUncheckedCreateWithoutHotelInput> | ReviewCreateWithoutHotelInput[] | ReviewUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutHotelInput | ReviewCreateOrConnectWithoutHotelInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutHotelInput | ReviewUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: ReviewCreateManyHotelInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutHotelInput | ReviewUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutHotelInput | ReviewUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type RoomInventoryUpdateManyWithoutHotelNestedInput = {
    create?: XOR<RoomInventoryCreateWithoutHotelInput, RoomInventoryUncheckedCreateWithoutHotelInput> | RoomInventoryCreateWithoutHotelInput[] | RoomInventoryUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: RoomInventoryCreateOrConnectWithoutHotelInput | RoomInventoryCreateOrConnectWithoutHotelInput[]
    upsert?: RoomInventoryUpsertWithWhereUniqueWithoutHotelInput | RoomInventoryUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: RoomInventoryCreateManyHotelInputEnvelope
    set?: RoomInventoryWhereUniqueInput | RoomInventoryWhereUniqueInput[]
    disconnect?: RoomInventoryWhereUniqueInput | RoomInventoryWhereUniqueInput[]
    delete?: RoomInventoryWhereUniqueInput | RoomInventoryWhereUniqueInput[]
    connect?: RoomInventoryWhereUniqueInput | RoomInventoryWhereUniqueInput[]
    update?: RoomInventoryUpdateWithWhereUniqueWithoutHotelInput | RoomInventoryUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: RoomInventoryUpdateManyWithWhereWithoutHotelInput | RoomInventoryUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: RoomInventoryScalarWhereInput | RoomInventoryScalarWhereInput[]
  }

  export type RoomPriceUpdateManyWithoutHotelNestedInput = {
    create?: XOR<RoomPriceCreateWithoutHotelInput, RoomPriceUncheckedCreateWithoutHotelInput> | RoomPriceCreateWithoutHotelInput[] | RoomPriceUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: RoomPriceCreateOrConnectWithoutHotelInput | RoomPriceCreateOrConnectWithoutHotelInput[]
    upsert?: RoomPriceUpsertWithWhereUniqueWithoutHotelInput | RoomPriceUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: RoomPriceCreateManyHotelInputEnvelope
    set?: RoomPriceWhereUniqueInput | RoomPriceWhereUniqueInput[]
    disconnect?: RoomPriceWhereUniqueInput | RoomPriceWhereUniqueInput[]
    delete?: RoomPriceWhereUniqueInput | RoomPriceWhereUniqueInput[]
    connect?: RoomPriceWhereUniqueInput | RoomPriceWhereUniqueInput[]
    update?: RoomPriceUpdateWithWhereUniqueWithoutHotelInput | RoomPriceUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: RoomPriceUpdateManyWithWhereWithoutHotelInput | RoomPriceUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: RoomPriceScalarWhereInput | RoomPriceScalarWhereInput[]
  }

  export type CancellationPolicyUpdateManyWithoutHotelNestedInput = {
    create?: XOR<CancellationPolicyCreateWithoutHotelInput, CancellationPolicyUncheckedCreateWithoutHotelInput> | CancellationPolicyCreateWithoutHotelInput[] | CancellationPolicyUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: CancellationPolicyCreateOrConnectWithoutHotelInput | CancellationPolicyCreateOrConnectWithoutHotelInput[]
    upsert?: CancellationPolicyUpsertWithWhereUniqueWithoutHotelInput | CancellationPolicyUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: CancellationPolicyCreateManyHotelInputEnvelope
    set?: CancellationPolicyWhereUniqueInput | CancellationPolicyWhereUniqueInput[]
    disconnect?: CancellationPolicyWhereUniqueInput | CancellationPolicyWhereUniqueInput[]
    delete?: CancellationPolicyWhereUniqueInput | CancellationPolicyWhereUniqueInput[]
    connect?: CancellationPolicyWhereUniqueInput | CancellationPolicyWhereUniqueInput[]
    update?: CancellationPolicyUpdateWithWhereUniqueWithoutHotelInput | CancellationPolicyUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: CancellationPolicyUpdateManyWithWhereWithoutHotelInput | CancellationPolicyUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: CancellationPolicyScalarWhereInput | CancellationPolicyScalarWhereInput[]
  }

  export type PromotionHotelUpdateManyWithoutHotelNestedInput = {
    create?: XOR<PromotionHotelCreateWithoutHotelInput, PromotionHotelUncheckedCreateWithoutHotelInput> | PromotionHotelCreateWithoutHotelInput[] | PromotionHotelUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: PromotionHotelCreateOrConnectWithoutHotelInput | PromotionHotelCreateOrConnectWithoutHotelInput[]
    upsert?: PromotionHotelUpsertWithWhereUniqueWithoutHotelInput | PromotionHotelUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: PromotionHotelCreateManyHotelInputEnvelope
    set?: PromotionHotelWhereUniqueInput | PromotionHotelWhereUniqueInput[]
    disconnect?: PromotionHotelWhereUniqueInput | PromotionHotelWhereUniqueInput[]
    delete?: PromotionHotelWhereUniqueInput | PromotionHotelWhereUniqueInput[]
    connect?: PromotionHotelWhereUniqueInput | PromotionHotelWhereUniqueInput[]
    update?: PromotionHotelUpdateWithWhereUniqueWithoutHotelInput | PromotionHotelUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: PromotionHotelUpdateManyWithWhereWithoutHotelInput | PromotionHotelUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: PromotionHotelScalarWhereInput | PromotionHotelScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ImageUncheckedUpdateManyWithoutHotelNestedInput = {
    create?: XOR<ImageCreateWithoutHotelInput, ImageUncheckedCreateWithoutHotelInput> | ImageCreateWithoutHotelInput[] | ImageUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutHotelInput | ImageCreateOrConnectWithoutHotelInput[]
    upsert?: ImageUpsertWithWhereUniqueWithoutHotelInput | ImageUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: ImageCreateManyHotelInputEnvelope
    set?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    disconnect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    delete?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    update?: ImageUpdateWithWhereUniqueWithoutHotelInput | ImageUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: ImageUpdateManyWithWhereWithoutHotelInput | ImageUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: ImageScalarWhereInput | ImageScalarWhereInput[]
  }

  export type HotelAmenityUncheckedUpdateManyWithoutHotelNestedInput = {
    create?: XOR<HotelAmenityCreateWithoutHotelInput, HotelAmenityUncheckedCreateWithoutHotelInput> | HotelAmenityCreateWithoutHotelInput[] | HotelAmenityUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: HotelAmenityCreateOrConnectWithoutHotelInput | HotelAmenityCreateOrConnectWithoutHotelInput[]
    upsert?: HotelAmenityUpsertWithWhereUniqueWithoutHotelInput | HotelAmenityUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: HotelAmenityCreateManyHotelInputEnvelope
    set?: HotelAmenityWhereUniqueInput | HotelAmenityWhereUniqueInput[]
    disconnect?: HotelAmenityWhereUniqueInput | HotelAmenityWhereUniqueInput[]
    delete?: HotelAmenityWhereUniqueInput | HotelAmenityWhereUniqueInput[]
    connect?: HotelAmenityWhereUniqueInput | HotelAmenityWhereUniqueInput[]
    update?: HotelAmenityUpdateWithWhereUniqueWithoutHotelInput | HotelAmenityUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: HotelAmenityUpdateManyWithWhereWithoutHotelInput | HotelAmenityUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: HotelAmenityScalarWhereInput | HotelAmenityScalarWhereInput[]
  }

  export type RoomTypeUncheckedUpdateManyWithoutHotelNestedInput = {
    create?: XOR<RoomTypeCreateWithoutHotelInput, RoomTypeUncheckedCreateWithoutHotelInput> | RoomTypeCreateWithoutHotelInput[] | RoomTypeUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: RoomTypeCreateOrConnectWithoutHotelInput | RoomTypeCreateOrConnectWithoutHotelInput[]
    upsert?: RoomTypeUpsertWithWhereUniqueWithoutHotelInput | RoomTypeUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: RoomTypeCreateManyHotelInputEnvelope
    set?: RoomTypeWhereUniqueInput | RoomTypeWhereUniqueInput[]
    disconnect?: RoomTypeWhereUniqueInput | RoomTypeWhereUniqueInput[]
    delete?: RoomTypeWhereUniqueInput | RoomTypeWhereUniqueInput[]
    connect?: RoomTypeWhereUniqueInput | RoomTypeWhereUniqueInput[]
    update?: RoomTypeUpdateWithWhereUniqueWithoutHotelInput | RoomTypeUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: RoomTypeUpdateManyWithWhereWithoutHotelInput | RoomTypeUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: RoomTypeScalarWhereInput | RoomTypeScalarWhereInput[]
  }

  export type RoomUncheckedUpdateManyWithoutHotelNestedInput = {
    create?: XOR<RoomCreateWithoutHotelInput, RoomUncheckedCreateWithoutHotelInput> | RoomCreateWithoutHotelInput[] | RoomUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutHotelInput | RoomCreateOrConnectWithoutHotelInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutHotelInput | RoomUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: RoomCreateManyHotelInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutHotelInput | RoomUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutHotelInput | RoomUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutHotelNestedInput = {
    create?: XOR<BookingCreateWithoutHotelInput, BookingUncheckedCreateWithoutHotelInput> | BookingCreateWithoutHotelInput[] | BookingUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutHotelInput | BookingCreateOrConnectWithoutHotelInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutHotelInput | BookingUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: BookingCreateManyHotelInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutHotelInput | BookingUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutHotelInput | BookingUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutHotelNestedInput = {
    create?: XOR<ReviewCreateWithoutHotelInput, ReviewUncheckedCreateWithoutHotelInput> | ReviewCreateWithoutHotelInput[] | ReviewUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutHotelInput | ReviewCreateOrConnectWithoutHotelInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutHotelInput | ReviewUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: ReviewCreateManyHotelInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutHotelInput | ReviewUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutHotelInput | ReviewUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type RoomInventoryUncheckedUpdateManyWithoutHotelNestedInput = {
    create?: XOR<RoomInventoryCreateWithoutHotelInput, RoomInventoryUncheckedCreateWithoutHotelInput> | RoomInventoryCreateWithoutHotelInput[] | RoomInventoryUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: RoomInventoryCreateOrConnectWithoutHotelInput | RoomInventoryCreateOrConnectWithoutHotelInput[]
    upsert?: RoomInventoryUpsertWithWhereUniqueWithoutHotelInput | RoomInventoryUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: RoomInventoryCreateManyHotelInputEnvelope
    set?: RoomInventoryWhereUniqueInput | RoomInventoryWhereUniqueInput[]
    disconnect?: RoomInventoryWhereUniqueInput | RoomInventoryWhereUniqueInput[]
    delete?: RoomInventoryWhereUniqueInput | RoomInventoryWhereUniqueInput[]
    connect?: RoomInventoryWhereUniqueInput | RoomInventoryWhereUniqueInput[]
    update?: RoomInventoryUpdateWithWhereUniqueWithoutHotelInput | RoomInventoryUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: RoomInventoryUpdateManyWithWhereWithoutHotelInput | RoomInventoryUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: RoomInventoryScalarWhereInput | RoomInventoryScalarWhereInput[]
  }

  export type RoomPriceUncheckedUpdateManyWithoutHotelNestedInput = {
    create?: XOR<RoomPriceCreateWithoutHotelInput, RoomPriceUncheckedCreateWithoutHotelInput> | RoomPriceCreateWithoutHotelInput[] | RoomPriceUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: RoomPriceCreateOrConnectWithoutHotelInput | RoomPriceCreateOrConnectWithoutHotelInput[]
    upsert?: RoomPriceUpsertWithWhereUniqueWithoutHotelInput | RoomPriceUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: RoomPriceCreateManyHotelInputEnvelope
    set?: RoomPriceWhereUniqueInput | RoomPriceWhereUniqueInput[]
    disconnect?: RoomPriceWhereUniqueInput | RoomPriceWhereUniqueInput[]
    delete?: RoomPriceWhereUniqueInput | RoomPriceWhereUniqueInput[]
    connect?: RoomPriceWhereUniqueInput | RoomPriceWhereUniqueInput[]
    update?: RoomPriceUpdateWithWhereUniqueWithoutHotelInput | RoomPriceUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: RoomPriceUpdateManyWithWhereWithoutHotelInput | RoomPriceUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: RoomPriceScalarWhereInput | RoomPriceScalarWhereInput[]
  }

  export type CancellationPolicyUncheckedUpdateManyWithoutHotelNestedInput = {
    create?: XOR<CancellationPolicyCreateWithoutHotelInput, CancellationPolicyUncheckedCreateWithoutHotelInput> | CancellationPolicyCreateWithoutHotelInput[] | CancellationPolicyUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: CancellationPolicyCreateOrConnectWithoutHotelInput | CancellationPolicyCreateOrConnectWithoutHotelInput[]
    upsert?: CancellationPolicyUpsertWithWhereUniqueWithoutHotelInput | CancellationPolicyUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: CancellationPolicyCreateManyHotelInputEnvelope
    set?: CancellationPolicyWhereUniqueInput | CancellationPolicyWhereUniqueInput[]
    disconnect?: CancellationPolicyWhereUniqueInput | CancellationPolicyWhereUniqueInput[]
    delete?: CancellationPolicyWhereUniqueInput | CancellationPolicyWhereUniqueInput[]
    connect?: CancellationPolicyWhereUniqueInput | CancellationPolicyWhereUniqueInput[]
    update?: CancellationPolicyUpdateWithWhereUniqueWithoutHotelInput | CancellationPolicyUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: CancellationPolicyUpdateManyWithWhereWithoutHotelInput | CancellationPolicyUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: CancellationPolicyScalarWhereInput | CancellationPolicyScalarWhereInput[]
  }

  export type PromotionHotelUncheckedUpdateManyWithoutHotelNestedInput = {
    create?: XOR<PromotionHotelCreateWithoutHotelInput, PromotionHotelUncheckedCreateWithoutHotelInput> | PromotionHotelCreateWithoutHotelInput[] | PromotionHotelUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: PromotionHotelCreateOrConnectWithoutHotelInput | PromotionHotelCreateOrConnectWithoutHotelInput[]
    upsert?: PromotionHotelUpsertWithWhereUniqueWithoutHotelInput | PromotionHotelUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: PromotionHotelCreateManyHotelInputEnvelope
    set?: PromotionHotelWhereUniqueInput | PromotionHotelWhereUniqueInput[]
    disconnect?: PromotionHotelWhereUniqueInput | PromotionHotelWhereUniqueInput[]
    delete?: PromotionHotelWhereUniqueInput | PromotionHotelWhereUniqueInput[]
    connect?: PromotionHotelWhereUniqueInput | PromotionHotelWhereUniqueInput[]
    update?: PromotionHotelUpdateWithWhereUniqueWithoutHotelInput | PromotionHotelUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: PromotionHotelUpdateManyWithWhereWithoutHotelInput | PromotionHotelUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: PromotionHotelScalarWhereInput | PromotionHotelScalarWhereInput[]
  }

  export type HotelCreateNestedOneWithoutAddressInput = {
    create?: XOR<HotelCreateWithoutAddressInput, HotelUncheckedCreateWithoutAddressInput>
    connectOrCreate?: HotelCreateOrConnectWithoutAddressInput
    connect?: HotelWhereUniqueInput
  }

  export type HotelUncheckedCreateNestedOneWithoutAddressInput = {
    create?: XOR<HotelCreateWithoutAddressInput, HotelUncheckedCreateWithoutAddressInput>
    connectOrCreate?: HotelCreateOrConnectWithoutAddressInput
    connect?: HotelWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type HotelUpdateOneWithoutAddressNestedInput = {
    create?: XOR<HotelCreateWithoutAddressInput, HotelUncheckedCreateWithoutAddressInput>
    connectOrCreate?: HotelCreateOrConnectWithoutAddressInput
    upsert?: HotelUpsertWithoutAddressInput
    disconnect?: HotelWhereInput | boolean
    delete?: HotelWhereInput | boolean
    connect?: HotelWhereUniqueInput
    update?: XOR<XOR<HotelUpdateToOneWithWhereWithoutAddressInput, HotelUpdateWithoutAddressInput>, HotelUncheckedUpdateWithoutAddressInput>
  }

  export type HotelUncheckedUpdateOneWithoutAddressNestedInput = {
    create?: XOR<HotelCreateWithoutAddressInput, HotelUncheckedCreateWithoutAddressInput>
    connectOrCreate?: HotelCreateOrConnectWithoutAddressInput
    upsert?: HotelUpsertWithoutAddressInput
    disconnect?: HotelWhereInput | boolean
    delete?: HotelWhereInput | boolean
    connect?: HotelWhereUniqueInput
    update?: XOR<XOR<HotelUpdateToOneWithWhereWithoutAddressInput, HotelUpdateWithoutAddressInput>, HotelUncheckedUpdateWithoutAddressInput>
  }

  export type HotelCreateNestedOneWithoutImagesInput = {
    create?: XOR<HotelCreateWithoutImagesInput, HotelUncheckedCreateWithoutImagesInput>
    connectOrCreate?: HotelCreateOrConnectWithoutImagesInput
    connect?: HotelWhereUniqueInput
  }

  export type RoomTypeCreateNestedOneWithoutImagesInput = {
    create?: XOR<RoomTypeCreateWithoutImagesInput, RoomTypeUncheckedCreateWithoutImagesInput>
    connectOrCreate?: RoomTypeCreateOrConnectWithoutImagesInput
    connect?: RoomTypeWhereUniqueInput
  }

  export type HotelUpdateOneWithoutImagesNestedInput = {
    create?: XOR<HotelCreateWithoutImagesInput, HotelUncheckedCreateWithoutImagesInput>
    connectOrCreate?: HotelCreateOrConnectWithoutImagesInput
    upsert?: HotelUpsertWithoutImagesInput
    disconnect?: HotelWhereInput | boolean
    delete?: HotelWhereInput | boolean
    connect?: HotelWhereUniqueInput
    update?: XOR<XOR<HotelUpdateToOneWithWhereWithoutImagesInput, HotelUpdateWithoutImagesInput>, HotelUncheckedUpdateWithoutImagesInput>
  }

  export type RoomTypeUpdateOneWithoutImagesNestedInput = {
    create?: XOR<RoomTypeCreateWithoutImagesInput, RoomTypeUncheckedCreateWithoutImagesInput>
    connectOrCreate?: RoomTypeCreateOrConnectWithoutImagesInput
    upsert?: RoomTypeUpsertWithoutImagesInput
    disconnect?: RoomTypeWhereInput | boolean
    delete?: RoomTypeWhereInput | boolean
    connect?: RoomTypeWhereUniqueInput
    update?: XOR<XOR<RoomTypeUpdateToOneWithWhereWithoutImagesInput, RoomTypeUpdateWithoutImagesInput>, RoomTypeUncheckedUpdateWithoutImagesInput>
  }

  export type HotelAmenityCreateNestedManyWithoutAmenityInput = {
    create?: XOR<HotelAmenityCreateWithoutAmenityInput, HotelAmenityUncheckedCreateWithoutAmenityInput> | HotelAmenityCreateWithoutAmenityInput[] | HotelAmenityUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: HotelAmenityCreateOrConnectWithoutAmenityInput | HotelAmenityCreateOrConnectWithoutAmenityInput[]
    createMany?: HotelAmenityCreateManyAmenityInputEnvelope
    connect?: HotelAmenityWhereUniqueInput | HotelAmenityWhereUniqueInput[]
  }

  export type RoomTypeAmenityCreateNestedManyWithoutAmenityInput = {
    create?: XOR<RoomTypeAmenityCreateWithoutAmenityInput, RoomTypeAmenityUncheckedCreateWithoutAmenityInput> | RoomTypeAmenityCreateWithoutAmenityInput[] | RoomTypeAmenityUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: RoomTypeAmenityCreateOrConnectWithoutAmenityInput | RoomTypeAmenityCreateOrConnectWithoutAmenityInput[]
    createMany?: RoomTypeAmenityCreateManyAmenityInputEnvelope
    connect?: RoomTypeAmenityWhereUniqueInput | RoomTypeAmenityWhereUniqueInput[]
  }

  export type HotelAmenityUncheckedCreateNestedManyWithoutAmenityInput = {
    create?: XOR<HotelAmenityCreateWithoutAmenityInput, HotelAmenityUncheckedCreateWithoutAmenityInput> | HotelAmenityCreateWithoutAmenityInput[] | HotelAmenityUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: HotelAmenityCreateOrConnectWithoutAmenityInput | HotelAmenityCreateOrConnectWithoutAmenityInput[]
    createMany?: HotelAmenityCreateManyAmenityInputEnvelope
    connect?: HotelAmenityWhereUniqueInput | HotelAmenityWhereUniqueInput[]
  }

  export type RoomTypeAmenityUncheckedCreateNestedManyWithoutAmenityInput = {
    create?: XOR<RoomTypeAmenityCreateWithoutAmenityInput, RoomTypeAmenityUncheckedCreateWithoutAmenityInput> | RoomTypeAmenityCreateWithoutAmenityInput[] | RoomTypeAmenityUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: RoomTypeAmenityCreateOrConnectWithoutAmenityInput | RoomTypeAmenityCreateOrConnectWithoutAmenityInput[]
    createMany?: RoomTypeAmenityCreateManyAmenityInputEnvelope
    connect?: RoomTypeAmenityWhereUniqueInput | RoomTypeAmenityWhereUniqueInput[]
  }

  export type HotelAmenityUpdateManyWithoutAmenityNestedInput = {
    create?: XOR<HotelAmenityCreateWithoutAmenityInput, HotelAmenityUncheckedCreateWithoutAmenityInput> | HotelAmenityCreateWithoutAmenityInput[] | HotelAmenityUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: HotelAmenityCreateOrConnectWithoutAmenityInput | HotelAmenityCreateOrConnectWithoutAmenityInput[]
    upsert?: HotelAmenityUpsertWithWhereUniqueWithoutAmenityInput | HotelAmenityUpsertWithWhereUniqueWithoutAmenityInput[]
    createMany?: HotelAmenityCreateManyAmenityInputEnvelope
    set?: HotelAmenityWhereUniqueInput | HotelAmenityWhereUniqueInput[]
    disconnect?: HotelAmenityWhereUniqueInput | HotelAmenityWhereUniqueInput[]
    delete?: HotelAmenityWhereUniqueInput | HotelAmenityWhereUniqueInput[]
    connect?: HotelAmenityWhereUniqueInput | HotelAmenityWhereUniqueInput[]
    update?: HotelAmenityUpdateWithWhereUniqueWithoutAmenityInput | HotelAmenityUpdateWithWhereUniqueWithoutAmenityInput[]
    updateMany?: HotelAmenityUpdateManyWithWhereWithoutAmenityInput | HotelAmenityUpdateManyWithWhereWithoutAmenityInput[]
    deleteMany?: HotelAmenityScalarWhereInput | HotelAmenityScalarWhereInput[]
  }

  export type RoomTypeAmenityUpdateManyWithoutAmenityNestedInput = {
    create?: XOR<RoomTypeAmenityCreateWithoutAmenityInput, RoomTypeAmenityUncheckedCreateWithoutAmenityInput> | RoomTypeAmenityCreateWithoutAmenityInput[] | RoomTypeAmenityUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: RoomTypeAmenityCreateOrConnectWithoutAmenityInput | RoomTypeAmenityCreateOrConnectWithoutAmenityInput[]
    upsert?: RoomTypeAmenityUpsertWithWhereUniqueWithoutAmenityInput | RoomTypeAmenityUpsertWithWhereUniqueWithoutAmenityInput[]
    createMany?: RoomTypeAmenityCreateManyAmenityInputEnvelope
    set?: RoomTypeAmenityWhereUniqueInput | RoomTypeAmenityWhereUniqueInput[]
    disconnect?: RoomTypeAmenityWhereUniqueInput | RoomTypeAmenityWhereUniqueInput[]
    delete?: RoomTypeAmenityWhereUniqueInput | RoomTypeAmenityWhereUniqueInput[]
    connect?: RoomTypeAmenityWhereUniqueInput | RoomTypeAmenityWhereUniqueInput[]
    update?: RoomTypeAmenityUpdateWithWhereUniqueWithoutAmenityInput | RoomTypeAmenityUpdateWithWhereUniqueWithoutAmenityInput[]
    updateMany?: RoomTypeAmenityUpdateManyWithWhereWithoutAmenityInput | RoomTypeAmenityUpdateManyWithWhereWithoutAmenityInput[]
    deleteMany?: RoomTypeAmenityScalarWhereInput | RoomTypeAmenityScalarWhereInput[]
  }

  export type HotelAmenityUncheckedUpdateManyWithoutAmenityNestedInput = {
    create?: XOR<HotelAmenityCreateWithoutAmenityInput, HotelAmenityUncheckedCreateWithoutAmenityInput> | HotelAmenityCreateWithoutAmenityInput[] | HotelAmenityUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: HotelAmenityCreateOrConnectWithoutAmenityInput | HotelAmenityCreateOrConnectWithoutAmenityInput[]
    upsert?: HotelAmenityUpsertWithWhereUniqueWithoutAmenityInput | HotelAmenityUpsertWithWhereUniqueWithoutAmenityInput[]
    createMany?: HotelAmenityCreateManyAmenityInputEnvelope
    set?: HotelAmenityWhereUniqueInput | HotelAmenityWhereUniqueInput[]
    disconnect?: HotelAmenityWhereUniqueInput | HotelAmenityWhereUniqueInput[]
    delete?: HotelAmenityWhereUniqueInput | HotelAmenityWhereUniqueInput[]
    connect?: HotelAmenityWhereUniqueInput | HotelAmenityWhereUniqueInput[]
    update?: HotelAmenityUpdateWithWhereUniqueWithoutAmenityInput | HotelAmenityUpdateWithWhereUniqueWithoutAmenityInput[]
    updateMany?: HotelAmenityUpdateManyWithWhereWithoutAmenityInput | HotelAmenityUpdateManyWithWhereWithoutAmenityInput[]
    deleteMany?: HotelAmenityScalarWhereInput | HotelAmenityScalarWhereInput[]
  }

  export type RoomTypeAmenityUncheckedUpdateManyWithoutAmenityNestedInput = {
    create?: XOR<RoomTypeAmenityCreateWithoutAmenityInput, RoomTypeAmenityUncheckedCreateWithoutAmenityInput> | RoomTypeAmenityCreateWithoutAmenityInput[] | RoomTypeAmenityUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: RoomTypeAmenityCreateOrConnectWithoutAmenityInput | RoomTypeAmenityCreateOrConnectWithoutAmenityInput[]
    upsert?: RoomTypeAmenityUpsertWithWhereUniqueWithoutAmenityInput | RoomTypeAmenityUpsertWithWhereUniqueWithoutAmenityInput[]
    createMany?: RoomTypeAmenityCreateManyAmenityInputEnvelope
    set?: RoomTypeAmenityWhereUniqueInput | RoomTypeAmenityWhereUniqueInput[]
    disconnect?: RoomTypeAmenityWhereUniqueInput | RoomTypeAmenityWhereUniqueInput[]
    delete?: RoomTypeAmenityWhereUniqueInput | RoomTypeAmenityWhereUniqueInput[]
    connect?: RoomTypeAmenityWhereUniqueInput | RoomTypeAmenityWhereUniqueInput[]
    update?: RoomTypeAmenityUpdateWithWhereUniqueWithoutAmenityInput | RoomTypeAmenityUpdateWithWhereUniqueWithoutAmenityInput[]
    updateMany?: RoomTypeAmenityUpdateManyWithWhereWithoutAmenityInput | RoomTypeAmenityUpdateManyWithWhereWithoutAmenityInput[]
    deleteMany?: RoomTypeAmenityScalarWhereInput | RoomTypeAmenityScalarWhereInput[]
  }

  export type HotelCreateNestedOneWithoutAmenitiesInput = {
    create?: XOR<HotelCreateWithoutAmenitiesInput, HotelUncheckedCreateWithoutAmenitiesInput>
    connectOrCreate?: HotelCreateOrConnectWithoutAmenitiesInput
    connect?: HotelWhereUniqueInput
  }

  export type AmenityCreateNestedOneWithoutHotelsInput = {
    create?: XOR<AmenityCreateWithoutHotelsInput, AmenityUncheckedCreateWithoutHotelsInput>
    connectOrCreate?: AmenityCreateOrConnectWithoutHotelsInput
    connect?: AmenityWhereUniqueInput
  }

  export type HotelUpdateOneRequiredWithoutAmenitiesNestedInput = {
    create?: XOR<HotelCreateWithoutAmenitiesInput, HotelUncheckedCreateWithoutAmenitiesInput>
    connectOrCreate?: HotelCreateOrConnectWithoutAmenitiesInput
    upsert?: HotelUpsertWithoutAmenitiesInput
    connect?: HotelWhereUniqueInput
    update?: XOR<XOR<HotelUpdateToOneWithWhereWithoutAmenitiesInput, HotelUpdateWithoutAmenitiesInput>, HotelUncheckedUpdateWithoutAmenitiesInput>
  }

  export type AmenityUpdateOneRequiredWithoutHotelsNestedInput = {
    create?: XOR<AmenityCreateWithoutHotelsInput, AmenityUncheckedCreateWithoutHotelsInput>
    connectOrCreate?: AmenityCreateOrConnectWithoutHotelsInput
    upsert?: AmenityUpsertWithoutHotelsInput
    connect?: AmenityWhereUniqueInput
    update?: XOR<XOR<AmenityUpdateToOneWithWhereWithoutHotelsInput, AmenityUpdateWithoutHotelsInput>, AmenityUncheckedUpdateWithoutHotelsInput>
  }

  export type HotelCreateNestedOneWithoutRoomTypesInput = {
    create?: XOR<HotelCreateWithoutRoomTypesInput, HotelUncheckedCreateWithoutRoomTypesInput>
    connectOrCreate?: HotelCreateOrConnectWithoutRoomTypesInput
    connect?: HotelWhereUniqueInput
  }

  export type ImageCreateNestedManyWithoutRoomTypeInput = {
    create?: XOR<ImageCreateWithoutRoomTypeInput, ImageUncheckedCreateWithoutRoomTypeInput> | ImageCreateWithoutRoomTypeInput[] | ImageUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutRoomTypeInput | ImageCreateOrConnectWithoutRoomTypeInput[]
    createMany?: ImageCreateManyRoomTypeInputEnvelope
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
  }

  export type RoomTypeAmenityCreateNestedManyWithoutRoomTypeInput = {
    create?: XOR<RoomTypeAmenityCreateWithoutRoomTypeInput, RoomTypeAmenityUncheckedCreateWithoutRoomTypeInput> | RoomTypeAmenityCreateWithoutRoomTypeInput[] | RoomTypeAmenityUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: RoomTypeAmenityCreateOrConnectWithoutRoomTypeInput | RoomTypeAmenityCreateOrConnectWithoutRoomTypeInput[]
    createMany?: RoomTypeAmenityCreateManyRoomTypeInputEnvelope
    connect?: RoomTypeAmenityWhereUniqueInput | RoomTypeAmenityWhereUniqueInput[]
  }

  export type RoomCreateNestedManyWithoutRoomTypeInput = {
    create?: XOR<RoomCreateWithoutRoomTypeInput, RoomUncheckedCreateWithoutRoomTypeInput> | RoomCreateWithoutRoomTypeInput[] | RoomUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutRoomTypeInput | RoomCreateOrConnectWithoutRoomTypeInput[]
    createMany?: RoomCreateManyRoomTypeInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type RoomInventoryCreateNestedManyWithoutRoomTypeInput = {
    create?: XOR<RoomInventoryCreateWithoutRoomTypeInput, RoomInventoryUncheckedCreateWithoutRoomTypeInput> | RoomInventoryCreateWithoutRoomTypeInput[] | RoomInventoryUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: RoomInventoryCreateOrConnectWithoutRoomTypeInput | RoomInventoryCreateOrConnectWithoutRoomTypeInput[]
    createMany?: RoomInventoryCreateManyRoomTypeInputEnvelope
    connect?: RoomInventoryWhereUniqueInput | RoomInventoryWhereUniqueInput[]
  }

  export type RoomPriceCreateNestedManyWithoutRoomTypeInput = {
    create?: XOR<RoomPriceCreateWithoutRoomTypeInput, RoomPriceUncheckedCreateWithoutRoomTypeInput> | RoomPriceCreateWithoutRoomTypeInput[] | RoomPriceUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: RoomPriceCreateOrConnectWithoutRoomTypeInput | RoomPriceCreateOrConnectWithoutRoomTypeInput[]
    createMany?: RoomPriceCreateManyRoomTypeInputEnvelope
    connect?: RoomPriceWhereUniqueInput | RoomPriceWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutRoomTypeInput = {
    create?: XOR<BookingCreateWithoutRoomTypeInput, BookingUncheckedCreateWithoutRoomTypeInput> | BookingCreateWithoutRoomTypeInput[] | BookingUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutRoomTypeInput | BookingCreateOrConnectWithoutRoomTypeInput[]
    createMany?: BookingCreateManyRoomTypeInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type PromotionRoomTypeCreateNestedManyWithoutRoomTypeInput = {
    create?: XOR<PromotionRoomTypeCreateWithoutRoomTypeInput, PromotionRoomTypeUncheckedCreateWithoutRoomTypeInput> | PromotionRoomTypeCreateWithoutRoomTypeInput[] | PromotionRoomTypeUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: PromotionRoomTypeCreateOrConnectWithoutRoomTypeInput | PromotionRoomTypeCreateOrConnectWithoutRoomTypeInput[]
    createMany?: PromotionRoomTypeCreateManyRoomTypeInputEnvelope
    connect?: PromotionRoomTypeWhereUniqueInput | PromotionRoomTypeWhereUniqueInput[]
  }

  export type ImageUncheckedCreateNestedManyWithoutRoomTypeInput = {
    create?: XOR<ImageCreateWithoutRoomTypeInput, ImageUncheckedCreateWithoutRoomTypeInput> | ImageCreateWithoutRoomTypeInput[] | ImageUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutRoomTypeInput | ImageCreateOrConnectWithoutRoomTypeInput[]
    createMany?: ImageCreateManyRoomTypeInputEnvelope
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
  }

  export type RoomTypeAmenityUncheckedCreateNestedManyWithoutRoomTypeInput = {
    create?: XOR<RoomTypeAmenityCreateWithoutRoomTypeInput, RoomTypeAmenityUncheckedCreateWithoutRoomTypeInput> | RoomTypeAmenityCreateWithoutRoomTypeInput[] | RoomTypeAmenityUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: RoomTypeAmenityCreateOrConnectWithoutRoomTypeInput | RoomTypeAmenityCreateOrConnectWithoutRoomTypeInput[]
    createMany?: RoomTypeAmenityCreateManyRoomTypeInputEnvelope
    connect?: RoomTypeAmenityWhereUniqueInput | RoomTypeAmenityWhereUniqueInput[]
  }

  export type RoomUncheckedCreateNestedManyWithoutRoomTypeInput = {
    create?: XOR<RoomCreateWithoutRoomTypeInput, RoomUncheckedCreateWithoutRoomTypeInput> | RoomCreateWithoutRoomTypeInput[] | RoomUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutRoomTypeInput | RoomCreateOrConnectWithoutRoomTypeInput[]
    createMany?: RoomCreateManyRoomTypeInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type RoomInventoryUncheckedCreateNestedManyWithoutRoomTypeInput = {
    create?: XOR<RoomInventoryCreateWithoutRoomTypeInput, RoomInventoryUncheckedCreateWithoutRoomTypeInput> | RoomInventoryCreateWithoutRoomTypeInput[] | RoomInventoryUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: RoomInventoryCreateOrConnectWithoutRoomTypeInput | RoomInventoryCreateOrConnectWithoutRoomTypeInput[]
    createMany?: RoomInventoryCreateManyRoomTypeInputEnvelope
    connect?: RoomInventoryWhereUniqueInput | RoomInventoryWhereUniqueInput[]
  }

  export type RoomPriceUncheckedCreateNestedManyWithoutRoomTypeInput = {
    create?: XOR<RoomPriceCreateWithoutRoomTypeInput, RoomPriceUncheckedCreateWithoutRoomTypeInput> | RoomPriceCreateWithoutRoomTypeInput[] | RoomPriceUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: RoomPriceCreateOrConnectWithoutRoomTypeInput | RoomPriceCreateOrConnectWithoutRoomTypeInput[]
    createMany?: RoomPriceCreateManyRoomTypeInputEnvelope
    connect?: RoomPriceWhereUniqueInput | RoomPriceWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutRoomTypeInput = {
    create?: XOR<BookingCreateWithoutRoomTypeInput, BookingUncheckedCreateWithoutRoomTypeInput> | BookingCreateWithoutRoomTypeInput[] | BookingUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutRoomTypeInput | BookingCreateOrConnectWithoutRoomTypeInput[]
    createMany?: BookingCreateManyRoomTypeInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type PromotionRoomTypeUncheckedCreateNestedManyWithoutRoomTypeInput = {
    create?: XOR<PromotionRoomTypeCreateWithoutRoomTypeInput, PromotionRoomTypeUncheckedCreateWithoutRoomTypeInput> | PromotionRoomTypeCreateWithoutRoomTypeInput[] | PromotionRoomTypeUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: PromotionRoomTypeCreateOrConnectWithoutRoomTypeInput | PromotionRoomTypeCreateOrConnectWithoutRoomTypeInput[]
    createMany?: PromotionRoomTypeCreateManyRoomTypeInputEnvelope
    connect?: PromotionRoomTypeWhereUniqueInput | PromotionRoomTypeWhereUniqueInput[]
  }

  export type HotelUpdateOneRequiredWithoutRoomTypesNestedInput = {
    create?: XOR<HotelCreateWithoutRoomTypesInput, HotelUncheckedCreateWithoutRoomTypesInput>
    connectOrCreate?: HotelCreateOrConnectWithoutRoomTypesInput
    upsert?: HotelUpsertWithoutRoomTypesInput
    connect?: HotelWhereUniqueInput
    update?: XOR<XOR<HotelUpdateToOneWithWhereWithoutRoomTypesInput, HotelUpdateWithoutRoomTypesInput>, HotelUncheckedUpdateWithoutRoomTypesInput>
  }

  export type ImageUpdateManyWithoutRoomTypeNestedInput = {
    create?: XOR<ImageCreateWithoutRoomTypeInput, ImageUncheckedCreateWithoutRoomTypeInput> | ImageCreateWithoutRoomTypeInput[] | ImageUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutRoomTypeInput | ImageCreateOrConnectWithoutRoomTypeInput[]
    upsert?: ImageUpsertWithWhereUniqueWithoutRoomTypeInput | ImageUpsertWithWhereUniqueWithoutRoomTypeInput[]
    createMany?: ImageCreateManyRoomTypeInputEnvelope
    set?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    disconnect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    delete?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    update?: ImageUpdateWithWhereUniqueWithoutRoomTypeInput | ImageUpdateWithWhereUniqueWithoutRoomTypeInput[]
    updateMany?: ImageUpdateManyWithWhereWithoutRoomTypeInput | ImageUpdateManyWithWhereWithoutRoomTypeInput[]
    deleteMany?: ImageScalarWhereInput | ImageScalarWhereInput[]
  }

  export type RoomTypeAmenityUpdateManyWithoutRoomTypeNestedInput = {
    create?: XOR<RoomTypeAmenityCreateWithoutRoomTypeInput, RoomTypeAmenityUncheckedCreateWithoutRoomTypeInput> | RoomTypeAmenityCreateWithoutRoomTypeInput[] | RoomTypeAmenityUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: RoomTypeAmenityCreateOrConnectWithoutRoomTypeInput | RoomTypeAmenityCreateOrConnectWithoutRoomTypeInput[]
    upsert?: RoomTypeAmenityUpsertWithWhereUniqueWithoutRoomTypeInput | RoomTypeAmenityUpsertWithWhereUniqueWithoutRoomTypeInput[]
    createMany?: RoomTypeAmenityCreateManyRoomTypeInputEnvelope
    set?: RoomTypeAmenityWhereUniqueInput | RoomTypeAmenityWhereUniqueInput[]
    disconnect?: RoomTypeAmenityWhereUniqueInput | RoomTypeAmenityWhereUniqueInput[]
    delete?: RoomTypeAmenityWhereUniqueInput | RoomTypeAmenityWhereUniqueInput[]
    connect?: RoomTypeAmenityWhereUniqueInput | RoomTypeAmenityWhereUniqueInput[]
    update?: RoomTypeAmenityUpdateWithWhereUniqueWithoutRoomTypeInput | RoomTypeAmenityUpdateWithWhereUniqueWithoutRoomTypeInput[]
    updateMany?: RoomTypeAmenityUpdateManyWithWhereWithoutRoomTypeInput | RoomTypeAmenityUpdateManyWithWhereWithoutRoomTypeInput[]
    deleteMany?: RoomTypeAmenityScalarWhereInput | RoomTypeAmenityScalarWhereInput[]
  }

  export type RoomUpdateManyWithoutRoomTypeNestedInput = {
    create?: XOR<RoomCreateWithoutRoomTypeInput, RoomUncheckedCreateWithoutRoomTypeInput> | RoomCreateWithoutRoomTypeInput[] | RoomUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutRoomTypeInput | RoomCreateOrConnectWithoutRoomTypeInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutRoomTypeInput | RoomUpsertWithWhereUniqueWithoutRoomTypeInput[]
    createMany?: RoomCreateManyRoomTypeInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutRoomTypeInput | RoomUpdateWithWhereUniqueWithoutRoomTypeInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutRoomTypeInput | RoomUpdateManyWithWhereWithoutRoomTypeInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type RoomInventoryUpdateManyWithoutRoomTypeNestedInput = {
    create?: XOR<RoomInventoryCreateWithoutRoomTypeInput, RoomInventoryUncheckedCreateWithoutRoomTypeInput> | RoomInventoryCreateWithoutRoomTypeInput[] | RoomInventoryUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: RoomInventoryCreateOrConnectWithoutRoomTypeInput | RoomInventoryCreateOrConnectWithoutRoomTypeInput[]
    upsert?: RoomInventoryUpsertWithWhereUniqueWithoutRoomTypeInput | RoomInventoryUpsertWithWhereUniqueWithoutRoomTypeInput[]
    createMany?: RoomInventoryCreateManyRoomTypeInputEnvelope
    set?: RoomInventoryWhereUniqueInput | RoomInventoryWhereUniqueInput[]
    disconnect?: RoomInventoryWhereUniqueInput | RoomInventoryWhereUniqueInput[]
    delete?: RoomInventoryWhereUniqueInput | RoomInventoryWhereUniqueInput[]
    connect?: RoomInventoryWhereUniqueInput | RoomInventoryWhereUniqueInput[]
    update?: RoomInventoryUpdateWithWhereUniqueWithoutRoomTypeInput | RoomInventoryUpdateWithWhereUniqueWithoutRoomTypeInput[]
    updateMany?: RoomInventoryUpdateManyWithWhereWithoutRoomTypeInput | RoomInventoryUpdateManyWithWhereWithoutRoomTypeInput[]
    deleteMany?: RoomInventoryScalarWhereInput | RoomInventoryScalarWhereInput[]
  }

  export type RoomPriceUpdateManyWithoutRoomTypeNestedInput = {
    create?: XOR<RoomPriceCreateWithoutRoomTypeInput, RoomPriceUncheckedCreateWithoutRoomTypeInput> | RoomPriceCreateWithoutRoomTypeInput[] | RoomPriceUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: RoomPriceCreateOrConnectWithoutRoomTypeInput | RoomPriceCreateOrConnectWithoutRoomTypeInput[]
    upsert?: RoomPriceUpsertWithWhereUniqueWithoutRoomTypeInput | RoomPriceUpsertWithWhereUniqueWithoutRoomTypeInput[]
    createMany?: RoomPriceCreateManyRoomTypeInputEnvelope
    set?: RoomPriceWhereUniqueInput | RoomPriceWhereUniqueInput[]
    disconnect?: RoomPriceWhereUniqueInput | RoomPriceWhereUniqueInput[]
    delete?: RoomPriceWhereUniqueInput | RoomPriceWhereUniqueInput[]
    connect?: RoomPriceWhereUniqueInput | RoomPriceWhereUniqueInput[]
    update?: RoomPriceUpdateWithWhereUniqueWithoutRoomTypeInput | RoomPriceUpdateWithWhereUniqueWithoutRoomTypeInput[]
    updateMany?: RoomPriceUpdateManyWithWhereWithoutRoomTypeInput | RoomPriceUpdateManyWithWhereWithoutRoomTypeInput[]
    deleteMany?: RoomPriceScalarWhereInput | RoomPriceScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutRoomTypeNestedInput = {
    create?: XOR<BookingCreateWithoutRoomTypeInput, BookingUncheckedCreateWithoutRoomTypeInput> | BookingCreateWithoutRoomTypeInput[] | BookingUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutRoomTypeInput | BookingCreateOrConnectWithoutRoomTypeInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutRoomTypeInput | BookingUpsertWithWhereUniqueWithoutRoomTypeInput[]
    createMany?: BookingCreateManyRoomTypeInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutRoomTypeInput | BookingUpdateWithWhereUniqueWithoutRoomTypeInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutRoomTypeInput | BookingUpdateManyWithWhereWithoutRoomTypeInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type PromotionRoomTypeUpdateManyWithoutRoomTypeNestedInput = {
    create?: XOR<PromotionRoomTypeCreateWithoutRoomTypeInput, PromotionRoomTypeUncheckedCreateWithoutRoomTypeInput> | PromotionRoomTypeCreateWithoutRoomTypeInput[] | PromotionRoomTypeUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: PromotionRoomTypeCreateOrConnectWithoutRoomTypeInput | PromotionRoomTypeCreateOrConnectWithoutRoomTypeInput[]
    upsert?: PromotionRoomTypeUpsertWithWhereUniqueWithoutRoomTypeInput | PromotionRoomTypeUpsertWithWhereUniqueWithoutRoomTypeInput[]
    createMany?: PromotionRoomTypeCreateManyRoomTypeInputEnvelope
    set?: PromotionRoomTypeWhereUniqueInput | PromotionRoomTypeWhereUniqueInput[]
    disconnect?: PromotionRoomTypeWhereUniqueInput | PromotionRoomTypeWhereUniqueInput[]
    delete?: PromotionRoomTypeWhereUniqueInput | PromotionRoomTypeWhereUniqueInput[]
    connect?: PromotionRoomTypeWhereUniqueInput | PromotionRoomTypeWhereUniqueInput[]
    update?: PromotionRoomTypeUpdateWithWhereUniqueWithoutRoomTypeInput | PromotionRoomTypeUpdateWithWhereUniqueWithoutRoomTypeInput[]
    updateMany?: PromotionRoomTypeUpdateManyWithWhereWithoutRoomTypeInput | PromotionRoomTypeUpdateManyWithWhereWithoutRoomTypeInput[]
    deleteMany?: PromotionRoomTypeScalarWhereInput | PromotionRoomTypeScalarWhereInput[]
  }

  export type ImageUncheckedUpdateManyWithoutRoomTypeNestedInput = {
    create?: XOR<ImageCreateWithoutRoomTypeInput, ImageUncheckedCreateWithoutRoomTypeInput> | ImageCreateWithoutRoomTypeInput[] | ImageUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutRoomTypeInput | ImageCreateOrConnectWithoutRoomTypeInput[]
    upsert?: ImageUpsertWithWhereUniqueWithoutRoomTypeInput | ImageUpsertWithWhereUniqueWithoutRoomTypeInput[]
    createMany?: ImageCreateManyRoomTypeInputEnvelope
    set?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    disconnect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    delete?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    update?: ImageUpdateWithWhereUniqueWithoutRoomTypeInput | ImageUpdateWithWhereUniqueWithoutRoomTypeInput[]
    updateMany?: ImageUpdateManyWithWhereWithoutRoomTypeInput | ImageUpdateManyWithWhereWithoutRoomTypeInput[]
    deleteMany?: ImageScalarWhereInput | ImageScalarWhereInput[]
  }

  export type RoomTypeAmenityUncheckedUpdateManyWithoutRoomTypeNestedInput = {
    create?: XOR<RoomTypeAmenityCreateWithoutRoomTypeInput, RoomTypeAmenityUncheckedCreateWithoutRoomTypeInput> | RoomTypeAmenityCreateWithoutRoomTypeInput[] | RoomTypeAmenityUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: RoomTypeAmenityCreateOrConnectWithoutRoomTypeInput | RoomTypeAmenityCreateOrConnectWithoutRoomTypeInput[]
    upsert?: RoomTypeAmenityUpsertWithWhereUniqueWithoutRoomTypeInput | RoomTypeAmenityUpsertWithWhereUniqueWithoutRoomTypeInput[]
    createMany?: RoomTypeAmenityCreateManyRoomTypeInputEnvelope
    set?: RoomTypeAmenityWhereUniqueInput | RoomTypeAmenityWhereUniqueInput[]
    disconnect?: RoomTypeAmenityWhereUniqueInput | RoomTypeAmenityWhereUniqueInput[]
    delete?: RoomTypeAmenityWhereUniqueInput | RoomTypeAmenityWhereUniqueInput[]
    connect?: RoomTypeAmenityWhereUniqueInput | RoomTypeAmenityWhereUniqueInput[]
    update?: RoomTypeAmenityUpdateWithWhereUniqueWithoutRoomTypeInput | RoomTypeAmenityUpdateWithWhereUniqueWithoutRoomTypeInput[]
    updateMany?: RoomTypeAmenityUpdateManyWithWhereWithoutRoomTypeInput | RoomTypeAmenityUpdateManyWithWhereWithoutRoomTypeInput[]
    deleteMany?: RoomTypeAmenityScalarWhereInput | RoomTypeAmenityScalarWhereInput[]
  }

  export type RoomUncheckedUpdateManyWithoutRoomTypeNestedInput = {
    create?: XOR<RoomCreateWithoutRoomTypeInput, RoomUncheckedCreateWithoutRoomTypeInput> | RoomCreateWithoutRoomTypeInput[] | RoomUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutRoomTypeInput | RoomCreateOrConnectWithoutRoomTypeInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutRoomTypeInput | RoomUpsertWithWhereUniqueWithoutRoomTypeInput[]
    createMany?: RoomCreateManyRoomTypeInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutRoomTypeInput | RoomUpdateWithWhereUniqueWithoutRoomTypeInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutRoomTypeInput | RoomUpdateManyWithWhereWithoutRoomTypeInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type RoomInventoryUncheckedUpdateManyWithoutRoomTypeNestedInput = {
    create?: XOR<RoomInventoryCreateWithoutRoomTypeInput, RoomInventoryUncheckedCreateWithoutRoomTypeInput> | RoomInventoryCreateWithoutRoomTypeInput[] | RoomInventoryUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: RoomInventoryCreateOrConnectWithoutRoomTypeInput | RoomInventoryCreateOrConnectWithoutRoomTypeInput[]
    upsert?: RoomInventoryUpsertWithWhereUniqueWithoutRoomTypeInput | RoomInventoryUpsertWithWhereUniqueWithoutRoomTypeInput[]
    createMany?: RoomInventoryCreateManyRoomTypeInputEnvelope
    set?: RoomInventoryWhereUniqueInput | RoomInventoryWhereUniqueInput[]
    disconnect?: RoomInventoryWhereUniqueInput | RoomInventoryWhereUniqueInput[]
    delete?: RoomInventoryWhereUniqueInput | RoomInventoryWhereUniqueInput[]
    connect?: RoomInventoryWhereUniqueInput | RoomInventoryWhereUniqueInput[]
    update?: RoomInventoryUpdateWithWhereUniqueWithoutRoomTypeInput | RoomInventoryUpdateWithWhereUniqueWithoutRoomTypeInput[]
    updateMany?: RoomInventoryUpdateManyWithWhereWithoutRoomTypeInput | RoomInventoryUpdateManyWithWhereWithoutRoomTypeInput[]
    deleteMany?: RoomInventoryScalarWhereInput | RoomInventoryScalarWhereInput[]
  }

  export type RoomPriceUncheckedUpdateManyWithoutRoomTypeNestedInput = {
    create?: XOR<RoomPriceCreateWithoutRoomTypeInput, RoomPriceUncheckedCreateWithoutRoomTypeInput> | RoomPriceCreateWithoutRoomTypeInput[] | RoomPriceUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: RoomPriceCreateOrConnectWithoutRoomTypeInput | RoomPriceCreateOrConnectWithoutRoomTypeInput[]
    upsert?: RoomPriceUpsertWithWhereUniqueWithoutRoomTypeInput | RoomPriceUpsertWithWhereUniqueWithoutRoomTypeInput[]
    createMany?: RoomPriceCreateManyRoomTypeInputEnvelope
    set?: RoomPriceWhereUniqueInput | RoomPriceWhereUniqueInput[]
    disconnect?: RoomPriceWhereUniqueInput | RoomPriceWhereUniqueInput[]
    delete?: RoomPriceWhereUniqueInput | RoomPriceWhereUniqueInput[]
    connect?: RoomPriceWhereUniqueInput | RoomPriceWhereUniqueInput[]
    update?: RoomPriceUpdateWithWhereUniqueWithoutRoomTypeInput | RoomPriceUpdateWithWhereUniqueWithoutRoomTypeInput[]
    updateMany?: RoomPriceUpdateManyWithWhereWithoutRoomTypeInput | RoomPriceUpdateManyWithWhereWithoutRoomTypeInput[]
    deleteMany?: RoomPriceScalarWhereInput | RoomPriceScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutRoomTypeNestedInput = {
    create?: XOR<BookingCreateWithoutRoomTypeInput, BookingUncheckedCreateWithoutRoomTypeInput> | BookingCreateWithoutRoomTypeInput[] | BookingUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutRoomTypeInput | BookingCreateOrConnectWithoutRoomTypeInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutRoomTypeInput | BookingUpsertWithWhereUniqueWithoutRoomTypeInput[]
    createMany?: BookingCreateManyRoomTypeInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutRoomTypeInput | BookingUpdateWithWhereUniqueWithoutRoomTypeInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutRoomTypeInput | BookingUpdateManyWithWhereWithoutRoomTypeInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type PromotionRoomTypeUncheckedUpdateManyWithoutRoomTypeNestedInput = {
    create?: XOR<PromotionRoomTypeCreateWithoutRoomTypeInput, PromotionRoomTypeUncheckedCreateWithoutRoomTypeInput> | PromotionRoomTypeCreateWithoutRoomTypeInput[] | PromotionRoomTypeUncheckedCreateWithoutRoomTypeInput[]
    connectOrCreate?: PromotionRoomTypeCreateOrConnectWithoutRoomTypeInput | PromotionRoomTypeCreateOrConnectWithoutRoomTypeInput[]
    upsert?: PromotionRoomTypeUpsertWithWhereUniqueWithoutRoomTypeInput | PromotionRoomTypeUpsertWithWhereUniqueWithoutRoomTypeInput[]
    createMany?: PromotionRoomTypeCreateManyRoomTypeInputEnvelope
    set?: PromotionRoomTypeWhereUniqueInput | PromotionRoomTypeWhereUniqueInput[]
    disconnect?: PromotionRoomTypeWhereUniqueInput | PromotionRoomTypeWhereUniqueInput[]
    delete?: PromotionRoomTypeWhereUniqueInput | PromotionRoomTypeWhereUniqueInput[]
    connect?: PromotionRoomTypeWhereUniqueInput | PromotionRoomTypeWhereUniqueInput[]
    update?: PromotionRoomTypeUpdateWithWhereUniqueWithoutRoomTypeInput | PromotionRoomTypeUpdateWithWhereUniqueWithoutRoomTypeInput[]
    updateMany?: PromotionRoomTypeUpdateManyWithWhereWithoutRoomTypeInput | PromotionRoomTypeUpdateManyWithWhereWithoutRoomTypeInput[]
    deleteMany?: PromotionRoomTypeScalarWhereInput | PromotionRoomTypeScalarWhereInput[]
  }

  export type RoomTypeCreateNestedOneWithoutAmenitiesInput = {
    create?: XOR<RoomTypeCreateWithoutAmenitiesInput, RoomTypeUncheckedCreateWithoutAmenitiesInput>
    connectOrCreate?: RoomTypeCreateOrConnectWithoutAmenitiesInput
    connect?: RoomTypeWhereUniqueInput
  }

  export type AmenityCreateNestedOneWithoutRoomTypesInput = {
    create?: XOR<AmenityCreateWithoutRoomTypesInput, AmenityUncheckedCreateWithoutRoomTypesInput>
    connectOrCreate?: AmenityCreateOrConnectWithoutRoomTypesInput
    connect?: AmenityWhereUniqueInput
  }

  export type RoomTypeUpdateOneRequiredWithoutAmenitiesNestedInput = {
    create?: XOR<RoomTypeCreateWithoutAmenitiesInput, RoomTypeUncheckedCreateWithoutAmenitiesInput>
    connectOrCreate?: RoomTypeCreateOrConnectWithoutAmenitiesInput
    upsert?: RoomTypeUpsertWithoutAmenitiesInput
    connect?: RoomTypeWhereUniqueInput
    update?: XOR<XOR<RoomTypeUpdateToOneWithWhereWithoutAmenitiesInput, RoomTypeUpdateWithoutAmenitiesInput>, RoomTypeUncheckedUpdateWithoutAmenitiesInput>
  }

  export type AmenityUpdateOneRequiredWithoutRoomTypesNestedInput = {
    create?: XOR<AmenityCreateWithoutRoomTypesInput, AmenityUncheckedCreateWithoutRoomTypesInput>
    connectOrCreate?: AmenityCreateOrConnectWithoutRoomTypesInput
    upsert?: AmenityUpsertWithoutRoomTypesInput
    connect?: AmenityWhereUniqueInput
    update?: XOR<XOR<AmenityUpdateToOneWithWhereWithoutRoomTypesInput, AmenityUpdateWithoutRoomTypesInput>, AmenityUncheckedUpdateWithoutRoomTypesInput>
  }

  export type RoomTypeCreateNestedOneWithoutRoomsInput = {
    create?: XOR<RoomTypeCreateWithoutRoomsInput, RoomTypeUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: RoomTypeCreateOrConnectWithoutRoomsInput
    connect?: RoomTypeWhereUniqueInput
  }

  export type HotelCreateNestedOneWithoutRoomsInput = {
    create?: XOR<HotelCreateWithoutRoomsInput, HotelUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: HotelCreateOrConnectWithoutRoomsInput
    connect?: HotelWhereUniqueInput
  }

  export type EnumRoomStatusFieldUpdateOperationsInput = {
    set?: $Enums.RoomStatus
  }

  export type RoomTypeUpdateOneRequiredWithoutRoomsNestedInput = {
    create?: XOR<RoomTypeCreateWithoutRoomsInput, RoomTypeUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: RoomTypeCreateOrConnectWithoutRoomsInput
    upsert?: RoomTypeUpsertWithoutRoomsInput
    connect?: RoomTypeWhereUniqueInput
    update?: XOR<XOR<RoomTypeUpdateToOneWithWhereWithoutRoomsInput, RoomTypeUpdateWithoutRoomsInput>, RoomTypeUncheckedUpdateWithoutRoomsInput>
  }

  export type HotelUpdateOneWithoutRoomsNestedInput = {
    create?: XOR<HotelCreateWithoutRoomsInput, HotelUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: HotelCreateOrConnectWithoutRoomsInput
    upsert?: HotelUpsertWithoutRoomsInput
    disconnect?: HotelWhereInput | boolean
    delete?: HotelWhereInput | boolean
    connect?: HotelWhereUniqueInput
    update?: XOR<XOR<HotelUpdateToOneWithWhereWithoutRoomsInput, HotelUpdateWithoutRoomsInput>, HotelUncheckedUpdateWithoutRoomsInput>
  }

  export type RoomTypeCreateNestedOneWithoutInventoryInput = {
    create?: XOR<RoomTypeCreateWithoutInventoryInput, RoomTypeUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: RoomTypeCreateOrConnectWithoutInventoryInput
    connect?: RoomTypeWhereUniqueInput
  }

  export type HotelCreateNestedOneWithoutInventoryInput = {
    create?: XOR<HotelCreateWithoutInventoryInput, HotelUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: HotelCreateOrConnectWithoutInventoryInput
    connect?: HotelWhereUniqueInput
  }

  export type RoomTypeUpdateOneRequiredWithoutInventoryNestedInput = {
    create?: XOR<RoomTypeCreateWithoutInventoryInput, RoomTypeUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: RoomTypeCreateOrConnectWithoutInventoryInput
    upsert?: RoomTypeUpsertWithoutInventoryInput
    connect?: RoomTypeWhereUniqueInput
    update?: XOR<XOR<RoomTypeUpdateToOneWithWhereWithoutInventoryInput, RoomTypeUpdateWithoutInventoryInput>, RoomTypeUncheckedUpdateWithoutInventoryInput>
  }

  export type HotelUpdateOneWithoutInventoryNestedInput = {
    create?: XOR<HotelCreateWithoutInventoryInput, HotelUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: HotelCreateOrConnectWithoutInventoryInput
    upsert?: HotelUpsertWithoutInventoryInput
    disconnect?: HotelWhereInput | boolean
    delete?: HotelWhereInput | boolean
    connect?: HotelWhereUniqueInput
    update?: XOR<XOR<HotelUpdateToOneWithWhereWithoutInventoryInput, HotelUpdateWithoutInventoryInput>, HotelUncheckedUpdateWithoutInventoryInput>
  }

  export type RoomTypeCreateNestedOneWithoutPricesInput = {
    create?: XOR<RoomTypeCreateWithoutPricesInput, RoomTypeUncheckedCreateWithoutPricesInput>
    connectOrCreate?: RoomTypeCreateOrConnectWithoutPricesInput
    connect?: RoomTypeWhereUniqueInput
  }

  export type HotelCreateNestedOneWithoutPricesInput = {
    create?: XOR<HotelCreateWithoutPricesInput, HotelUncheckedCreateWithoutPricesInput>
    connectOrCreate?: HotelCreateOrConnectWithoutPricesInput
    connect?: HotelWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumCurrencyCodeFieldUpdateOperationsInput = {
    set?: $Enums.CurrencyCode
  }

  export type NullableEnumPriceTypeFieldUpdateOperationsInput = {
    set?: $Enums.PriceType | null
  }

  export type RoomTypeUpdateOneRequiredWithoutPricesNestedInput = {
    create?: XOR<RoomTypeCreateWithoutPricesInput, RoomTypeUncheckedCreateWithoutPricesInput>
    connectOrCreate?: RoomTypeCreateOrConnectWithoutPricesInput
    upsert?: RoomTypeUpsertWithoutPricesInput
    connect?: RoomTypeWhereUniqueInput
    update?: XOR<XOR<RoomTypeUpdateToOneWithWhereWithoutPricesInput, RoomTypeUpdateWithoutPricesInput>, RoomTypeUncheckedUpdateWithoutPricesInput>
  }

  export type HotelUpdateOneWithoutPricesNestedInput = {
    create?: XOR<HotelCreateWithoutPricesInput, HotelUncheckedCreateWithoutPricesInput>
    connectOrCreate?: HotelCreateOrConnectWithoutPricesInput
    upsert?: HotelUpsertWithoutPricesInput
    disconnect?: HotelWhereInput | boolean
    delete?: HotelWhereInput | boolean
    connect?: HotelWhereUniqueInput
    update?: XOR<XOR<HotelUpdateToOneWithWhereWithoutPricesInput, HotelUpdateWithoutPricesInput>, HotelUncheckedUpdateWithoutPricesInput>
  }

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type BookingCreateNestedManyWithoutUserInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type CancellationCreateNestedManyWithoutUserInput = {
    create?: XOR<CancellationCreateWithoutUserInput, CancellationUncheckedCreateWithoutUserInput> | CancellationCreateWithoutUserInput[] | CancellationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CancellationCreateOrConnectWithoutUserInput | CancellationCreateOrConnectWithoutUserInput[]
    createMany?: CancellationCreateManyUserInputEnvelope
    connect?: CancellationWhereUniqueInput | CancellationWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type CancellationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CancellationCreateWithoutUserInput, CancellationUncheckedCreateWithoutUserInput> | CancellationCreateWithoutUserInput[] | CancellationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CancellationCreateOrConnectWithoutUserInput | CancellationCreateOrConnectWithoutUserInput[]
    createMany?: CancellationCreateManyUserInputEnvelope
    connect?: CancellationWhereUniqueInput | CancellationWhereUniqueInput[]
  }

  export type RoleUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    upsert?: RoleUpsertWithoutUsersInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUsersInput, RoleUpdateWithoutUsersInput>, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type BookingUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutUserInput | BookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutUserInput | BookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutUserInput | BookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type CancellationUpdateManyWithoutUserNestedInput = {
    create?: XOR<CancellationCreateWithoutUserInput, CancellationUncheckedCreateWithoutUserInput> | CancellationCreateWithoutUserInput[] | CancellationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CancellationCreateOrConnectWithoutUserInput | CancellationCreateOrConnectWithoutUserInput[]
    upsert?: CancellationUpsertWithWhereUniqueWithoutUserInput | CancellationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CancellationCreateManyUserInputEnvelope
    set?: CancellationWhereUniqueInput | CancellationWhereUniqueInput[]
    disconnect?: CancellationWhereUniqueInput | CancellationWhereUniqueInput[]
    delete?: CancellationWhereUniqueInput | CancellationWhereUniqueInput[]
    connect?: CancellationWhereUniqueInput | CancellationWhereUniqueInput[]
    update?: CancellationUpdateWithWhereUniqueWithoutUserInput | CancellationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CancellationUpdateManyWithWhereWithoutUserInput | CancellationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CancellationScalarWhereInput | CancellationScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput> | BookingCreateWithoutUserInput[] | BookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutUserInput | BookingCreateOrConnectWithoutUserInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutUserInput | BookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookingCreateManyUserInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutUserInput | BookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutUserInput | BookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type CancellationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CancellationCreateWithoutUserInput, CancellationUncheckedCreateWithoutUserInput> | CancellationCreateWithoutUserInput[] | CancellationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CancellationCreateOrConnectWithoutUserInput | CancellationCreateOrConnectWithoutUserInput[]
    upsert?: CancellationUpsertWithWhereUniqueWithoutUserInput | CancellationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CancellationCreateManyUserInputEnvelope
    set?: CancellationWhereUniqueInput | CancellationWhereUniqueInput[]
    disconnect?: CancellationWhereUniqueInput | CancellationWhereUniqueInput[]
    delete?: CancellationWhereUniqueInput | CancellationWhereUniqueInput[]
    connect?: CancellationWhereUniqueInput | CancellationWhereUniqueInput[]
    update?: CancellationUpdateWithWhereUniqueWithoutUserInput | CancellationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CancellationUpdateManyWithWhereWithoutUserInput | CancellationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CancellationScalarWhereInput | CancellationScalarWhereInput[]
  }

  export type UserCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBookingsInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    connect?: UserWhereUniqueInput
  }

  export type RoomTypeCreateNestedOneWithoutBookingsInput = {
    create?: XOR<RoomTypeCreateWithoutBookingsInput, RoomTypeUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: RoomTypeCreateOrConnectWithoutBookingsInput
    connect?: RoomTypeWhereUniqueInput
  }

  export type PaymentCreateNestedOneWithoutBookingInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput
    connect?: PaymentWhereUniqueInput
  }

  export type ReviewCreateNestedOneWithoutBookingInput = {
    create?: XOR<ReviewCreateWithoutBookingInput, ReviewUncheckedCreateWithoutBookingInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutBookingInput
    connect?: ReviewWhereUniqueInput
  }

  export type PromotionCreateNestedOneWithoutBookingsInput = {
    create?: XOR<PromotionCreateWithoutBookingsInput, PromotionUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: PromotionCreateOrConnectWithoutBookingsInput
    connect?: PromotionWhereUniqueInput
  }

  export type CancellationPolicyCreateNestedOneWithoutBookingsInput = {
    create?: XOR<CancellationPolicyCreateWithoutBookingsInput, CancellationPolicyUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: CancellationPolicyCreateOrConnectWithoutBookingsInput
    connect?: CancellationPolicyWhereUniqueInput
  }

  export type CancellationCreateNestedOneWithoutBookingInput = {
    create?: XOR<CancellationCreateWithoutBookingInput, CancellationUncheckedCreateWithoutBookingInput>
    connectOrCreate?: CancellationCreateOrConnectWithoutBookingInput
    connect?: CancellationWhereUniqueInput
  }

  export type HotelCreateNestedOneWithoutBookingsInput = {
    create?: XOR<HotelCreateWithoutBookingsInput, HotelUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: HotelCreateOrConnectWithoutBookingsInput
    connect?: HotelWhereUniqueInput
  }

  export type PaymentUncheckedCreateNestedOneWithoutBookingInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput
    connect?: PaymentWhereUniqueInput
  }

  export type ReviewUncheckedCreateNestedOneWithoutBookingInput = {
    create?: XOR<ReviewCreateWithoutBookingInput, ReviewUncheckedCreateWithoutBookingInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutBookingInput
    connect?: ReviewWhereUniqueInput
  }

  export type CancellationUncheckedCreateNestedOneWithoutBookingInput = {
    create?: XOR<CancellationCreateWithoutBookingInput, CancellationUncheckedCreateWithoutBookingInput>
    connectOrCreate?: CancellationCreateOrConnectWithoutBookingInput
    connect?: CancellationWhereUniqueInput
  }

  export type EnumBookingStatusFieldUpdateOperationsInput = {
    set?: $Enums.BookingStatus
  }

  export type UserUpdateOneWithoutBookingsNestedInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    upsert?: UserUpsertWithoutBookingsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBookingsInput, UserUpdateWithoutBookingsInput>, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type RoomTypeUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<RoomTypeCreateWithoutBookingsInput, RoomTypeUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: RoomTypeCreateOrConnectWithoutBookingsInput
    upsert?: RoomTypeUpsertWithoutBookingsInput
    connect?: RoomTypeWhereUniqueInput
    update?: XOR<XOR<RoomTypeUpdateToOneWithWhereWithoutBookingsInput, RoomTypeUpdateWithoutBookingsInput>, RoomTypeUncheckedUpdateWithoutBookingsInput>
  }

  export type PaymentUpdateOneWithoutBookingNestedInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput
    upsert?: PaymentUpsertWithoutBookingInput
    disconnect?: PaymentWhereInput | boolean
    delete?: PaymentWhereInput | boolean
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutBookingInput, PaymentUpdateWithoutBookingInput>, PaymentUncheckedUpdateWithoutBookingInput>
  }

  export type ReviewUpdateOneWithoutBookingNestedInput = {
    create?: XOR<ReviewCreateWithoutBookingInput, ReviewUncheckedCreateWithoutBookingInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutBookingInput
    upsert?: ReviewUpsertWithoutBookingInput
    disconnect?: ReviewWhereInput | boolean
    delete?: ReviewWhereInput | boolean
    connect?: ReviewWhereUniqueInput
    update?: XOR<XOR<ReviewUpdateToOneWithWhereWithoutBookingInput, ReviewUpdateWithoutBookingInput>, ReviewUncheckedUpdateWithoutBookingInput>
  }

  export type PromotionUpdateOneWithoutBookingsNestedInput = {
    create?: XOR<PromotionCreateWithoutBookingsInput, PromotionUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: PromotionCreateOrConnectWithoutBookingsInput
    upsert?: PromotionUpsertWithoutBookingsInput
    disconnect?: PromotionWhereInput | boolean
    delete?: PromotionWhereInput | boolean
    connect?: PromotionWhereUniqueInput
    update?: XOR<XOR<PromotionUpdateToOneWithWhereWithoutBookingsInput, PromotionUpdateWithoutBookingsInput>, PromotionUncheckedUpdateWithoutBookingsInput>
  }

  export type CancellationPolicyUpdateOneWithoutBookingsNestedInput = {
    create?: XOR<CancellationPolicyCreateWithoutBookingsInput, CancellationPolicyUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: CancellationPolicyCreateOrConnectWithoutBookingsInput
    upsert?: CancellationPolicyUpsertWithoutBookingsInput
    disconnect?: CancellationPolicyWhereInput | boolean
    delete?: CancellationPolicyWhereInput | boolean
    connect?: CancellationPolicyWhereUniqueInput
    update?: XOR<XOR<CancellationPolicyUpdateToOneWithWhereWithoutBookingsInput, CancellationPolicyUpdateWithoutBookingsInput>, CancellationPolicyUncheckedUpdateWithoutBookingsInput>
  }

  export type CancellationUpdateOneWithoutBookingNestedInput = {
    create?: XOR<CancellationCreateWithoutBookingInput, CancellationUncheckedCreateWithoutBookingInput>
    connectOrCreate?: CancellationCreateOrConnectWithoutBookingInput
    upsert?: CancellationUpsertWithoutBookingInput
    disconnect?: CancellationWhereInput | boolean
    delete?: CancellationWhereInput | boolean
    connect?: CancellationWhereUniqueInput
    update?: XOR<XOR<CancellationUpdateToOneWithWhereWithoutBookingInput, CancellationUpdateWithoutBookingInput>, CancellationUncheckedUpdateWithoutBookingInput>
  }

  export type HotelUpdateOneWithoutBookingsNestedInput = {
    create?: XOR<HotelCreateWithoutBookingsInput, HotelUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: HotelCreateOrConnectWithoutBookingsInput
    upsert?: HotelUpsertWithoutBookingsInput
    disconnect?: HotelWhereInput | boolean
    delete?: HotelWhereInput | boolean
    connect?: HotelWhereUniqueInput
    update?: XOR<XOR<HotelUpdateToOneWithWhereWithoutBookingsInput, HotelUpdateWithoutBookingsInput>, HotelUncheckedUpdateWithoutBookingsInput>
  }

  export type PaymentUncheckedUpdateOneWithoutBookingNestedInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput
    upsert?: PaymentUpsertWithoutBookingInput
    disconnect?: PaymentWhereInput | boolean
    delete?: PaymentWhereInput | boolean
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutBookingInput, PaymentUpdateWithoutBookingInput>, PaymentUncheckedUpdateWithoutBookingInput>
  }

  export type ReviewUncheckedUpdateOneWithoutBookingNestedInput = {
    create?: XOR<ReviewCreateWithoutBookingInput, ReviewUncheckedCreateWithoutBookingInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutBookingInput
    upsert?: ReviewUpsertWithoutBookingInput
    disconnect?: ReviewWhereInput | boolean
    delete?: ReviewWhereInput | boolean
    connect?: ReviewWhereUniqueInput
    update?: XOR<XOR<ReviewUpdateToOneWithWhereWithoutBookingInput, ReviewUpdateWithoutBookingInput>, ReviewUncheckedUpdateWithoutBookingInput>
  }

  export type CancellationUncheckedUpdateOneWithoutBookingNestedInput = {
    create?: XOR<CancellationCreateWithoutBookingInput, CancellationUncheckedCreateWithoutBookingInput>
    connectOrCreate?: CancellationCreateOrConnectWithoutBookingInput
    upsert?: CancellationUpsertWithoutBookingInput
    disconnect?: CancellationWhereInput | boolean
    delete?: CancellationWhereInput | boolean
    connect?: CancellationWhereUniqueInput
    update?: XOR<XOR<CancellationUpdateToOneWithWhereWithoutBookingInput, CancellationUpdateWithoutBookingInput>, CancellationUncheckedUpdateWithoutBookingInput>
  }

  export type BookingCreateNestedOneWithoutPaymentInput = {
    create?: XOR<BookingCreateWithoutPaymentInput, BookingUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPaymentInput
    connect?: BookingWhereUniqueInput
  }

  export type TransactionCreateNestedManyWithoutPaymentInput = {
    create?: XOR<TransactionCreateWithoutPaymentInput, TransactionUncheckedCreateWithoutPaymentInput> | TransactionCreateWithoutPaymentInput[] | TransactionUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutPaymentInput | TransactionCreateOrConnectWithoutPaymentInput[]
    createMany?: TransactionCreateManyPaymentInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutPaymentInput = {
    create?: XOR<TransactionCreateWithoutPaymentInput, TransactionUncheckedCreateWithoutPaymentInput> | TransactionCreateWithoutPaymentInput[] | TransactionUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutPaymentInput | TransactionCreateOrConnectWithoutPaymentInput[]
    createMany?: TransactionCreateManyPaymentInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type NullableEnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod | null
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type BookingUpdateOneRequiredWithoutPaymentNestedInput = {
    create?: XOR<BookingCreateWithoutPaymentInput, BookingUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPaymentInput
    upsert?: BookingUpsertWithoutPaymentInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutPaymentInput, BookingUpdateWithoutPaymentInput>, BookingUncheckedUpdateWithoutPaymentInput>
  }

  export type TransactionUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<TransactionCreateWithoutPaymentInput, TransactionUncheckedCreateWithoutPaymentInput> | TransactionCreateWithoutPaymentInput[] | TransactionUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutPaymentInput | TransactionCreateOrConnectWithoutPaymentInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutPaymentInput | TransactionUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: TransactionCreateManyPaymentInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutPaymentInput | TransactionUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutPaymentInput | TransactionUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<TransactionCreateWithoutPaymentInput, TransactionUncheckedCreateWithoutPaymentInput> | TransactionCreateWithoutPaymentInput[] | TransactionUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutPaymentInput | TransactionCreateOrConnectWithoutPaymentInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutPaymentInput | TransactionUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: TransactionCreateManyPaymentInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutPaymentInput | TransactionUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutPaymentInput | TransactionUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type PaymentCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<PaymentCreateWithoutTransactionsInput, PaymentUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutTransactionsInput
    connect?: PaymentWhereUniqueInput
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType
  }

  export type EnumTransactionStatusFieldUpdateOperationsInput = {
    set?: $Enums.TransactionStatus
  }

  export type PaymentUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<PaymentCreateWithoutTransactionsInput, PaymentUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutTransactionsInput
    upsert?: PaymentUpsertWithoutTransactionsInput
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutTransactionsInput, PaymentUpdateWithoutTransactionsInput>, PaymentUncheckedUpdateWithoutTransactionsInput>
  }

  export type BookingCreateNestedOneWithoutReviewInput = {
    create?: XOR<BookingCreateWithoutReviewInput, BookingUncheckedCreateWithoutReviewInput>
    connectOrCreate?: BookingCreateOrConnectWithoutReviewInput
    connect?: BookingWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewsInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type HotelCreateNestedOneWithoutReviewsInput = {
    create?: XOR<HotelCreateWithoutReviewsInput, HotelUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: HotelCreateOrConnectWithoutReviewsInput
    connect?: HotelWhereUniqueInput
  }

  export type BookingUpdateOneRequiredWithoutReviewNestedInput = {
    create?: XOR<BookingCreateWithoutReviewInput, BookingUncheckedCreateWithoutReviewInput>
    connectOrCreate?: BookingCreateOrConnectWithoutReviewInput
    upsert?: BookingUpsertWithoutReviewInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutReviewInput, BookingUpdateWithoutReviewInput>, BookingUncheckedUpdateWithoutReviewInput>
  }

  export type UserUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    upsert?: UserUpsertWithoutReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewsInput, UserUpdateWithoutReviewsInput>, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type HotelUpdateOneWithoutReviewsNestedInput = {
    create?: XOR<HotelCreateWithoutReviewsInput, HotelUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: HotelCreateOrConnectWithoutReviewsInput
    upsert?: HotelUpsertWithoutReviewsInput
    disconnect?: HotelWhereInput | boolean
    delete?: HotelWhereInput | boolean
    connect?: HotelWhereUniqueInput
    update?: XOR<XOR<HotelUpdateToOneWithWhereWithoutReviewsInput, HotelUpdateWithoutReviewsInput>, HotelUncheckedUpdateWithoutReviewsInput>
  }

  export type BookingCreateNestedManyWithoutPromotionInput = {
    create?: XOR<BookingCreateWithoutPromotionInput, BookingUncheckedCreateWithoutPromotionInput> | BookingCreateWithoutPromotionInput[] | BookingUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutPromotionInput | BookingCreateOrConnectWithoutPromotionInput[]
    createMany?: BookingCreateManyPromotionInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type PromotionHotelCreateNestedManyWithoutPromotionInput = {
    create?: XOR<PromotionHotelCreateWithoutPromotionInput, PromotionHotelUncheckedCreateWithoutPromotionInput> | PromotionHotelCreateWithoutPromotionInput[] | PromotionHotelUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: PromotionHotelCreateOrConnectWithoutPromotionInput | PromotionHotelCreateOrConnectWithoutPromotionInput[]
    createMany?: PromotionHotelCreateManyPromotionInputEnvelope
    connect?: PromotionHotelWhereUniqueInput | PromotionHotelWhereUniqueInput[]
  }

  export type PromotionRoomTypeCreateNestedManyWithoutPromotionInput = {
    create?: XOR<PromotionRoomTypeCreateWithoutPromotionInput, PromotionRoomTypeUncheckedCreateWithoutPromotionInput> | PromotionRoomTypeCreateWithoutPromotionInput[] | PromotionRoomTypeUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: PromotionRoomTypeCreateOrConnectWithoutPromotionInput | PromotionRoomTypeCreateOrConnectWithoutPromotionInput[]
    createMany?: PromotionRoomTypeCreateManyPromotionInputEnvelope
    connect?: PromotionRoomTypeWhereUniqueInput | PromotionRoomTypeWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutPromotionInput = {
    create?: XOR<BookingCreateWithoutPromotionInput, BookingUncheckedCreateWithoutPromotionInput> | BookingCreateWithoutPromotionInput[] | BookingUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutPromotionInput | BookingCreateOrConnectWithoutPromotionInput[]
    createMany?: BookingCreateManyPromotionInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type PromotionHotelUncheckedCreateNestedManyWithoutPromotionInput = {
    create?: XOR<PromotionHotelCreateWithoutPromotionInput, PromotionHotelUncheckedCreateWithoutPromotionInput> | PromotionHotelCreateWithoutPromotionInput[] | PromotionHotelUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: PromotionHotelCreateOrConnectWithoutPromotionInput | PromotionHotelCreateOrConnectWithoutPromotionInput[]
    createMany?: PromotionHotelCreateManyPromotionInputEnvelope
    connect?: PromotionHotelWhereUniqueInput | PromotionHotelWhereUniqueInput[]
  }

  export type PromotionRoomTypeUncheckedCreateNestedManyWithoutPromotionInput = {
    create?: XOR<PromotionRoomTypeCreateWithoutPromotionInput, PromotionRoomTypeUncheckedCreateWithoutPromotionInput> | PromotionRoomTypeCreateWithoutPromotionInput[] | PromotionRoomTypeUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: PromotionRoomTypeCreateOrConnectWithoutPromotionInput | PromotionRoomTypeCreateOrConnectWithoutPromotionInput[]
    createMany?: PromotionRoomTypeCreateManyPromotionInputEnvelope
    connect?: PromotionRoomTypeWhereUniqueInput | PromotionRoomTypeWhereUniqueInput[]
  }

  export type EnumDiscountTypeFieldUpdateOperationsInput = {
    set?: $Enums.DiscountType
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type BookingUpdateManyWithoutPromotionNestedInput = {
    create?: XOR<BookingCreateWithoutPromotionInput, BookingUncheckedCreateWithoutPromotionInput> | BookingCreateWithoutPromotionInput[] | BookingUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutPromotionInput | BookingCreateOrConnectWithoutPromotionInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutPromotionInput | BookingUpsertWithWhereUniqueWithoutPromotionInput[]
    createMany?: BookingCreateManyPromotionInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutPromotionInput | BookingUpdateWithWhereUniqueWithoutPromotionInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutPromotionInput | BookingUpdateManyWithWhereWithoutPromotionInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type PromotionHotelUpdateManyWithoutPromotionNestedInput = {
    create?: XOR<PromotionHotelCreateWithoutPromotionInput, PromotionHotelUncheckedCreateWithoutPromotionInput> | PromotionHotelCreateWithoutPromotionInput[] | PromotionHotelUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: PromotionHotelCreateOrConnectWithoutPromotionInput | PromotionHotelCreateOrConnectWithoutPromotionInput[]
    upsert?: PromotionHotelUpsertWithWhereUniqueWithoutPromotionInput | PromotionHotelUpsertWithWhereUniqueWithoutPromotionInput[]
    createMany?: PromotionHotelCreateManyPromotionInputEnvelope
    set?: PromotionHotelWhereUniqueInput | PromotionHotelWhereUniqueInput[]
    disconnect?: PromotionHotelWhereUniqueInput | PromotionHotelWhereUniqueInput[]
    delete?: PromotionHotelWhereUniqueInput | PromotionHotelWhereUniqueInput[]
    connect?: PromotionHotelWhereUniqueInput | PromotionHotelWhereUniqueInput[]
    update?: PromotionHotelUpdateWithWhereUniqueWithoutPromotionInput | PromotionHotelUpdateWithWhereUniqueWithoutPromotionInput[]
    updateMany?: PromotionHotelUpdateManyWithWhereWithoutPromotionInput | PromotionHotelUpdateManyWithWhereWithoutPromotionInput[]
    deleteMany?: PromotionHotelScalarWhereInput | PromotionHotelScalarWhereInput[]
  }

  export type PromotionRoomTypeUpdateManyWithoutPromotionNestedInput = {
    create?: XOR<PromotionRoomTypeCreateWithoutPromotionInput, PromotionRoomTypeUncheckedCreateWithoutPromotionInput> | PromotionRoomTypeCreateWithoutPromotionInput[] | PromotionRoomTypeUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: PromotionRoomTypeCreateOrConnectWithoutPromotionInput | PromotionRoomTypeCreateOrConnectWithoutPromotionInput[]
    upsert?: PromotionRoomTypeUpsertWithWhereUniqueWithoutPromotionInput | PromotionRoomTypeUpsertWithWhereUniqueWithoutPromotionInput[]
    createMany?: PromotionRoomTypeCreateManyPromotionInputEnvelope
    set?: PromotionRoomTypeWhereUniqueInput | PromotionRoomTypeWhereUniqueInput[]
    disconnect?: PromotionRoomTypeWhereUniqueInput | PromotionRoomTypeWhereUniqueInput[]
    delete?: PromotionRoomTypeWhereUniqueInput | PromotionRoomTypeWhereUniqueInput[]
    connect?: PromotionRoomTypeWhereUniqueInput | PromotionRoomTypeWhereUniqueInput[]
    update?: PromotionRoomTypeUpdateWithWhereUniqueWithoutPromotionInput | PromotionRoomTypeUpdateWithWhereUniqueWithoutPromotionInput[]
    updateMany?: PromotionRoomTypeUpdateManyWithWhereWithoutPromotionInput | PromotionRoomTypeUpdateManyWithWhereWithoutPromotionInput[]
    deleteMany?: PromotionRoomTypeScalarWhereInput | PromotionRoomTypeScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutPromotionNestedInput = {
    create?: XOR<BookingCreateWithoutPromotionInput, BookingUncheckedCreateWithoutPromotionInput> | BookingCreateWithoutPromotionInput[] | BookingUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutPromotionInput | BookingCreateOrConnectWithoutPromotionInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutPromotionInput | BookingUpsertWithWhereUniqueWithoutPromotionInput[]
    createMany?: BookingCreateManyPromotionInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutPromotionInput | BookingUpdateWithWhereUniqueWithoutPromotionInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutPromotionInput | BookingUpdateManyWithWhereWithoutPromotionInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type PromotionHotelUncheckedUpdateManyWithoutPromotionNestedInput = {
    create?: XOR<PromotionHotelCreateWithoutPromotionInput, PromotionHotelUncheckedCreateWithoutPromotionInput> | PromotionHotelCreateWithoutPromotionInput[] | PromotionHotelUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: PromotionHotelCreateOrConnectWithoutPromotionInput | PromotionHotelCreateOrConnectWithoutPromotionInput[]
    upsert?: PromotionHotelUpsertWithWhereUniqueWithoutPromotionInput | PromotionHotelUpsertWithWhereUniqueWithoutPromotionInput[]
    createMany?: PromotionHotelCreateManyPromotionInputEnvelope
    set?: PromotionHotelWhereUniqueInput | PromotionHotelWhereUniqueInput[]
    disconnect?: PromotionHotelWhereUniqueInput | PromotionHotelWhereUniqueInput[]
    delete?: PromotionHotelWhereUniqueInput | PromotionHotelWhereUniqueInput[]
    connect?: PromotionHotelWhereUniqueInput | PromotionHotelWhereUniqueInput[]
    update?: PromotionHotelUpdateWithWhereUniqueWithoutPromotionInput | PromotionHotelUpdateWithWhereUniqueWithoutPromotionInput[]
    updateMany?: PromotionHotelUpdateManyWithWhereWithoutPromotionInput | PromotionHotelUpdateManyWithWhereWithoutPromotionInput[]
    deleteMany?: PromotionHotelScalarWhereInput | PromotionHotelScalarWhereInput[]
  }

  export type PromotionRoomTypeUncheckedUpdateManyWithoutPromotionNestedInput = {
    create?: XOR<PromotionRoomTypeCreateWithoutPromotionInput, PromotionRoomTypeUncheckedCreateWithoutPromotionInput> | PromotionRoomTypeCreateWithoutPromotionInput[] | PromotionRoomTypeUncheckedCreateWithoutPromotionInput[]
    connectOrCreate?: PromotionRoomTypeCreateOrConnectWithoutPromotionInput | PromotionRoomTypeCreateOrConnectWithoutPromotionInput[]
    upsert?: PromotionRoomTypeUpsertWithWhereUniqueWithoutPromotionInput | PromotionRoomTypeUpsertWithWhereUniqueWithoutPromotionInput[]
    createMany?: PromotionRoomTypeCreateManyPromotionInputEnvelope
    set?: PromotionRoomTypeWhereUniqueInput | PromotionRoomTypeWhereUniqueInput[]
    disconnect?: PromotionRoomTypeWhereUniqueInput | PromotionRoomTypeWhereUniqueInput[]
    delete?: PromotionRoomTypeWhereUniqueInput | PromotionRoomTypeWhereUniqueInput[]
    connect?: PromotionRoomTypeWhereUniqueInput | PromotionRoomTypeWhereUniqueInput[]
    update?: PromotionRoomTypeUpdateWithWhereUniqueWithoutPromotionInput | PromotionRoomTypeUpdateWithWhereUniqueWithoutPromotionInput[]
    updateMany?: PromotionRoomTypeUpdateManyWithWhereWithoutPromotionInput | PromotionRoomTypeUpdateManyWithWhereWithoutPromotionInput[]
    deleteMany?: PromotionRoomTypeScalarWhereInput | PromotionRoomTypeScalarWhereInput[]
  }

  export type BookingCreateNestedManyWithoutCancellationPolicyInput = {
    create?: XOR<BookingCreateWithoutCancellationPolicyInput, BookingUncheckedCreateWithoutCancellationPolicyInput> | BookingCreateWithoutCancellationPolicyInput[] | BookingUncheckedCreateWithoutCancellationPolicyInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutCancellationPolicyInput | BookingCreateOrConnectWithoutCancellationPolicyInput[]
    createMany?: BookingCreateManyCancellationPolicyInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type HotelCreateNestedOneWithoutPoliciesInput = {
    create?: XOR<HotelCreateWithoutPoliciesInput, HotelUncheckedCreateWithoutPoliciesInput>
    connectOrCreate?: HotelCreateOrConnectWithoutPoliciesInput
    connect?: HotelWhereUniqueInput
  }

  export type BookingUncheckedCreateNestedManyWithoutCancellationPolicyInput = {
    create?: XOR<BookingCreateWithoutCancellationPolicyInput, BookingUncheckedCreateWithoutCancellationPolicyInput> | BookingCreateWithoutCancellationPolicyInput[] | BookingUncheckedCreateWithoutCancellationPolicyInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutCancellationPolicyInput | BookingCreateOrConnectWithoutCancellationPolicyInput[]
    createMany?: BookingCreateManyCancellationPolicyInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BookingUpdateManyWithoutCancellationPolicyNestedInput = {
    create?: XOR<BookingCreateWithoutCancellationPolicyInput, BookingUncheckedCreateWithoutCancellationPolicyInput> | BookingCreateWithoutCancellationPolicyInput[] | BookingUncheckedCreateWithoutCancellationPolicyInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutCancellationPolicyInput | BookingCreateOrConnectWithoutCancellationPolicyInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutCancellationPolicyInput | BookingUpsertWithWhereUniqueWithoutCancellationPolicyInput[]
    createMany?: BookingCreateManyCancellationPolicyInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutCancellationPolicyInput | BookingUpdateWithWhereUniqueWithoutCancellationPolicyInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutCancellationPolicyInput | BookingUpdateManyWithWhereWithoutCancellationPolicyInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type HotelUpdateOneWithoutPoliciesNestedInput = {
    create?: XOR<HotelCreateWithoutPoliciesInput, HotelUncheckedCreateWithoutPoliciesInput>
    connectOrCreate?: HotelCreateOrConnectWithoutPoliciesInput
    upsert?: HotelUpsertWithoutPoliciesInput
    disconnect?: HotelWhereInput | boolean
    delete?: HotelWhereInput | boolean
    connect?: HotelWhereUniqueInput
    update?: XOR<XOR<HotelUpdateToOneWithWhereWithoutPoliciesInput, HotelUpdateWithoutPoliciesInput>, HotelUncheckedUpdateWithoutPoliciesInput>
  }

  export type BookingUncheckedUpdateManyWithoutCancellationPolicyNestedInput = {
    create?: XOR<BookingCreateWithoutCancellationPolicyInput, BookingUncheckedCreateWithoutCancellationPolicyInput> | BookingCreateWithoutCancellationPolicyInput[] | BookingUncheckedCreateWithoutCancellationPolicyInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutCancellationPolicyInput | BookingCreateOrConnectWithoutCancellationPolicyInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutCancellationPolicyInput | BookingUpsertWithWhereUniqueWithoutCancellationPolicyInput[]
    createMany?: BookingCreateManyCancellationPolicyInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutCancellationPolicyInput | BookingUpdateWithWhereUniqueWithoutCancellationPolicyInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutCancellationPolicyInput | BookingUpdateManyWithWhereWithoutCancellationPolicyInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BookingCreateNestedOneWithoutCancellationInput = {
    create?: XOR<BookingCreateWithoutCancellationInput, BookingUncheckedCreateWithoutCancellationInput>
    connectOrCreate?: BookingCreateOrConnectWithoutCancellationInput
    connect?: BookingWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCancellationsInput = {
    create?: XOR<UserCreateWithoutCancellationsInput, UserUncheckedCreateWithoutCancellationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCancellationsInput
    connect?: UserWhereUniqueInput
  }

  export type BookingUpdateOneRequiredWithoutCancellationNestedInput = {
    create?: XOR<BookingCreateWithoutCancellationInput, BookingUncheckedCreateWithoutCancellationInput>
    connectOrCreate?: BookingCreateOrConnectWithoutCancellationInput
    upsert?: BookingUpsertWithoutCancellationInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutCancellationInput, BookingUpdateWithoutCancellationInput>, BookingUncheckedUpdateWithoutCancellationInput>
  }

  export type UserUpdateOneWithoutCancellationsNestedInput = {
    create?: XOR<UserCreateWithoutCancellationsInput, UserUncheckedCreateWithoutCancellationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCancellationsInput
    upsert?: UserUpsertWithoutCancellationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCancellationsInput, UserUpdateWithoutCancellationsInput>, UserUncheckedUpdateWithoutCancellationsInput>
  }

  export type PromotionCreateNestedOneWithoutPromotionHotelInput = {
    create?: XOR<PromotionCreateWithoutPromotionHotelInput, PromotionUncheckedCreateWithoutPromotionHotelInput>
    connectOrCreate?: PromotionCreateOrConnectWithoutPromotionHotelInput
    connect?: PromotionWhereUniqueInput
  }

  export type HotelCreateNestedOneWithoutPromotionHotelInput = {
    create?: XOR<HotelCreateWithoutPromotionHotelInput, HotelUncheckedCreateWithoutPromotionHotelInput>
    connectOrCreate?: HotelCreateOrConnectWithoutPromotionHotelInput
    connect?: HotelWhereUniqueInput
  }

  export type PromotionUpdateOneRequiredWithoutPromotionHotelNestedInput = {
    create?: XOR<PromotionCreateWithoutPromotionHotelInput, PromotionUncheckedCreateWithoutPromotionHotelInput>
    connectOrCreate?: PromotionCreateOrConnectWithoutPromotionHotelInput
    upsert?: PromotionUpsertWithoutPromotionHotelInput
    connect?: PromotionWhereUniqueInput
    update?: XOR<XOR<PromotionUpdateToOneWithWhereWithoutPromotionHotelInput, PromotionUpdateWithoutPromotionHotelInput>, PromotionUncheckedUpdateWithoutPromotionHotelInput>
  }

  export type HotelUpdateOneRequiredWithoutPromotionHotelNestedInput = {
    create?: XOR<HotelCreateWithoutPromotionHotelInput, HotelUncheckedCreateWithoutPromotionHotelInput>
    connectOrCreate?: HotelCreateOrConnectWithoutPromotionHotelInput
    upsert?: HotelUpsertWithoutPromotionHotelInput
    connect?: HotelWhereUniqueInput
    update?: XOR<XOR<HotelUpdateToOneWithWhereWithoutPromotionHotelInput, HotelUpdateWithoutPromotionHotelInput>, HotelUncheckedUpdateWithoutPromotionHotelInput>
  }

  export type PromotionCreateNestedOneWithoutPromotionRoomTypeInput = {
    create?: XOR<PromotionCreateWithoutPromotionRoomTypeInput, PromotionUncheckedCreateWithoutPromotionRoomTypeInput>
    connectOrCreate?: PromotionCreateOrConnectWithoutPromotionRoomTypeInput
    connect?: PromotionWhereUniqueInput
  }

  export type RoomTypeCreateNestedOneWithoutPromotionRoomTypeInput = {
    create?: XOR<RoomTypeCreateWithoutPromotionRoomTypeInput, RoomTypeUncheckedCreateWithoutPromotionRoomTypeInput>
    connectOrCreate?: RoomTypeCreateOrConnectWithoutPromotionRoomTypeInput
    connect?: RoomTypeWhereUniqueInput
  }

  export type PromotionUpdateOneRequiredWithoutPromotionRoomTypeNestedInput = {
    create?: XOR<PromotionCreateWithoutPromotionRoomTypeInput, PromotionUncheckedCreateWithoutPromotionRoomTypeInput>
    connectOrCreate?: PromotionCreateOrConnectWithoutPromotionRoomTypeInput
    upsert?: PromotionUpsertWithoutPromotionRoomTypeInput
    connect?: PromotionWhereUniqueInput
    update?: XOR<XOR<PromotionUpdateToOneWithWhereWithoutPromotionRoomTypeInput, PromotionUpdateWithoutPromotionRoomTypeInput>, PromotionUncheckedUpdateWithoutPromotionRoomTypeInput>
  }

  export type RoomTypeUpdateOneRequiredWithoutPromotionRoomTypeNestedInput = {
    create?: XOR<RoomTypeCreateWithoutPromotionRoomTypeInput, RoomTypeUncheckedCreateWithoutPromotionRoomTypeInput>
    connectOrCreate?: RoomTypeCreateOrConnectWithoutPromotionRoomTypeInput
    upsert?: RoomTypeUpsertWithoutPromotionRoomTypeInput
    connect?: RoomTypeWhereUniqueInput
    update?: XOR<XOR<RoomTypeUpdateToOneWithWhereWithoutPromotionRoomTypeInput, RoomTypeUpdateWithoutPromotionRoomTypeInput>, RoomTypeUncheckedUpdateWithoutPromotionRoomTypeInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumRoomStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomStatus | EnumRoomStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RoomStatus[] | ListEnumRoomStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomStatus[] | ListEnumRoomStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomStatusFilter<$PrismaModel> | $Enums.RoomStatus
  }

  export type NestedEnumRoomStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomStatus | EnumRoomStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RoomStatus[] | ListEnumRoomStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomStatus[] | ListEnumRoomStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomStatusWithAggregatesFilter<$PrismaModel> | $Enums.RoomStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoomStatusFilter<$PrismaModel>
    _max?: NestedEnumRoomStatusFilter<$PrismaModel>
  }

  export type NestedEnumCurrencyCodeFilter<$PrismaModel = never> = {
    equals?: $Enums.CurrencyCode | EnumCurrencyCodeFieldRefInput<$PrismaModel>
    in?: $Enums.CurrencyCode[] | ListEnumCurrencyCodeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CurrencyCode[] | ListEnumCurrencyCodeFieldRefInput<$PrismaModel>
    not?: NestedEnumCurrencyCodeFilter<$PrismaModel> | $Enums.CurrencyCode
  }

  export type NestedEnumPriceTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PriceType | EnumPriceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PriceType[] | ListEnumPriceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PriceType[] | ListEnumPriceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPriceTypeNullableFilter<$PrismaModel> | $Enums.PriceType | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumCurrencyCodeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CurrencyCode | EnumCurrencyCodeFieldRefInput<$PrismaModel>
    in?: $Enums.CurrencyCode[] | ListEnumCurrencyCodeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CurrencyCode[] | ListEnumCurrencyCodeFieldRefInput<$PrismaModel>
    not?: NestedEnumCurrencyCodeWithAggregatesFilter<$PrismaModel> | $Enums.CurrencyCode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCurrencyCodeFilter<$PrismaModel>
    _max?: NestedEnumCurrencyCodeFilter<$PrismaModel>
  }

  export type NestedEnumPriceTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PriceType | EnumPriceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PriceType[] | ListEnumPriceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PriceType[] | ListEnumPriceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPriceTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PriceType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPriceTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumPriceTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableFilter<$PrismaModel> | $Enums.PaymentMethod | null
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type NestedEnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type NestedEnumDiscountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeFilter<$PrismaModel> | $Enums.DiscountType
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumDiscountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeWithAggregatesFilter<$PrismaModel> | $Enums.DiscountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscountTypeFilter<$PrismaModel>
    _max?: NestedEnumDiscountTypeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type AddressCreateWithoutHotelInput = {
    streetAddress: string
    city: string
    stateProvince?: string | null
    postalCode: string
    countryCode: string
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUncheckedCreateWithoutHotelInput = {
    id?: number
    streetAddress: string
    city: string
    stateProvince?: string | null
    postalCode: string
    countryCode: string
    latitude?: number | null
    longitude?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressCreateOrConnectWithoutHotelInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutHotelInput, AddressUncheckedCreateWithoutHotelInput>
  }

  export type ImageCreateWithoutHotelInput = {
    url: string
    altText?: string | null
    order?: number | null
    createdAt?: Date | string
    RoomType?: RoomTypeCreateNestedOneWithoutImagesInput
  }

  export type ImageUncheckedCreateWithoutHotelInput = {
    id?: number
    url: string
    altText?: string | null
    order?: number | null
    roomTypeId?: number | null
    createdAt?: Date | string
  }

  export type ImageCreateOrConnectWithoutHotelInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageCreateWithoutHotelInput, ImageUncheckedCreateWithoutHotelInput>
  }

  export type ImageCreateManyHotelInputEnvelope = {
    data: ImageCreateManyHotelInput | ImageCreateManyHotelInput[]
    skipDuplicates?: boolean
  }

  export type HotelAmenityCreateWithoutHotelInput = {
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    Amenity: AmenityCreateNestedOneWithoutHotelsInput
  }

  export type HotelAmenityUncheckedCreateWithoutHotelInput = {
    amenityId: number
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type HotelAmenityCreateOrConnectWithoutHotelInput = {
    where: HotelAmenityWhereUniqueInput
    create: XOR<HotelAmenityCreateWithoutHotelInput, HotelAmenityUncheckedCreateWithoutHotelInput>
  }

  export type HotelAmenityCreateManyHotelInputEnvelope = {
    data: HotelAmenityCreateManyHotelInput | HotelAmenityCreateManyHotelInput[]
    skipDuplicates?: boolean
  }

  export type RoomTypeCreateWithoutHotelInput = {
    name: string
    description?: string | null
    maxGuests: number
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ImageCreateNestedManyWithoutRoomTypeInput
    amenities?: RoomTypeAmenityCreateNestedManyWithoutRoomTypeInput
    rooms?: RoomCreateNestedManyWithoutRoomTypeInput
    inventory?: RoomInventoryCreateNestedManyWithoutRoomTypeInput
    prices?: RoomPriceCreateNestedManyWithoutRoomTypeInput
    bookings?: BookingCreateNestedManyWithoutRoomTypeInput
    PromotionRoomType?: PromotionRoomTypeCreateNestedManyWithoutRoomTypeInput
  }

  export type RoomTypeUncheckedCreateWithoutHotelInput = {
    id?: number
    name: string
    description?: string | null
    maxGuests: number
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ImageUncheckedCreateNestedManyWithoutRoomTypeInput
    amenities?: RoomTypeAmenityUncheckedCreateNestedManyWithoutRoomTypeInput
    rooms?: RoomUncheckedCreateNestedManyWithoutRoomTypeInput
    inventory?: RoomInventoryUncheckedCreateNestedManyWithoutRoomTypeInput
    prices?: RoomPriceUncheckedCreateNestedManyWithoutRoomTypeInput
    bookings?: BookingUncheckedCreateNestedManyWithoutRoomTypeInput
    PromotionRoomType?: PromotionRoomTypeUncheckedCreateNestedManyWithoutRoomTypeInput
  }

  export type RoomTypeCreateOrConnectWithoutHotelInput = {
    where: RoomTypeWhereUniqueInput
    create: XOR<RoomTypeCreateWithoutHotelInput, RoomTypeUncheckedCreateWithoutHotelInput>
  }

  export type RoomTypeCreateManyHotelInputEnvelope = {
    data: RoomTypeCreateManyHotelInput | RoomTypeCreateManyHotelInput[]
    skipDuplicates?: boolean
  }

  export type RoomCreateWithoutHotelInput = {
    roomNumber: string
    floor?: string | null
    status?: $Enums.RoomStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    RoomType: RoomTypeCreateNestedOneWithoutRoomsInput
  }

  export type RoomUncheckedCreateWithoutHotelInput = {
    id?: number
    roomTypeId: number
    roomNumber: string
    floor?: string | null
    status?: $Enums.RoomStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomCreateOrConnectWithoutHotelInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutHotelInput, RoomUncheckedCreateWithoutHotelInput>
  }

  export type RoomCreateManyHotelInputEnvelope = {
    data: RoomCreateManyHotelInput | RoomCreateManyHotelInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutHotelInput = {
    numberOfRooms?: number
    checkIn: Date | string
    checkOut: Date | string
    totalAmount?: number | null
    currency?: $Enums.CurrencyCode
    status?: $Enums.BookingStatus
    guestName?: string | null
    guestSurname?: string | null
    guestEmail?: string | null
    guestPhone?: string | null
    guestIdentity?: string | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    User?: UserCreateNestedOneWithoutBookingsInput
    RoomType: RoomTypeCreateNestedOneWithoutBookingsInput
    payment?: PaymentCreateNestedOneWithoutBookingInput
    review?: ReviewCreateNestedOneWithoutBookingInput
    Promotion?: PromotionCreateNestedOneWithoutBookingsInput
    CancellationPolicy?: CancellationPolicyCreateNestedOneWithoutBookingsInput
    cancellation?: CancellationCreateNestedOneWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutHotelInput = {
    id?: number
    userId?: number | null
    roomTypeId: number
    numberOfRooms?: number
    checkIn: Date | string
    checkOut: Date | string
    totalAmount?: number | null
    currency?: $Enums.CurrencyCode
    status?: $Enums.BookingStatus
    guestName?: string | null
    guestSurname?: string | null
    guestEmail?: string | null
    guestPhone?: string | null
    guestIdentity?: string | null
    promotionId?: number | null
    cancellationPolicyId?: number | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    payment?: PaymentUncheckedCreateNestedOneWithoutBookingInput
    review?: ReviewUncheckedCreateNestedOneWithoutBookingInput
    cancellation?: CancellationUncheckedCreateNestedOneWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutHotelInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutHotelInput, BookingUncheckedCreateWithoutHotelInput>
  }

  export type BookingCreateManyHotelInputEnvelope = {
    data: BookingCreateManyHotelInput | BookingCreateManyHotelInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutHotelInput = {
    rating: number
    title?: string | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Booking: BookingCreateNestedOneWithoutReviewInput
    User: UserCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutHotelInput = {
    id?: number
    bookingId: number
    userId: number
    rating: number
    title?: string | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutHotelInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutHotelInput, ReviewUncheckedCreateWithoutHotelInput>
  }

  export type ReviewCreateManyHotelInputEnvelope = {
    data: ReviewCreateManyHotelInput | ReviewCreateManyHotelInput[]
    skipDuplicates?: boolean
  }

  export type RoomInventoryCreateWithoutHotelInput = {
    date: Date | string
    totalInventory: number
    bookedCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    RoomType: RoomTypeCreateNestedOneWithoutInventoryInput
  }

  export type RoomInventoryUncheckedCreateWithoutHotelInput = {
    id?: number
    roomTypeId: number
    date: Date | string
    totalInventory: number
    bookedCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomInventoryCreateOrConnectWithoutHotelInput = {
    where: RoomInventoryWhereUniqueInput
    create: XOR<RoomInventoryCreateWithoutHotelInput, RoomInventoryUncheckedCreateWithoutHotelInput>
  }

  export type RoomInventoryCreateManyHotelInputEnvelope = {
    data: RoomInventoryCreateManyHotelInput | RoomInventoryCreateManyHotelInput[]
    skipDuplicates?: boolean
  }

  export type RoomPriceCreateWithoutHotelInput = {
    date: Date | string
    price: number
    currency?: $Enums.CurrencyCode
    priceType?: $Enums.PriceType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    RoomType: RoomTypeCreateNestedOneWithoutPricesInput
  }

  export type RoomPriceUncheckedCreateWithoutHotelInput = {
    id?: number
    roomTypeId: number
    date: Date | string
    price: number
    currency?: $Enums.CurrencyCode
    priceType?: $Enums.PriceType | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomPriceCreateOrConnectWithoutHotelInput = {
    where: RoomPriceWhereUniqueInput
    create: XOR<RoomPriceCreateWithoutHotelInput, RoomPriceUncheckedCreateWithoutHotelInput>
  }

  export type RoomPriceCreateManyHotelInputEnvelope = {
    data: RoomPriceCreateManyHotelInput | RoomPriceCreateManyHotelInput[]
    skipDuplicates?: boolean
  }

  export type CancellationPolicyCreateWithoutHotelInput = {
    name: string
    description?: string | null
    rules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutCancellationPolicyInput
  }

  export type CancellationPolicyUncheckedCreateWithoutHotelInput = {
    id?: number
    name: string
    description?: string | null
    rules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutCancellationPolicyInput
  }

  export type CancellationPolicyCreateOrConnectWithoutHotelInput = {
    where: CancellationPolicyWhereUniqueInput
    create: XOR<CancellationPolicyCreateWithoutHotelInput, CancellationPolicyUncheckedCreateWithoutHotelInput>
  }

  export type CancellationPolicyCreateManyHotelInputEnvelope = {
    data: CancellationPolicyCreateManyHotelInput | CancellationPolicyCreateManyHotelInput[]
    skipDuplicates?: boolean
  }

  export type PromotionHotelCreateWithoutHotelInput = {
    createdAt?: Date | string
    Promotion: PromotionCreateNestedOneWithoutPromotionHotelInput
  }

  export type PromotionHotelUncheckedCreateWithoutHotelInput = {
    id?: number
    promotionId: number
    createdAt?: Date | string
  }

  export type PromotionHotelCreateOrConnectWithoutHotelInput = {
    where: PromotionHotelWhereUniqueInput
    create: XOR<PromotionHotelCreateWithoutHotelInput, PromotionHotelUncheckedCreateWithoutHotelInput>
  }

  export type PromotionHotelCreateManyHotelInputEnvelope = {
    data: PromotionHotelCreateManyHotelInput | PromotionHotelCreateManyHotelInput[]
    skipDuplicates?: boolean
  }

  export type AddressUpsertWithoutHotelInput = {
    update: XOR<AddressUpdateWithoutHotelInput, AddressUncheckedUpdateWithoutHotelInput>
    create: XOR<AddressCreateWithoutHotelInput, AddressUncheckedCreateWithoutHotelInput>
    where?: AddressWhereInput
  }

  export type AddressUpdateToOneWithWhereWithoutHotelInput = {
    where?: AddressWhereInput
    data: XOR<AddressUpdateWithoutHotelInput, AddressUncheckedUpdateWithoutHotelInput>
  }

  export type AddressUpdateWithoutHotelInput = {
    streetAddress?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    stateProvince?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    streetAddress?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    stateProvince?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageUpsertWithWhereUniqueWithoutHotelInput = {
    where: ImageWhereUniqueInput
    update: XOR<ImageUpdateWithoutHotelInput, ImageUncheckedUpdateWithoutHotelInput>
    create: XOR<ImageCreateWithoutHotelInput, ImageUncheckedCreateWithoutHotelInput>
  }

  export type ImageUpdateWithWhereUniqueWithoutHotelInput = {
    where: ImageWhereUniqueInput
    data: XOR<ImageUpdateWithoutHotelInput, ImageUncheckedUpdateWithoutHotelInput>
  }

  export type ImageUpdateManyWithWhereWithoutHotelInput = {
    where: ImageScalarWhereInput
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyWithoutHotelInput>
  }

  export type ImageScalarWhereInput = {
    AND?: ImageScalarWhereInput | ImageScalarWhereInput[]
    OR?: ImageScalarWhereInput[]
    NOT?: ImageScalarWhereInput | ImageScalarWhereInput[]
    id?: IntFilter<"Image"> | number
    url?: StringFilter<"Image"> | string
    altText?: StringNullableFilter<"Image"> | string | null
    order?: IntNullableFilter<"Image"> | number | null
    hotelId?: IntNullableFilter<"Image"> | number | null
    roomTypeId?: IntNullableFilter<"Image"> | number | null
    createdAt?: DateTimeFilter<"Image"> | Date | string
  }

  export type HotelAmenityUpsertWithWhereUniqueWithoutHotelInput = {
    where: HotelAmenityWhereUniqueInput
    update: XOR<HotelAmenityUpdateWithoutHotelInput, HotelAmenityUncheckedUpdateWithoutHotelInput>
    create: XOR<HotelAmenityCreateWithoutHotelInput, HotelAmenityUncheckedCreateWithoutHotelInput>
  }

  export type HotelAmenityUpdateWithWhereUniqueWithoutHotelInput = {
    where: HotelAmenityWhereUniqueInput
    data: XOR<HotelAmenityUpdateWithoutHotelInput, HotelAmenityUncheckedUpdateWithoutHotelInput>
  }

  export type HotelAmenityUpdateManyWithWhereWithoutHotelInput = {
    where: HotelAmenityScalarWhereInput
    data: XOR<HotelAmenityUpdateManyMutationInput, HotelAmenityUncheckedUpdateManyWithoutHotelInput>
  }

  export type HotelAmenityScalarWhereInput = {
    AND?: HotelAmenityScalarWhereInput | HotelAmenityScalarWhereInput[]
    OR?: HotelAmenityScalarWhereInput[]
    NOT?: HotelAmenityScalarWhereInput | HotelAmenityScalarWhereInput[]
    hotelId?: IntFilter<"HotelAmenity"> | number
    amenityId?: IntFilter<"HotelAmenity"> | number
    details?: JsonNullableFilter<"HotelAmenity">
    createdAt?: DateTimeFilter<"HotelAmenity"> | Date | string
  }

  export type RoomTypeUpsertWithWhereUniqueWithoutHotelInput = {
    where: RoomTypeWhereUniqueInput
    update: XOR<RoomTypeUpdateWithoutHotelInput, RoomTypeUncheckedUpdateWithoutHotelInput>
    create: XOR<RoomTypeCreateWithoutHotelInput, RoomTypeUncheckedCreateWithoutHotelInput>
  }

  export type RoomTypeUpdateWithWhereUniqueWithoutHotelInput = {
    where: RoomTypeWhereUniqueInput
    data: XOR<RoomTypeUpdateWithoutHotelInput, RoomTypeUncheckedUpdateWithoutHotelInput>
  }

  export type RoomTypeUpdateManyWithWhereWithoutHotelInput = {
    where: RoomTypeScalarWhereInput
    data: XOR<RoomTypeUpdateManyMutationInput, RoomTypeUncheckedUpdateManyWithoutHotelInput>
  }

  export type RoomTypeScalarWhereInput = {
    AND?: RoomTypeScalarWhereInput | RoomTypeScalarWhereInput[]
    OR?: RoomTypeScalarWhereInput[]
    NOT?: RoomTypeScalarWhereInput | RoomTypeScalarWhereInput[]
    id?: IntFilter<"RoomType"> | number
    hotelId?: IntFilter<"RoomType"> | number
    name?: StringFilter<"RoomType"> | string
    description?: StringNullableFilter<"RoomType"> | string | null
    maxGuests?: IntFilter<"RoomType"> | number
    createdAt?: DateTimeFilter<"RoomType"> | Date | string
    updatedAt?: DateTimeFilter<"RoomType"> | Date | string
  }

  export type RoomUpsertWithWhereUniqueWithoutHotelInput = {
    where: RoomWhereUniqueInput
    update: XOR<RoomUpdateWithoutHotelInput, RoomUncheckedUpdateWithoutHotelInput>
    create: XOR<RoomCreateWithoutHotelInput, RoomUncheckedCreateWithoutHotelInput>
  }

  export type RoomUpdateWithWhereUniqueWithoutHotelInput = {
    where: RoomWhereUniqueInput
    data: XOR<RoomUpdateWithoutHotelInput, RoomUncheckedUpdateWithoutHotelInput>
  }

  export type RoomUpdateManyWithWhereWithoutHotelInput = {
    where: RoomScalarWhereInput
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyWithoutHotelInput>
  }

  export type RoomScalarWhereInput = {
    AND?: RoomScalarWhereInput | RoomScalarWhereInput[]
    OR?: RoomScalarWhereInput[]
    NOT?: RoomScalarWhereInput | RoomScalarWhereInput[]
    id?: IntFilter<"Room"> | number
    roomTypeId?: IntFilter<"Room"> | number
    roomNumber?: StringFilter<"Room"> | string
    floor?: StringNullableFilter<"Room"> | string | null
    status?: EnumRoomStatusFilter<"Room"> | $Enums.RoomStatus
    createdAt?: DateTimeFilter<"Room"> | Date | string
    updatedAt?: DateTimeFilter<"Room"> | Date | string
    hotelId?: IntNullableFilter<"Room"> | number | null
  }

  export type BookingUpsertWithWhereUniqueWithoutHotelInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutHotelInput, BookingUncheckedUpdateWithoutHotelInput>
    create: XOR<BookingCreateWithoutHotelInput, BookingUncheckedCreateWithoutHotelInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutHotelInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutHotelInput, BookingUncheckedUpdateWithoutHotelInput>
  }

  export type BookingUpdateManyWithWhereWithoutHotelInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutHotelInput>
  }

  export type BookingScalarWhereInput = {
    AND?: BookingScalarWhereInput | BookingScalarWhereInput[]
    OR?: BookingScalarWhereInput[]
    NOT?: BookingScalarWhereInput | BookingScalarWhereInput[]
    id?: IntFilter<"Booking"> | number
    userId?: IntNullableFilter<"Booking"> | number | null
    roomTypeId?: IntFilter<"Booking"> | number
    numberOfRooms?: IntFilter<"Booking"> | number
    checkIn?: DateTimeFilter<"Booking"> | Date | string
    checkOut?: DateTimeFilter<"Booking"> | Date | string
    totalAmount?: FloatNullableFilter<"Booking"> | number | null
    currency?: EnumCurrencyCodeFilter<"Booking"> | $Enums.CurrencyCode
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    guestName?: StringNullableFilter<"Booking"> | string | null
    guestSurname?: StringNullableFilter<"Booking"> | string | null
    guestEmail?: StringNullableFilter<"Booking"> | string | null
    guestPhone?: StringNullableFilter<"Booking"> | string | null
    guestIdentity?: StringNullableFilter<"Booking"> | string | null
    promotionId?: IntNullableFilter<"Booking"> | number | null
    cancellationPolicyId?: IntNullableFilter<"Booking"> | number | null
    promotionSnapshot?: JsonNullableFilter<"Booking">
    policySnapshot?: JsonNullableFilter<"Booking">
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    hotelId?: IntNullableFilter<"Booking"> | number | null
  }

  export type ReviewUpsertWithWhereUniqueWithoutHotelInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutHotelInput, ReviewUncheckedUpdateWithoutHotelInput>
    create: XOR<ReviewCreateWithoutHotelInput, ReviewUncheckedCreateWithoutHotelInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutHotelInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutHotelInput, ReviewUncheckedUpdateWithoutHotelInput>
  }

  export type ReviewUpdateManyWithWhereWithoutHotelInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutHotelInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: IntFilter<"Review"> | number
    bookingId?: IntFilter<"Review"> | number
    userId?: IntFilter<"Review"> | number
    rating?: IntFilter<"Review"> | number
    title?: StringNullableFilter<"Review"> | string | null
    comment?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    hotelId?: IntNullableFilter<"Review"> | number | null
  }

  export type RoomInventoryUpsertWithWhereUniqueWithoutHotelInput = {
    where: RoomInventoryWhereUniqueInput
    update: XOR<RoomInventoryUpdateWithoutHotelInput, RoomInventoryUncheckedUpdateWithoutHotelInput>
    create: XOR<RoomInventoryCreateWithoutHotelInput, RoomInventoryUncheckedCreateWithoutHotelInput>
  }

  export type RoomInventoryUpdateWithWhereUniqueWithoutHotelInput = {
    where: RoomInventoryWhereUniqueInput
    data: XOR<RoomInventoryUpdateWithoutHotelInput, RoomInventoryUncheckedUpdateWithoutHotelInput>
  }

  export type RoomInventoryUpdateManyWithWhereWithoutHotelInput = {
    where: RoomInventoryScalarWhereInput
    data: XOR<RoomInventoryUpdateManyMutationInput, RoomInventoryUncheckedUpdateManyWithoutHotelInput>
  }

  export type RoomInventoryScalarWhereInput = {
    AND?: RoomInventoryScalarWhereInput | RoomInventoryScalarWhereInput[]
    OR?: RoomInventoryScalarWhereInput[]
    NOT?: RoomInventoryScalarWhereInput | RoomInventoryScalarWhereInput[]
    id?: IntFilter<"RoomInventory"> | number
    roomTypeId?: IntFilter<"RoomInventory"> | number
    date?: DateTimeFilter<"RoomInventory"> | Date | string
    totalInventory?: IntFilter<"RoomInventory"> | number
    bookedCount?: IntFilter<"RoomInventory"> | number
    createdAt?: DateTimeFilter<"RoomInventory"> | Date | string
    updatedAt?: DateTimeFilter<"RoomInventory"> | Date | string
    hotelId?: IntNullableFilter<"RoomInventory"> | number | null
  }

  export type RoomPriceUpsertWithWhereUniqueWithoutHotelInput = {
    where: RoomPriceWhereUniqueInput
    update: XOR<RoomPriceUpdateWithoutHotelInput, RoomPriceUncheckedUpdateWithoutHotelInput>
    create: XOR<RoomPriceCreateWithoutHotelInput, RoomPriceUncheckedCreateWithoutHotelInput>
  }

  export type RoomPriceUpdateWithWhereUniqueWithoutHotelInput = {
    where: RoomPriceWhereUniqueInput
    data: XOR<RoomPriceUpdateWithoutHotelInput, RoomPriceUncheckedUpdateWithoutHotelInput>
  }

  export type RoomPriceUpdateManyWithWhereWithoutHotelInput = {
    where: RoomPriceScalarWhereInput
    data: XOR<RoomPriceUpdateManyMutationInput, RoomPriceUncheckedUpdateManyWithoutHotelInput>
  }

  export type RoomPriceScalarWhereInput = {
    AND?: RoomPriceScalarWhereInput | RoomPriceScalarWhereInput[]
    OR?: RoomPriceScalarWhereInput[]
    NOT?: RoomPriceScalarWhereInput | RoomPriceScalarWhereInput[]
    id?: IntFilter<"RoomPrice"> | number
    roomTypeId?: IntFilter<"RoomPrice"> | number
    date?: DateTimeFilter<"RoomPrice"> | Date | string
    price?: FloatFilter<"RoomPrice"> | number
    currency?: EnumCurrencyCodeFilter<"RoomPrice"> | $Enums.CurrencyCode
    priceType?: EnumPriceTypeNullableFilter<"RoomPrice"> | $Enums.PriceType | null
    createdAt?: DateTimeFilter<"RoomPrice"> | Date | string
    updatedAt?: DateTimeFilter<"RoomPrice"> | Date | string
    hotelId?: IntNullableFilter<"RoomPrice"> | number | null
  }

  export type CancellationPolicyUpsertWithWhereUniqueWithoutHotelInput = {
    where: CancellationPolicyWhereUniqueInput
    update: XOR<CancellationPolicyUpdateWithoutHotelInput, CancellationPolicyUncheckedUpdateWithoutHotelInput>
    create: XOR<CancellationPolicyCreateWithoutHotelInput, CancellationPolicyUncheckedCreateWithoutHotelInput>
  }

  export type CancellationPolicyUpdateWithWhereUniqueWithoutHotelInput = {
    where: CancellationPolicyWhereUniqueInput
    data: XOR<CancellationPolicyUpdateWithoutHotelInput, CancellationPolicyUncheckedUpdateWithoutHotelInput>
  }

  export type CancellationPolicyUpdateManyWithWhereWithoutHotelInput = {
    where: CancellationPolicyScalarWhereInput
    data: XOR<CancellationPolicyUpdateManyMutationInput, CancellationPolicyUncheckedUpdateManyWithoutHotelInput>
  }

  export type CancellationPolicyScalarWhereInput = {
    AND?: CancellationPolicyScalarWhereInput | CancellationPolicyScalarWhereInput[]
    OR?: CancellationPolicyScalarWhereInput[]
    NOT?: CancellationPolicyScalarWhereInput | CancellationPolicyScalarWhereInput[]
    id?: IntFilter<"CancellationPolicy"> | number
    name?: StringFilter<"CancellationPolicy"> | string
    description?: StringNullableFilter<"CancellationPolicy"> | string | null
    rules?: JsonNullableFilter<"CancellationPolicy">
    createdAt?: DateTimeFilter<"CancellationPolicy"> | Date | string
    updatedAt?: DateTimeFilter<"CancellationPolicy"> | Date | string
    hotelId?: IntNullableFilter<"CancellationPolicy"> | number | null
  }

  export type PromotionHotelUpsertWithWhereUniqueWithoutHotelInput = {
    where: PromotionHotelWhereUniqueInput
    update: XOR<PromotionHotelUpdateWithoutHotelInput, PromotionHotelUncheckedUpdateWithoutHotelInput>
    create: XOR<PromotionHotelCreateWithoutHotelInput, PromotionHotelUncheckedCreateWithoutHotelInput>
  }

  export type PromotionHotelUpdateWithWhereUniqueWithoutHotelInput = {
    where: PromotionHotelWhereUniqueInput
    data: XOR<PromotionHotelUpdateWithoutHotelInput, PromotionHotelUncheckedUpdateWithoutHotelInput>
  }

  export type PromotionHotelUpdateManyWithWhereWithoutHotelInput = {
    where: PromotionHotelScalarWhereInput
    data: XOR<PromotionHotelUpdateManyMutationInput, PromotionHotelUncheckedUpdateManyWithoutHotelInput>
  }

  export type PromotionHotelScalarWhereInput = {
    AND?: PromotionHotelScalarWhereInput | PromotionHotelScalarWhereInput[]
    OR?: PromotionHotelScalarWhereInput[]
    NOT?: PromotionHotelScalarWhereInput | PromotionHotelScalarWhereInput[]
    id?: IntFilter<"PromotionHotel"> | number
    promotionId?: IntFilter<"PromotionHotel"> | number
    hotelId?: IntFilter<"PromotionHotel"> | number
    createdAt?: DateTimeFilter<"PromotionHotel"> | Date | string
  }

  export type HotelCreateWithoutAddressInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ImageCreateNestedManyWithoutHotelInput
    amenities?: HotelAmenityCreateNestedManyWithoutHotelInput
    roomTypes?: RoomTypeCreateNestedManyWithoutHotelInput
    rooms?: RoomCreateNestedManyWithoutHotelInput
    bookings?: BookingCreateNestedManyWithoutHotelInput
    reviews?: ReviewCreateNestedManyWithoutHotelInput
    inventory?: RoomInventoryCreateNestedManyWithoutHotelInput
    prices?: RoomPriceCreateNestedManyWithoutHotelInput
    policies?: CancellationPolicyCreateNestedManyWithoutHotelInput
    PromotionHotel?: PromotionHotelCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateWithoutAddressInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ImageUncheckedCreateNestedManyWithoutHotelInput
    amenities?: HotelAmenityUncheckedCreateNestedManyWithoutHotelInput
    roomTypes?: RoomTypeUncheckedCreateNestedManyWithoutHotelInput
    rooms?: RoomUncheckedCreateNestedManyWithoutHotelInput
    bookings?: BookingUncheckedCreateNestedManyWithoutHotelInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutHotelInput
    inventory?: RoomInventoryUncheckedCreateNestedManyWithoutHotelInput
    prices?: RoomPriceUncheckedCreateNestedManyWithoutHotelInput
    policies?: CancellationPolicyUncheckedCreateNestedManyWithoutHotelInput
    PromotionHotel?: PromotionHotelUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelCreateOrConnectWithoutAddressInput = {
    where: HotelWhereUniqueInput
    create: XOR<HotelCreateWithoutAddressInput, HotelUncheckedCreateWithoutAddressInput>
  }

  export type HotelUpsertWithoutAddressInput = {
    update: XOR<HotelUpdateWithoutAddressInput, HotelUncheckedUpdateWithoutAddressInput>
    create: XOR<HotelCreateWithoutAddressInput, HotelUncheckedCreateWithoutAddressInput>
    where?: HotelWhereInput
  }

  export type HotelUpdateToOneWithWhereWithoutAddressInput = {
    where?: HotelWhereInput
    data: XOR<HotelUpdateWithoutAddressInput, HotelUncheckedUpdateWithoutAddressInput>
  }

  export type HotelUpdateWithoutAddressInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ImageUpdateManyWithoutHotelNestedInput
    amenities?: HotelAmenityUpdateManyWithoutHotelNestedInput
    roomTypes?: RoomTypeUpdateManyWithoutHotelNestedInput
    rooms?: RoomUpdateManyWithoutHotelNestedInput
    bookings?: BookingUpdateManyWithoutHotelNestedInput
    reviews?: ReviewUpdateManyWithoutHotelNestedInput
    inventory?: RoomInventoryUpdateManyWithoutHotelNestedInput
    prices?: RoomPriceUpdateManyWithoutHotelNestedInput
    policies?: CancellationPolicyUpdateManyWithoutHotelNestedInput
    PromotionHotel?: PromotionHotelUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ImageUncheckedUpdateManyWithoutHotelNestedInput
    amenities?: HotelAmenityUncheckedUpdateManyWithoutHotelNestedInput
    roomTypes?: RoomTypeUncheckedUpdateManyWithoutHotelNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutHotelNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutHotelNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutHotelNestedInput
    inventory?: RoomInventoryUncheckedUpdateManyWithoutHotelNestedInput
    prices?: RoomPriceUncheckedUpdateManyWithoutHotelNestedInput
    policies?: CancellationPolicyUncheckedUpdateManyWithoutHotelNestedInput
    PromotionHotel?: PromotionHotelUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type HotelCreateWithoutImagesInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Address?: AddressCreateNestedOneWithoutHotelInput
    amenities?: HotelAmenityCreateNestedManyWithoutHotelInput
    roomTypes?: RoomTypeCreateNestedManyWithoutHotelInput
    rooms?: RoomCreateNestedManyWithoutHotelInput
    bookings?: BookingCreateNestedManyWithoutHotelInput
    reviews?: ReviewCreateNestedManyWithoutHotelInput
    inventory?: RoomInventoryCreateNestedManyWithoutHotelInput
    prices?: RoomPriceCreateNestedManyWithoutHotelInput
    policies?: CancellationPolicyCreateNestedManyWithoutHotelInput
    PromotionHotel?: PromotionHotelCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateWithoutImagesInput = {
    id?: number
    name: string
    description?: string | null
    addressId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    amenities?: HotelAmenityUncheckedCreateNestedManyWithoutHotelInput
    roomTypes?: RoomTypeUncheckedCreateNestedManyWithoutHotelInput
    rooms?: RoomUncheckedCreateNestedManyWithoutHotelInput
    bookings?: BookingUncheckedCreateNestedManyWithoutHotelInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutHotelInput
    inventory?: RoomInventoryUncheckedCreateNestedManyWithoutHotelInput
    prices?: RoomPriceUncheckedCreateNestedManyWithoutHotelInput
    policies?: CancellationPolicyUncheckedCreateNestedManyWithoutHotelInput
    PromotionHotel?: PromotionHotelUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelCreateOrConnectWithoutImagesInput = {
    where: HotelWhereUniqueInput
    create: XOR<HotelCreateWithoutImagesInput, HotelUncheckedCreateWithoutImagesInput>
  }

  export type RoomTypeCreateWithoutImagesInput = {
    name: string
    description?: string | null
    maxGuests: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Hotel: HotelCreateNestedOneWithoutRoomTypesInput
    amenities?: RoomTypeAmenityCreateNestedManyWithoutRoomTypeInput
    rooms?: RoomCreateNestedManyWithoutRoomTypeInput
    inventory?: RoomInventoryCreateNestedManyWithoutRoomTypeInput
    prices?: RoomPriceCreateNestedManyWithoutRoomTypeInput
    bookings?: BookingCreateNestedManyWithoutRoomTypeInput
    PromotionRoomType?: PromotionRoomTypeCreateNestedManyWithoutRoomTypeInput
  }

  export type RoomTypeUncheckedCreateWithoutImagesInput = {
    id?: number
    hotelId: number
    name: string
    description?: string | null
    maxGuests: number
    createdAt?: Date | string
    updatedAt?: Date | string
    amenities?: RoomTypeAmenityUncheckedCreateNestedManyWithoutRoomTypeInput
    rooms?: RoomUncheckedCreateNestedManyWithoutRoomTypeInput
    inventory?: RoomInventoryUncheckedCreateNestedManyWithoutRoomTypeInput
    prices?: RoomPriceUncheckedCreateNestedManyWithoutRoomTypeInput
    bookings?: BookingUncheckedCreateNestedManyWithoutRoomTypeInput
    PromotionRoomType?: PromotionRoomTypeUncheckedCreateNestedManyWithoutRoomTypeInput
  }

  export type RoomTypeCreateOrConnectWithoutImagesInput = {
    where: RoomTypeWhereUniqueInput
    create: XOR<RoomTypeCreateWithoutImagesInput, RoomTypeUncheckedCreateWithoutImagesInput>
  }

  export type HotelUpsertWithoutImagesInput = {
    update: XOR<HotelUpdateWithoutImagesInput, HotelUncheckedUpdateWithoutImagesInput>
    create: XOR<HotelCreateWithoutImagesInput, HotelUncheckedCreateWithoutImagesInput>
    where?: HotelWhereInput
  }

  export type HotelUpdateToOneWithWhereWithoutImagesInput = {
    where?: HotelWhereInput
    data: XOR<HotelUpdateWithoutImagesInput, HotelUncheckedUpdateWithoutImagesInput>
  }

  export type HotelUpdateWithoutImagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Address?: AddressUpdateOneWithoutHotelNestedInput
    amenities?: HotelAmenityUpdateManyWithoutHotelNestedInput
    roomTypes?: RoomTypeUpdateManyWithoutHotelNestedInput
    rooms?: RoomUpdateManyWithoutHotelNestedInput
    bookings?: BookingUpdateManyWithoutHotelNestedInput
    reviews?: ReviewUpdateManyWithoutHotelNestedInput
    inventory?: RoomInventoryUpdateManyWithoutHotelNestedInput
    prices?: RoomPriceUpdateManyWithoutHotelNestedInput
    policies?: CancellationPolicyUpdateManyWithoutHotelNestedInput
    PromotionHotel?: PromotionHotelUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateWithoutImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amenities?: HotelAmenityUncheckedUpdateManyWithoutHotelNestedInput
    roomTypes?: RoomTypeUncheckedUpdateManyWithoutHotelNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutHotelNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutHotelNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutHotelNestedInput
    inventory?: RoomInventoryUncheckedUpdateManyWithoutHotelNestedInput
    prices?: RoomPriceUncheckedUpdateManyWithoutHotelNestedInput
    policies?: CancellationPolicyUncheckedUpdateManyWithoutHotelNestedInput
    PromotionHotel?: PromotionHotelUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type RoomTypeUpsertWithoutImagesInput = {
    update: XOR<RoomTypeUpdateWithoutImagesInput, RoomTypeUncheckedUpdateWithoutImagesInput>
    create: XOR<RoomTypeCreateWithoutImagesInput, RoomTypeUncheckedCreateWithoutImagesInput>
    where?: RoomTypeWhereInput
  }

  export type RoomTypeUpdateToOneWithWhereWithoutImagesInput = {
    where?: RoomTypeWhereInput
    data: XOR<RoomTypeUpdateWithoutImagesInput, RoomTypeUncheckedUpdateWithoutImagesInput>
  }

  export type RoomTypeUpdateWithoutImagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Hotel?: HotelUpdateOneRequiredWithoutRoomTypesNestedInput
    amenities?: RoomTypeAmenityUpdateManyWithoutRoomTypeNestedInput
    rooms?: RoomUpdateManyWithoutRoomTypeNestedInput
    inventory?: RoomInventoryUpdateManyWithoutRoomTypeNestedInput
    prices?: RoomPriceUpdateManyWithoutRoomTypeNestedInput
    bookings?: BookingUpdateManyWithoutRoomTypeNestedInput
    PromotionRoomType?: PromotionRoomTypeUpdateManyWithoutRoomTypeNestedInput
  }

  export type RoomTypeUncheckedUpdateWithoutImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amenities?: RoomTypeAmenityUncheckedUpdateManyWithoutRoomTypeNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutRoomTypeNestedInput
    inventory?: RoomInventoryUncheckedUpdateManyWithoutRoomTypeNestedInput
    prices?: RoomPriceUncheckedUpdateManyWithoutRoomTypeNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutRoomTypeNestedInput
    PromotionRoomType?: PromotionRoomTypeUncheckedUpdateManyWithoutRoomTypeNestedInput
  }

  export type HotelAmenityCreateWithoutAmenityInput = {
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    Hotel: HotelCreateNestedOneWithoutAmenitiesInput
  }

  export type HotelAmenityUncheckedCreateWithoutAmenityInput = {
    hotelId: number
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type HotelAmenityCreateOrConnectWithoutAmenityInput = {
    where: HotelAmenityWhereUniqueInput
    create: XOR<HotelAmenityCreateWithoutAmenityInput, HotelAmenityUncheckedCreateWithoutAmenityInput>
  }

  export type HotelAmenityCreateManyAmenityInputEnvelope = {
    data: HotelAmenityCreateManyAmenityInput | HotelAmenityCreateManyAmenityInput[]
    skipDuplicates?: boolean
  }

  export type RoomTypeAmenityCreateWithoutAmenityInput = {
    createdAt?: Date | string
    RoomType: RoomTypeCreateNestedOneWithoutAmenitiesInput
  }

  export type RoomTypeAmenityUncheckedCreateWithoutAmenityInput = {
    roomTypeId: number
    createdAt?: Date | string
  }

  export type RoomTypeAmenityCreateOrConnectWithoutAmenityInput = {
    where: RoomTypeAmenityWhereUniqueInput
    create: XOR<RoomTypeAmenityCreateWithoutAmenityInput, RoomTypeAmenityUncheckedCreateWithoutAmenityInput>
  }

  export type RoomTypeAmenityCreateManyAmenityInputEnvelope = {
    data: RoomTypeAmenityCreateManyAmenityInput | RoomTypeAmenityCreateManyAmenityInput[]
    skipDuplicates?: boolean
  }

  export type HotelAmenityUpsertWithWhereUniqueWithoutAmenityInput = {
    where: HotelAmenityWhereUniqueInput
    update: XOR<HotelAmenityUpdateWithoutAmenityInput, HotelAmenityUncheckedUpdateWithoutAmenityInput>
    create: XOR<HotelAmenityCreateWithoutAmenityInput, HotelAmenityUncheckedCreateWithoutAmenityInput>
  }

  export type HotelAmenityUpdateWithWhereUniqueWithoutAmenityInput = {
    where: HotelAmenityWhereUniqueInput
    data: XOR<HotelAmenityUpdateWithoutAmenityInput, HotelAmenityUncheckedUpdateWithoutAmenityInput>
  }

  export type HotelAmenityUpdateManyWithWhereWithoutAmenityInput = {
    where: HotelAmenityScalarWhereInput
    data: XOR<HotelAmenityUpdateManyMutationInput, HotelAmenityUncheckedUpdateManyWithoutAmenityInput>
  }

  export type RoomTypeAmenityUpsertWithWhereUniqueWithoutAmenityInput = {
    where: RoomTypeAmenityWhereUniqueInput
    update: XOR<RoomTypeAmenityUpdateWithoutAmenityInput, RoomTypeAmenityUncheckedUpdateWithoutAmenityInput>
    create: XOR<RoomTypeAmenityCreateWithoutAmenityInput, RoomTypeAmenityUncheckedCreateWithoutAmenityInput>
  }

  export type RoomTypeAmenityUpdateWithWhereUniqueWithoutAmenityInput = {
    where: RoomTypeAmenityWhereUniqueInput
    data: XOR<RoomTypeAmenityUpdateWithoutAmenityInput, RoomTypeAmenityUncheckedUpdateWithoutAmenityInput>
  }

  export type RoomTypeAmenityUpdateManyWithWhereWithoutAmenityInput = {
    where: RoomTypeAmenityScalarWhereInput
    data: XOR<RoomTypeAmenityUpdateManyMutationInput, RoomTypeAmenityUncheckedUpdateManyWithoutAmenityInput>
  }

  export type RoomTypeAmenityScalarWhereInput = {
    AND?: RoomTypeAmenityScalarWhereInput | RoomTypeAmenityScalarWhereInput[]
    OR?: RoomTypeAmenityScalarWhereInput[]
    NOT?: RoomTypeAmenityScalarWhereInput | RoomTypeAmenityScalarWhereInput[]
    roomTypeId?: IntFilter<"RoomTypeAmenity"> | number
    amenityId?: IntFilter<"RoomTypeAmenity"> | number
    createdAt?: DateTimeFilter<"RoomTypeAmenity"> | Date | string
  }

  export type HotelCreateWithoutAmenitiesInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Address?: AddressCreateNestedOneWithoutHotelInput
    images?: ImageCreateNestedManyWithoutHotelInput
    roomTypes?: RoomTypeCreateNestedManyWithoutHotelInput
    rooms?: RoomCreateNestedManyWithoutHotelInput
    bookings?: BookingCreateNestedManyWithoutHotelInput
    reviews?: ReviewCreateNestedManyWithoutHotelInput
    inventory?: RoomInventoryCreateNestedManyWithoutHotelInput
    prices?: RoomPriceCreateNestedManyWithoutHotelInput
    policies?: CancellationPolicyCreateNestedManyWithoutHotelInput
    PromotionHotel?: PromotionHotelCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateWithoutAmenitiesInput = {
    id?: number
    name: string
    description?: string | null
    addressId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ImageUncheckedCreateNestedManyWithoutHotelInput
    roomTypes?: RoomTypeUncheckedCreateNestedManyWithoutHotelInput
    rooms?: RoomUncheckedCreateNestedManyWithoutHotelInput
    bookings?: BookingUncheckedCreateNestedManyWithoutHotelInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutHotelInput
    inventory?: RoomInventoryUncheckedCreateNestedManyWithoutHotelInput
    prices?: RoomPriceUncheckedCreateNestedManyWithoutHotelInput
    policies?: CancellationPolicyUncheckedCreateNestedManyWithoutHotelInput
    PromotionHotel?: PromotionHotelUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelCreateOrConnectWithoutAmenitiesInput = {
    where: HotelWhereUniqueInput
    create: XOR<HotelCreateWithoutAmenitiesInput, HotelUncheckedCreateWithoutAmenitiesInput>
  }

  export type AmenityCreateWithoutHotelsInput = {
    name: string
    description?: string | null
    category?: string | null
    createdAt?: Date | string
    roomTypes?: RoomTypeAmenityCreateNestedManyWithoutAmenityInput
  }

  export type AmenityUncheckedCreateWithoutHotelsInput = {
    id?: number
    name: string
    description?: string | null
    category?: string | null
    createdAt?: Date | string
    roomTypes?: RoomTypeAmenityUncheckedCreateNestedManyWithoutAmenityInput
  }

  export type AmenityCreateOrConnectWithoutHotelsInput = {
    where: AmenityWhereUniqueInput
    create: XOR<AmenityCreateWithoutHotelsInput, AmenityUncheckedCreateWithoutHotelsInput>
  }

  export type HotelUpsertWithoutAmenitiesInput = {
    update: XOR<HotelUpdateWithoutAmenitiesInput, HotelUncheckedUpdateWithoutAmenitiesInput>
    create: XOR<HotelCreateWithoutAmenitiesInput, HotelUncheckedCreateWithoutAmenitiesInput>
    where?: HotelWhereInput
  }

  export type HotelUpdateToOneWithWhereWithoutAmenitiesInput = {
    where?: HotelWhereInput
    data: XOR<HotelUpdateWithoutAmenitiesInput, HotelUncheckedUpdateWithoutAmenitiesInput>
  }

  export type HotelUpdateWithoutAmenitiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Address?: AddressUpdateOneWithoutHotelNestedInput
    images?: ImageUpdateManyWithoutHotelNestedInput
    roomTypes?: RoomTypeUpdateManyWithoutHotelNestedInput
    rooms?: RoomUpdateManyWithoutHotelNestedInput
    bookings?: BookingUpdateManyWithoutHotelNestedInput
    reviews?: ReviewUpdateManyWithoutHotelNestedInput
    inventory?: RoomInventoryUpdateManyWithoutHotelNestedInput
    prices?: RoomPriceUpdateManyWithoutHotelNestedInput
    policies?: CancellationPolicyUpdateManyWithoutHotelNestedInput
    PromotionHotel?: PromotionHotelUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateWithoutAmenitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ImageUncheckedUpdateManyWithoutHotelNestedInput
    roomTypes?: RoomTypeUncheckedUpdateManyWithoutHotelNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutHotelNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutHotelNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutHotelNestedInput
    inventory?: RoomInventoryUncheckedUpdateManyWithoutHotelNestedInput
    prices?: RoomPriceUncheckedUpdateManyWithoutHotelNestedInput
    policies?: CancellationPolicyUncheckedUpdateManyWithoutHotelNestedInput
    PromotionHotel?: PromotionHotelUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type AmenityUpsertWithoutHotelsInput = {
    update: XOR<AmenityUpdateWithoutHotelsInput, AmenityUncheckedUpdateWithoutHotelsInput>
    create: XOR<AmenityCreateWithoutHotelsInput, AmenityUncheckedCreateWithoutHotelsInput>
    where?: AmenityWhereInput
  }

  export type AmenityUpdateToOneWithWhereWithoutHotelsInput = {
    where?: AmenityWhereInput
    data: XOR<AmenityUpdateWithoutHotelsInput, AmenityUncheckedUpdateWithoutHotelsInput>
  }

  export type AmenityUpdateWithoutHotelsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roomTypes?: RoomTypeAmenityUpdateManyWithoutAmenityNestedInput
  }

  export type AmenityUncheckedUpdateWithoutHotelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roomTypes?: RoomTypeAmenityUncheckedUpdateManyWithoutAmenityNestedInput
  }

  export type HotelCreateWithoutRoomTypesInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Address?: AddressCreateNestedOneWithoutHotelInput
    images?: ImageCreateNestedManyWithoutHotelInput
    amenities?: HotelAmenityCreateNestedManyWithoutHotelInput
    rooms?: RoomCreateNestedManyWithoutHotelInput
    bookings?: BookingCreateNestedManyWithoutHotelInput
    reviews?: ReviewCreateNestedManyWithoutHotelInput
    inventory?: RoomInventoryCreateNestedManyWithoutHotelInput
    prices?: RoomPriceCreateNestedManyWithoutHotelInput
    policies?: CancellationPolicyCreateNestedManyWithoutHotelInput
    PromotionHotel?: PromotionHotelCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateWithoutRoomTypesInput = {
    id?: number
    name: string
    description?: string | null
    addressId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ImageUncheckedCreateNestedManyWithoutHotelInput
    amenities?: HotelAmenityUncheckedCreateNestedManyWithoutHotelInput
    rooms?: RoomUncheckedCreateNestedManyWithoutHotelInput
    bookings?: BookingUncheckedCreateNestedManyWithoutHotelInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutHotelInput
    inventory?: RoomInventoryUncheckedCreateNestedManyWithoutHotelInput
    prices?: RoomPriceUncheckedCreateNestedManyWithoutHotelInput
    policies?: CancellationPolicyUncheckedCreateNestedManyWithoutHotelInput
    PromotionHotel?: PromotionHotelUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelCreateOrConnectWithoutRoomTypesInput = {
    where: HotelWhereUniqueInput
    create: XOR<HotelCreateWithoutRoomTypesInput, HotelUncheckedCreateWithoutRoomTypesInput>
  }

  export type ImageCreateWithoutRoomTypeInput = {
    url: string
    altText?: string | null
    order?: number | null
    createdAt?: Date | string
    Hotel?: HotelCreateNestedOneWithoutImagesInput
  }

  export type ImageUncheckedCreateWithoutRoomTypeInput = {
    id?: number
    url: string
    altText?: string | null
    order?: number | null
    hotelId?: number | null
    createdAt?: Date | string
  }

  export type ImageCreateOrConnectWithoutRoomTypeInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageCreateWithoutRoomTypeInput, ImageUncheckedCreateWithoutRoomTypeInput>
  }

  export type ImageCreateManyRoomTypeInputEnvelope = {
    data: ImageCreateManyRoomTypeInput | ImageCreateManyRoomTypeInput[]
    skipDuplicates?: boolean
  }

  export type RoomTypeAmenityCreateWithoutRoomTypeInput = {
    createdAt?: Date | string
    Amenity: AmenityCreateNestedOneWithoutRoomTypesInput
  }

  export type RoomTypeAmenityUncheckedCreateWithoutRoomTypeInput = {
    amenityId: number
    createdAt?: Date | string
  }

  export type RoomTypeAmenityCreateOrConnectWithoutRoomTypeInput = {
    where: RoomTypeAmenityWhereUniqueInput
    create: XOR<RoomTypeAmenityCreateWithoutRoomTypeInput, RoomTypeAmenityUncheckedCreateWithoutRoomTypeInput>
  }

  export type RoomTypeAmenityCreateManyRoomTypeInputEnvelope = {
    data: RoomTypeAmenityCreateManyRoomTypeInput | RoomTypeAmenityCreateManyRoomTypeInput[]
    skipDuplicates?: boolean
  }

  export type RoomCreateWithoutRoomTypeInput = {
    roomNumber: string
    floor?: string | null
    status?: $Enums.RoomStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Hotel?: HotelCreateNestedOneWithoutRoomsInput
  }

  export type RoomUncheckedCreateWithoutRoomTypeInput = {
    id?: number
    roomNumber: string
    floor?: string | null
    status?: $Enums.RoomStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelId?: number | null
  }

  export type RoomCreateOrConnectWithoutRoomTypeInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutRoomTypeInput, RoomUncheckedCreateWithoutRoomTypeInput>
  }

  export type RoomCreateManyRoomTypeInputEnvelope = {
    data: RoomCreateManyRoomTypeInput | RoomCreateManyRoomTypeInput[]
    skipDuplicates?: boolean
  }

  export type RoomInventoryCreateWithoutRoomTypeInput = {
    date: Date | string
    totalInventory: number
    bookedCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Hotel?: HotelCreateNestedOneWithoutInventoryInput
  }

  export type RoomInventoryUncheckedCreateWithoutRoomTypeInput = {
    id?: number
    date: Date | string
    totalInventory: number
    bookedCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelId?: number | null
  }

  export type RoomInventoryCreateOrConnectWithoutRoomTypeInput = {
    where: RoomInventoryWhereUniqueInput
    create: XOR<RoomInventoryCreateWithoutRoomTypeInput, RoomInventoryUncheckedCreateWithoutRoomTypeInput>
  }

  export type RoomInventoryCreateManyRoomTypeInputEnvelope = {
    data: RoomInventoryCreateManyRoomTypeInput | RoomInventoryCreateManyRoomTypeInput[]
    skipDuplicates?: boolean
  }

  export type RoomPriceCreateWithoutRoomTypeInput = {
    date: Date | string
    price: number
    currency?: $Enums.CurrencyCode
    priceType?: $Enums.PriceType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Hotel?: HotelCreateNestedOneWithoutPricesInput
  }

  export type RoomPriceUncheckedCreateWithoutRoomTypeInput = {
    id?: number
    date: Date | string
    price: number
    currency?: $Enums.CurrencyCode
    priceType?: $Enums.PriceType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelId?: number | null
  }

  export type RoomPriceCreateOrConnectWithoutRoomTypeInput = {
    where: RoomPriceWhereUniqueInput
    create: XOR<RoomPriceCreateWithoutRoomTypeInput, RoomPriceUncheckedCreateWithoutRoomTypeInput>
  }

  export type RoomPriceCreateManyRoomTypeInputEnvelope = {
    data: RoomPriceCreateManyRoomTypeInput | RoomPriceCreateManyRoomTypeInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutRoomTypeInput = {
    numberOfRooms?: number
    checkIn: Date | string
    checkOut: Date | string
    totalAmount?: number | null
    currency?: $Enums.CurrencyCode
    status?: $Enums.BookingStatus
    guestName?: string | null
    guestSurname?: string | null
    guestEmail?: string | null
    guestPhone?: string | null
    guestIdentity?: string | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    User?: UserCreateNestedOneWithoutBookingsInput
    payment?: PaymentCreateNestedOneWithoutBookingInput
    review?: ReviewCreateNestedOneWithoutBookingInput
    Promotion?: PromotionCreateNestedOneWithoutBookingsInput
    CancellationPolicy?: CancellationPolicyCreateNestedOneWithoutBookingsInput
    cancellation?: CancellationCreateNestedOneWithoutBookingInput
    Hotel?: HotelCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateWithoutRoomTypeInput = {
    id?: number
    userId?: number | null
    numberOfRooms?: number
    checkIn: Date | string
    checkOut: Date | string
    totalAmount?: number | null
    currency?: $Enums.CurrencyCode
    status?: $Enums.BookingStatus
    guestName?: string | null
    guestSurname?: string | null
    guestEmail?: string | null
    guestPhone?: string | null
    guestIdentity?: string | null
    promotionId?: number | null
    cancellationPolicyId?: number | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelId?: number | null
    payment?: PaymentUncheckedCreateNestedOneWithoutBookingInput
    review?: ReviewUncheckedCreateNestedOneWithoutBookingInput
    cancellation?: CancellationUncheckedCreateNestedOneWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutRoomTypeInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutRoomTypeInput, BookingUncheckedCreateWithoutRoomTypeInput>
  }

  export type BookingCreateManyRoomTypeInputEnvelope = {
    data: BookingCreateManyRoomTypeInput | BookingCreateManyRoomTypeInput[]
    skipDuplicates?: boolean
  }

  export type PromotionRoomTypeCreateWithoutRoomTypeInput = {
    createdAt?: Date | string
    Promotion: PromotionCreateNestedOneWithoutPromotionRoomTypeInput
  }

  export type PromotionRoomTypeUncheckedCreateWithoutRoomTypeInput = {
    id?: number
    promotionId: number
    createdAt?: Date | string
  }

  export type PromotionRoomTypeCreateOrConnectWithoutRoomTypeInput = {
    where: PromotionRoomTypeWhereUniqueInput
    create: XOR<PromotionRoomTypeCreateWithoutRoomTypeInput, PromotionRoomTypeUncheckedCreateWithoutRoomTypeInput>
  }

  export type PromotionRoomTypeCreateManyRoomTypeInputEnvelope = {
    data: PromotionRoomTypeCreateManyRoomTypeInput | PromotionRoomTypeCreateManyRoomTypeInput[]
    skipDuplicates?: boolean
  }

  export type HotelUpsertWithoutRoomTypesInput = {
    update: XOR<HotelUpdateWithoutRoomTypesInput, HotelUncheckedUpdateWithoutRoomTypesInput>
    create: XOR<HotelCreateWithoutRoomTypesInput, HotelUncheckedCreateWithoutRoomTypesInput>
    where?: HotelWhereInput
  }

  export type HotelUpdateToOneWithWhereWithoutRoomTypesInput = {
    where?: HotelWhereInput
    data: XOR<HotelUpdateWithoutRoomTypesInput, HotelUncheckedUpdateWithoutRoomTypesInput>
  }

  export type HotelUpdateWithoutRoomTypesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Address?: AddressUpdateOneWithoutHotelNestedInput
    images?: ImageUpdateManyWithoutHotelNestedInput
    amenities?: HotelAmenityUpdateManyWithoutHotelNestedInput
    rooms?: RoomUpdateManyWithoutHotelNestedInput
    bookings?: BookingUpdateManyWithoutHotelNestedInput
    reviews?: ReviewUpdateManyWithoutHotelNestedInput
    inventory?: RoomInventoryUpdateManyWithoutHotelNestedInput
    prices?: RoomPriceUpdateManyWithoutHotelNestedInput
    policies?: CancellationPolicyUpdateManyWithoutHotelNestedInput
    PromotionHotel?: PromotionHotelUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateWithoutRoomTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ImageUncheckedUpdateManyWithoutHotelNestedInput
    amenities?: HotelAmenityUncheckedUpdateManyWithoutHotelNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutHotelNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutHotelNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutHotelNestedInput
    inventory?: RoomInventoryUncheckedUpdateManyWithoutHotelNestedInput
    prices?: RoomPriceUncheckedUpdateManyWithoutHotelNestedInput
    policies?: CancellationPolicyUncheckedUpdateManyWithoutHotelNestedInput
    PromotionHotel?: PromotionHotelUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type ImageUpsertWithWhereUniqueWithoutRoomTypeInput = {
    where: ImageWhereUniqueInput
    update: XOR<ImageUpdateWithoutRoomTypeInput, ImageUncheckedUpdateWithoutRoomTypeInput>
    create: XOR<ImageCreateWithoutRoomTypeInput, ImageUncheckedCreateWithoutRoomTypeInput>
  }

  export type ImageUpdateWithWhereUniqueWithoutRoomTypeInput = {
    where: ImageWhereUniqueInput
    data: XOR<ImageUpdateWithoutRoomTypeInput, ImageUncheckedUpdateWithoutRoomTypeInput>
  }

  export type ImageUpdateManyWithWhereWithoutRoomTypeInput = {
    where: ImageScalarWhereInput
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyWithoutRoomTypeInput>
  }

  export type RoomTypeAmenityUpsertWithWhereUniqueWithoutRoomTypeInput = {
    where: RoomTypeAmenityWhereUniqueInput
    update: XOR<RoomTypeAmenityUpdateWithoutRoomTypeInput, RoomTypeAmenityUncheckedUpdateWithoutRoomTypeInput>
    create: XOR<RoomTypeAmenityCreateWithoutRoomTypeInput, RoomTypeAmenityUncheckedCreateWithoutRoomTypeInput>
  }

  export type RoomTypeAmenityUpdateWithWhereUniqueWithoutRoomTypeInput = {
    where: RoomTypeAmenityWhereUniqueInput
    data: XOR<RoomTypeAmenityUpdateWithoutRoomTypeInput, RoomTypeAmenityUncheckedUpdateWithoutRoomTypeInput>
  }

  export type RoomTypeAmenityUpdateManyWithWhereWithoutRoomTypeInput = {
    where: RoomTypeAmenityScalarWhereInput
    data: XOR<RoomTypeAmenityUpdateManyMutationInput, RoomTypeAmenityUncheckedUpdateManyWithoutRoomTypeInput>
  }

  export type RoomUpsertWithWhereUniqueWithoutRoomTypeInput = {
    where: RoomWhereUniqueInput
    update: XOR<RoomUpdateWithoutRoomTypeInput, RoomUncheckedUpdateWithoutRoomTypeInput>
    create: XOR<RoomCreateWithoutRoomTypeInput, RoomUncheckedCreateWithoutRoomTypeInput>
  }

  export type RoomUpdateWithWhereUniqueWithoutRoomTypeInput = {
    where: RoomWhereUniqueInput
    data: XOR<RoomUpdateWithoutRoomTypeInput, RoomUncheckedUpdateWithoutRoomTypeInput>
  }

  export type RoomUpdateManyWithWhereWithoutRoomTypeInput = {
    where: RoomScalarWhereInput
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyWithoutRoomTypeInput>
  }

  export type RoomInventoryUpsertWithWhereUniqueWithoutRoomTypeInput = {
    where: RoomInventoryWhereUniqueInput
    update: XOR<RoomInventoryUpdateWithoutRoomTypeInput, RoomInventoryUncheckedUpdateWithoutRoomTypeInput>
    create: XOR<RoomInventoryCreateWithoutRoomTypeInput, RoomInventoryUncheckedCreateWithoutRoomTypeInput>
  }

  export type RoomInventoryUpdateWithWhereUniqueWithoutRoomTypeInput = {
    where: RoomInventoryWhereUniqueInput
    data: XOR<RoomInventoryUpdateWithoutRoomTypeInput, RoomInventoryUncheckedUpdateWithoutRoomTypeInput>
  }

  export type RoomInventoryUpdateManyWithWhereWithoutRoomTypeInput = {
    where: RoomInventoryScalarWhereInput
    data: XOR<RoomInventoryUpdateManyMutationInput, RoomInventoryUncheckedUpdateManyWithoutRoomTypeInput>
  }

  export type RoomPriceUpsertWithWhereUniqueWithoutRoomTypeInput = {
    where: RoomPriceWhereUniqueInput
    update: XOR<RoomPriceUpdateWithoutRoomTypeInput, RoomPriceUncheckedUpdateWithoutRoomTypeInput>
    create: XOR<RoomPriceCreateWithoutRoomTypeInput, RoomPriceUncheckedCreateWithoutRoomTypeInput>
  }

  export type RoomPriceUpdateWithWhereUniqueWithoutRoomTypeInput = {
    where: RoomPriceWhereUniqueInput
    data: XOR<RoomPriceUpdateWithoutRoomTypeInput, RoomPriceUncheckedUpdateWithoutRoomTypeInput>
  }

  export type RoomPriceUpdateManyWithWhereWithoutRoomTypeInput = {
    where: RoomPriceScalarWhereInput
    data: XOR<RoomPriceUpdateManyMutationInput, RoomPriceUncheckedUpdateManyWithoutRoomTypeInput>
  }

  export type BookingUpsertWithWhereUniqueWithoutRoomTypeInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutRoomTypeInput, BookingUncheckedUpdateWithoutRoomTypeInput>
    create: XOR<BookingCreateWithoutRoomTypeInput, BookingUncheckedCreateWithoutRoomTypeInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutRoomTypeInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutRoomTypeInput, BookingUncheckedUpdateWithoutRoomTypeInput>
  }

  export type BookingUpdateManyWithWhereWithoutRoomTypeInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutRoomTypeInput>
  }

  export type PromotionRoomTypeUpsertWithWhereUniqueWithoutRoomTypeInput = {
    where: PromotionRoomTypeWhereUniqueInput
    update: XOR<PromotionRoomTypeUpdateWithoutRoomTypeInput, PromotionRoomTypeUncheckedUpdateWithoutRoomTypeInput>
    create: XOR<PromotionRoomTypeCreateWithoutRoomTypeInput, PromotionRoomTypeUncheckedCreateWithoutRoomTypeInput>
  }

  export type PromotionRoomTypeUpdateWithWhereUniqueWithoutRoomTypeInput = {
    where: PromotionRoomTypeWhereUniqueInput
    data: XOR<PromotionRoomTypeUpdateWithoutRoomTypeInput, PromotionRoomTypeUncheckedUpdateWithoutRoomTypeInput>
  }

  export type PromotionRoomTypeUpdateManyWithWhereWithoutRoomTypeInput = {
    where: PromotionRoomTypeScalarWhereInput
    data: XOR<PromotionRoomTypeUpdateManyMutationInput, PromotionRoomTypeUncheckedUpdateManyWithoutRoomTypeInput>
  }

  export type PromotionRoomTypeScalarWhereInput = {
    AND?: PromotionRoomTypeScalarWhereInput | PromotionRoomTypeScalarWhereInput[]
    OR?: PromotionRoomTypeScalarWhereInput[]
    NOT?: PromotionRoomTypeScalarWhereInput | PromotionRoomTypeScalarWhereInput[]
    id?: IntFilter<"PromotionRoomType"> | number
    promotionId?: IntFilter<"PromotionRoomType"> | number
    roomTypeId?: IntFilter<"PromotionRoomType"> | number
    createdAt?: DateTimeFilter<"PromotionRoomType"> | Date | string
  }

  export type RoomTypeCreateWithoutAmenitiesInput = {
    name: string
    description?: string | null
    maxGuests: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Hotel: HotelCreateNestedOneWithoutRoomTypesInput
    images?: ImageCreateNestedManyWithoutRoomTypeInput
    rooms?: RoomCreateNestedManyWithoutRoomTypeInput
    inventory?: RoomInventoryCreateNestedManyWithoutRoomTypeInput
    prices?: RoomPriceCreateNestedManyWithoutRoomTypeInput
    bookings?: BookingCreateNestedManyWithoutRoomTypeInput
    PromotionRoomType?: PromotionRoomTypeCreateNestedManyWithoutRoomTypeInput
  }

  export type RoomTypeUncheckedCreateWithoutAmenitiesInput = {
    id?: number
    hotelId: number
    name: string
    description?: string | null
    maxGuests: number
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ImageUncheckedCreateNestedManyWithoutRoomTypeInput
    rooms?: RoomUncheckedCreateNestedManyWithoutRoomTypeInput
    inventory?: RoomInventoryUncheckedCreateNestedManyWithoutRoomTypeInput
    prices?: RoomPriceUncheckedCreateNestedManyWithoutRoomTypeInput
    bookings?: BookingUncheckedCreateNestedManyWithoutRoomTypeInput
    PromotionRoomType?: PromotionRoomTypeUncheckedCreateNestedManyWithoutRoomTypeInput
  }

  export type RoomTypeCreateOrConnectWithoutAmenitiesInput = {
    where: RoomTypeWhereUniqueInput
    create: XOR<RoomTypeCreateWithoutAmenitiesInput, RoomTypeUncheckedCreateWithoutAmenitiesInput>
  }

  export type AmenityCreateWithoutRoomTypesInput = {
    name: string
    description?: string | null
    category?: string | null
    createdAt?: Date | string
    hotels?: HotelAmenityCreateNestedManyWithoutAmenityInput
  }

  export type AmenityUncheckedCreateWithoutRoomTypesInput = {
    id?: number
    name: string
    description?: string | null
    category?: string | null
    createdAt?: Date | string
    hotels?: HotelAmenityUncheckedCreateNestedManyWithoutAmenityInput
  }

  export type AmenityCreateOrConnectWithoutRoomTypesInput = {
    where: AmenityWhereUniqueInput
    create: XOR<AmenityCreateWithoutRoomTypesInput, AmenityUncheckedCreateWithoutRoomTypesInput>
  }

  export type RoomTypeUpsertWithoutAmenitiesInput = {
    update: XOR<RoomTypeUpdateWithoutAmenitiesInput, RoomTypeUncheckedUpdateWithoutAmenitiesInput>
    create: XOR<RoomTypeCreateWithoutAmenitiesInput, RoomTypeUncheckedCreateWithoutAmenitiesInput>
    where?: RoomTypeWhereInput
  }

  export type RoomTypeUpdateToOneWithWhereWithoutAmenitiesInput = {
    where?: RoomTypeWhereInput
    data: XOR<RoomTypeUpdateWithoutAmenitiesInput, RoomTypeUncheckedUpdateWithoutAmenitiesInput>
  }

  export type RoomTypeUpdateWithoutAmenitiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Hotel?: HotelUpdateOneRequiredWithoutRoomTypesNestedInput
    images?: ImageUpdateManyWithoutRoomTypeNestedInput
    rooms?: RoomUpdateManyWithoutRoomTypeNestedInput
    inventory?: RoomInventoryUpdateManyWithoutRoomTypeNestedInput
    prices?: RoomPriceUpdateManyWithoutRoomTypeNestedInput
    bookings?: BookingUpdateManyWithoutRoomTypeNestedInput
    PromotionRoomType?: PromotionRoomTypeUpdateManyWithoutRoomTypeNestedInput
  }

  export type RoomTypeUncheckedUpdateWithoutAmenitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ImageUncheckedUpdateManyWithoutRoomTypeNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutRoomTypeNestedInput
    inventory?: RoomInventoryUncheckedUpdateManyWithoutRoomTypeNestedInput
    prices?: RoomPriceUncheckedUpdateManyWithoutRoomTypeNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutRoomTypeNestedInput
    PromotionRoomType?: PromotionRoomTypeUncheckedUpdateManyWithoutRoomTypeNestedInput
  }

  export type AmenityUpsertWithoutRoomTypesInput = {
    update: XOR<AmenityUpdateWithoutRoomTypesInput, AmenityUncheckedUpdateWithoutRoomTypesInput>
    create: XOR<AmenityCreateWithoutRoomTypesInput, AmenityUncheckedCreateWithoutRoomTypesInput>
    where?: AmenityWhereInput
  }

  export type AmenityUpdateToOneWithWhereWithoutRoomTypesInput = {
    where?: AmenityWhereInput
    data: XOR<AmenityUpdateWithoutRoomTypesInput, AmenityUncheckedUpdateWithoutRoomTypesInput>
  }

  export type AmenityUpdateWithoutRoomTypesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotels?: HotelAmenityUpdateManyWithoutAmenityNestedInput
  }

  export type AmenityUncheckedUpdateWithoutRoomTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotels?: HotelAmenityUncheckedUpdateManyWithoutAmenityNestedInput
  }

  export type RoomTypeCreateWithoutRoomsInput = {
    name: string
    description?: string | null
    maxGuests: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Hotel: HotelCreateNestedOneWithoutRoomTypesInput
    images?: ImageCreateNestedManyWithoutRoomTypeInput
    amenities?: RoomTypeAmenityCreateNestedManyWithoutRoomTypeInput
    inventory?: RoomInventoryCreateNestedManyWithoutRoomTypeInput
    prices?: RoomPriceCreateNestedManyWithoutRoomTypeInput
    bookings?: BookingCreateNestedManyWithoutRoomTypeInput
    PromotionRoomType?: PromotionRoomTypeCreateNestedManyWithoutRoomTypeInput
  }

  export type RoomTypeUncheckedCreateWithoutRoomsInput = {
    id?: number
    hotelId: number
    name: string
    description?: string | null
    maxGuests: number
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ImageUncheckedCreateNestedManyWithoutRoomTypeInput
    amenities?: RoomTypeAmenityUncheckedCreateNestedManyWithoutRoomTypeInput
    inventory?: RoomInventoryUncheckedCreateNestedManyWithoutRoomTypeInput
    prices?: RoomPriceUncheckedCreateNestedManyWithoutRoomTypeInput
    bookings?: BookingUncheckedCreateNestedManyWithoutRoomTypeInput
    PromotionRoomType?: PromotionRoomTypeUncheckedCreateNestedManyWithoutRoomTypeInput
  }

  export type RoomTypeCreateOrConnectWithoutRoomsInput = {
    where: RoomTypeWhereUniqueInput
    create: XOR<RoomTypeCreateWithoutRoomsInput, RoomTypeUncheckedCreateWithoutRoomsInput>
  }

  export type HotelCreateWithoutRoomsInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Address?: AddressCreateNestedOneWithoutHotelInput
    images?: ImageCreateNestedManyWithoutHotelInput
    amenities?: HotelAmenityCreateNestedManyWithoutHotelInput
    roomTypes?: RoomTypeCreateNestedManyWithoutHotelInput
    bookings?: BookingCreateNestedManyWithoutHotelInput
    reviews?: ReviewCreateNestedManyWithoutHotelInput
    inventory?: RoomInventoryCreateNestedManyWithoutHotelInput
    prices?: RoomPriceCreateNestedManyWithoutHotelInput
    policies?: CancellationPolicyCreateNestedManyWithoutHotelInput
    PromotionHotel?: PromotionHotelCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateWithoutRoomsInput = {
    id?: number
    name: string
    description?: string | null
    addressId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ImageUncheckedCreateNestedManyWithoutHotelInput
    amenities?: HotelAmenityUncheckedCreateNestedManyWithoutHotelInput
    roomTypes?: RoomTypeUncheckedCreateNestedManyWithoutHotelInput
    bookings?: BookingUncheckedCreateNestedManyWithoutHotelInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutHotelInput
    inventory?: RoomInventoryUncheckedCreateNestedManyWithoutHotelInput
    prices?: RoomPriceUncheckedCreateNestedManyWithoutHotelInput
    policies?: CancellationPolicyUncheckedCreateNestedManyWithoutHotelInput
    PromotionHotel?: PromotionHotelUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelCreateOrConnectWithoutRoomsInput = {
    where: HotelWhereUniqueInput
    create: XOR<HotelCreateWithoutRoomsInput, HotelUncheckedCreateWithoutRoomsInput>
  }

  export type RoomTypeUpsertWithoutRoomsInput = {
    update: XOR<RoomTypeUpdateWithoutRoomsInput, RoomTypeUncheckedUpdateWithoutRoomsInput>
    create: XOR<RoomTypeCreateWithoutRoomsInput, RoomTypeUncheckedCreateWithoutRoomsInput>
    where?: RoomTypeWhereInput
  }

  export type RoomTypeUpdateToOneWithWhereWithoutRoomsInput = {
    where?: RoomTypeWhereInput
    data: XOR<RoomTypeUpdateWithoutRoomsInput, RoomTypeUncheckedUpdateWithoutRoomsInput>
  }

  export type RoomTypeUpdateWithoutRoomsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Hotel?: HotelUpdateOneRequiredWithoutRoomTypesNestedInput
    images?: ImageUpdateManyWithoutRoomTypeNestedInput
    amenities?: RoomTypeAmenityUpdateManyWithoutRoomTypeNestedInput
    inventory?: RoomInventoryUpdateManyWithoutRoomTypeNestedInput
    prices?: RoomPriceUpdateManyWithoutRoomTypeNestedInput
    bookings?: BookingUpdateManyWithoutRoomTypeNestedInput
    PromotionRoomType?: PromotionRoomTypeUpdateManyWithoutRoomTypeNestedInput
  }

  export type RoomTypeUncheckedUpdateWithoutRoomsInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ImageUncheckedUpdateManyWithoutRoomTypeNestedInput
    amenities?: RoomTypeAmenityUncheckedUpdateManyWithoutRoomTypeNestedInput
    inventory?: RoomInventoryUncheckedUpdateManyWithoutRoomTypeNestedInput
    prices?: RoomPriceUncheckedUpdateManyWithoutRoomTypeNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutRoomTypeNestedInput
    PromotionRoomType?: PromotionRoomTypeUncheckedUpdateManyWithoutRoomTypeNestedInput
  }

  export type HotelUpsertWithoutRoomsInput = {
    update: XOR<HotelUpdateWithoutRoomsInput, HotelUncheckedUpdateWithoutRoomsInput>
    create: XOR<HotelCreateWithoutRoomsInput, HotelUncheckedCreateWithoutRoomsInput>
    where?: HotelWhereInput
  }

  export type HotelUpdateToOneWithWhereWithoutRoomsInput = {
    where?: HotelWhereInput
    data: XOR<HotelUpdateWithoutRoomsInput, HotelUncheckedUpdateWithoutRoomsInput>
  }

  export type HotelUpdateWithoutRoomsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Address?: AddressUpdateOneWithoutHotelNestedInput
    images?: ImageUpdateManyWithoutHotelNestedInput
    amenities?: HotelAmenityUpdateManyWithoutHotelNestedInput
    roomTypes?: RoomTypeUpdateManyWithoutHotelNestedInput
    bookings?: BookingUpdateManyWithoutHotelNestedInput
    reviews?: ReviewUpdateManyWithoutHotelNestedInput
    inventory?: RoomInventoryUpdateManyWithoutHotelNestedInput
    prices?: RoomPriceUpdateManyWithoutHotelNestedInput
    policies?: CancellationPolicyUpdateManyWithoutHotelNestedInput
    PromotionHotel?: PromotionHotelUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateWithoutRoomsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ImageUncheckedUpdateManyWithoutHotelNestedInput
    amenities?: HotelAmenityUncheckedUpdateManyWithoutHotelNestedInput
    roomTypes?: RoomTypeUncheckedUpdateManyWithoutHotelNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutHotelNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutHotelNestedInput
    inventory?: RoomInventoryUncheckedUpdateManyWithoutHotelNestedInput
    prices?: RoomPriceUncheckedUpdateManyWithoutHotelNestedInput
    policies?: CancellationPolicyUncheckedUpdateManyWithoutHotelNestedInput
    PromotionHotel?: PromotionHotelUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type RoomTypeCreateWithoutInventoryInput = {
    name: string
    description?: string | null
    maxGuests: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Hotel: HotelCreateNestedOneWithoutRoomTypesInput
    images?: ImageCreateNestedManyWithoutRoomTypeInput
    amenities?: RoomTypeAmenityCreateNestedManyWithoutRoomTypeInput
    rooms?: RoomCreateNestedManyWithoutRoomTypeInput
    prices?: RoomPriceCreateNestedManyWithoutRoomTypeInput
    bookings?: BookingCreateNestedManyWithoutRoomTypeInput
    PromotionRoomType?: PromotionRoomTypeCreateNestedManyWithoutRoomTypeInput
  }

  export type RoomTypeUncheckedCreateWithoutInventoryInput = {
    id?: number
    hotelId: number
    name: string
    description?: string | null
    maxGuests: number
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ImageUncheckedCreateNestedManyWithoutRoomTypeInput
    amenities?: RoomTypeAmenityUncheckedCreateNestedManyWithoutRoomTypeInput
    rooms?: RoomUncheckedCreateNestedManyWithoutRoomTypeInput
    prices?: RoomPriceUncheckedCreateNestedManyWithoutRoomTypeInput
    bookings?: BookingUncheckedCreateNestedManyWithoutRoomTypeInput
    PromotionRoomType?: PromotionRoomTypeUncheckedCreateNestedManyWithoutRoomTypeInput
  }

  export type RoomTypeCreateOrConnectWithoutInventoryInput = {
    where: RoomTypeWhereUniqueInput
    create: XOR<RoomTypeCreateWithoutInventoryInput, RoomTypeUncheckedCreateWithoutInventoryInput>
  }

  export type HotelCreateWithoutInventoryInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Address?: AddressCreateNestedOneWithoutHotelInput
    images?: ImageCreateNestedManyWithoutHotelInput
    amenities?: HotelAmenityCreateNestedManyWithoutHotelInput
    roomTypes?: RoomTypeCreateNestedManyWithoutHotelInput
    rooms?: RoomCreateNestedManyWithoutHotelInput
    bookings?: BookingCreateNestedManyWithoutHotelInput
    reviews?: ReviewCreateNestedManyWithoutHotelInput
    prices?: RoomPriceCreateNestedManyWithoutHotelInput
    policies?: CancellationPolicyCreateNestedManyWithoutHotelInput
    PromotionHotel?: PromotionHotelCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateWithoutInventoryInput = {
    id?: number
    name: string
    description?: string | null
    addressId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ImageUncheckedCreateNestedManyWithoutHotelInput
    amenities?: HotelAmenityUncheckedCreateNestedManyWithoutHotelInput
    roomTypes?: RoomTypeUncheckedCreateNestedManyWithoutHotelInput
    rooms?: RoomUncheckedCreateNestedManyWithoutHotelInput
    bookings?: BookingUncheckedCreateNestedManyWithoutHotelInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutHotelInput
    prices?: RoomPriceUncheckedCreateNestedManyWithoutHotelInput
    policies?: CancellationPolicyUncheckedCreateNestedManyWithoutHotelInput
    PromotionHotel?: PromotionHotelUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelCreateOrConnectWithoutInventoryInput = {
    where: HotelWhereUniqueInput
    create: XOR<HotelCreateWithoutInventoryInput, HotelUncheckedCreateWithoutInventoryInput>
  }

  export type RoomTypeUpsertWithoutInventoryInput = {
    update: XOR<RoomTypeUpdateWithoutInventoryInput, RoomTypeUncheckedUpdateWithoutInventoryInput>
    create: XOR<RoomTypeCreateWithoutInventoryInput, RoomTypeUncheckedCreateWithoutInventoryInput>
    where?: RoomTypeWhereInput
  }

  export type RoomTypeUpdateToOneWithWhereWithoutInventoryInput = {
    where?: RoomTypeWhereInput
    data: XOR<RoomTypeUpdateWithoutInventoryInput, RoomTypeUncheckedUpdateWithoutInventoryInput>
  }

  export type RoomTypeUpdateWithoutInventoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Hotel?: HotelUpdateOneRequiredWithoutRoomTypesNestedInput
    images?: ImageUpdateManyWithoutRoomTypeNestedInput
    amenities?: RoomTypeAmenityUpdateManyWithoutRoomTypeNestedInput
    rooms?: RoomUpdateManyWithoutRoomTypeNestedInput
    prices?: RoomPriceUpdateManyWithoutRoomTypeNestedInput
    bookings?: BookingUpdateManyWithoutRoomTypeNestedInput
    PromotionRoomType?: PromotionRoomTypeUpdateManyWithoutRoomTypeNestedInput
  }

  export type RoomTypeUncheckedUpdateWithoutInventoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ImageUncheckedUpdateManyWithoutRoomTypeNestedInput
    amenities?: RoomTypeAmenityUncheckedUpdateManyWithoutRoomTypeNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutRoomTypeNestedInput
    prices?: RoomPriceUncheckedUpdateManyWithoutRoomTypeNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutRoomTypeNestedInput
    PromotionRoomType?: PromotionRoomTypeUncheckedUpdateManyWithoutRoomTypeNestedInput
  }

  export type HotelUpsertWithoutInventoryInput = {
    update: XOR<HotelUpdateWithoutInventoryInput, HotelUncheckedUpdateWithoutInventoryInput>
    create: XOR<HotelCreateWithoutInventoryInput, HotelUncheckedCreateWithoutInventoryInput>
    where?: HotelWhereInput
  }

  export type HotelUpdateToOneWithWhereWithoutInventoryInput = {
    where?: HotelWhereInput
    data: XOR<HotelUpdateWithoutInventoryInput, HotelUncheckedUpdateWithoutInventoryInput>
  }

  export type HotelUpdateWithoutInventoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Address?: AddressUpdateOneWithoutHotelNestedInput
    images?: ImageUpdateManyWithoutHotelNestedInput
    amenities?: HotelAmenityUpdateManyWithoutHotelNestedInput
    roomTypes?: RoomTypeUpdateManyWithoutHotelNestedInput
    rooms?: RoomUpdateManyWithoutHotelNestedInput
    bookings?: BookingUpdateManyWithoutHotelNestedInput
    reviews?: ReviewUpdateManyWithoutHotelNestedInput
    prices?: RoomPriceUpdateManyWithoutHotelNestedInput
    policies?: CancellationPolicyUpdateManyWithoutHotelNestedInput
    PromotionHotel?: PromotionHotelUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateWithoutInventoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ImageUncheckedUpdateManyWithoutHotelNestedInput
    amenities?: HotelAmenityUncheckedUpdateManyWithoutHotelNestedInput
    roomTypes?: RoomTypeUncheckedUpdateManyWithoutHotelNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutHotelNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutHotelNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutHotelNestedInput
    prices?: RoomPriceUncheckedUpdateManyWithoutHotelNestedInput
    policies?: CancellationPolicyUncheckedUpdateManyWithoutHotelNestedInput
    PromotionHotel?: PromotionHotelUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type RoomTypeCreateWithoutPricesInput = {
    name: string
    description?: string | null
    maxGuests: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Hotel: HotelCreateNestedOneWithoutRoomTypesInput
    images?: ImageCreateNestedManyWithoutRoomTypeInput
    amenities?: RoomTypeAmenityCreateNestedManyWithoutRoomTypeInput
    rooms?: RoomCreateNestedManyWithoutRoomTypeInput
    inventory?: RoomInventoryCreateNestedManyWithoutRoomTypeInput
    bookings?: BookingCreateNestedManyWithoutRoomTypeInput
    PromotionRoomType?: PromotionRoomTypeCreateNestedManyWithoutRoomTypeInput
  }

  export type RoomTypeUncheckedCreateWithoutPricesInput = {
    id?: number
    hotelId: number
    name: string
    description?: string | null
    maxGuests: number
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ImageUncheckedCreateNestedManyWithoutRoomTypeInput
    amenities?: RoomTypeAmenityUncheckedCreateNestedManyWithoutRoomTypeInput
    rooms?: RoomUncheckedCreateNestedManyWithoutRoomTypeInput
    inventory?: RoomInventoryUncheckedCreateNestedManyWithoutRoomTypeInput
    bookings?: BookingUncheckedCreateNestedManyWithoutRoomTypeInput
    PromotionRoomType?: PromotionRoomTypeUncheckedCreateNestedManyWithoutRoomTypeInput
  }

  export type RoomTypeCreateOrConnectWithoutPricesInput = {
    where: RoomTypeWhereUniqueInput
    create: XOR<RoomTypeCreateWithoutPricesInput, RoomTypeUncheckedCreateWithoutPricesInput>
  }

  export type HotelCreateWithoutPricesInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Address?: AddressCreateNestedOneWithoutHotelInput
    images?: ImageCreateNestedManyWithoutHotelInput
    amenities?: HotelAmenityCreateNestedManyWithoutHotelInput
    roomTypes?: RoomTypeCreateNestedManyWithoutHotelInput
    rooms?: RoomCreateNestedManyWithoutHotelInput
    bookings?: BookingCreateNestedManyWithoutHotelInput
    reviews?: ReviewCreateNestedManyWithoutHotelInput
    inventory?: RoomInventoryCreateNestedManyWithoutHotelInput
    policies?: CancellationPolicyCreateNestedManyWithoutHotelInput
    PromotionHotel?: PromotionHotelCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateWithoutPricesInput = {
    id?: number
    name: string
    description?: string | null
    addressId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ImageUncheckedCreateNestedManyWithoutHotelInput
    amenities?: HotelAmenityUncheckedCreateNestedManyWithoutHotelInput
    roomTypes?: RoomTypeUncheckedCreateNestedManyWithoutHotelInput
    rooms?: RoomUncheckedCreateNestedManyWithoutHotelInput
    bookings?: BookingUncheckedCreateNestedManyWithoutHotelInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutHotelInput
    inventory?: RoomInventoryUncheckedCreateNestedManyWithoutHotelInput
    policies?: CancellationPolicyUncheckedCreateNestedManyWithoutHotelInput
    PromotionHotel?: PromotionHotelUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelCreateOrConnectWithoutPricesInput = {
    where: HotelWhereUniqueInput
    create: XOR<HotelCreateWithoutPricesInput, HotelUncheckedCreateWithoutPricesInput>
  }

  export type RoomTypeUpsertWithoutPricesInput = {
    update: XOR<RoomTypeUpdateWithoutPricesInput, RoomTypeUncheckedUpdateWithoutPricesInput>
    create: XOR<RoomTypeCreateWithoutPricesInput, RoomTypeUncheckedCreateWithoutPricesInput>
    where?: RoomTypeWhereInput
  }

  export type RoomTypeUpdateToOneWithWhereWithoutPricesInput = {
    where?: RoomTypeWhereInput
    data: XOR<RoomTypeUpdateWithoutPricesInput, RoomTypeUncheckedUpdateWithoutPricesInput>
  }

  export type RoomTypeUpdateWithoutPricesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Hotel?: HotelUpdateOneRequiredWithoutRoomTypesNestedInput
    images?: ImageUpdateManyWithoutRoomTypeNestedInput
    amenities?: RoomTypeAmenityUpdateManyWithoutRoomTypeNestedInput
    rooms?: RoomUpdateManyWithoutRoomTypeNestedInput
    inventory?: RoomInventoryUpdateManyWithoutRoomTypeNestedInput
    bookings?: BookingUpdateManyWithoutRoomTypeNestedInput
    PromotionRoomType?: PromotionRoomTypeUpdateManyWithoutRoomTypeNestedInput
  }

  export type RoomTypeUncheckedUpdateWithoutPricesInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ImageUncheckedUpdateManyWithoutRoomTypeNestedInput
    amenities?: RoomTypeAmenityUncheckedUpdateManyWithoutRoomTypeNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutRoomTypeNestedInput
    inventory?: RoomInventoryUncheckedUpdateManyWithoutRoomTypeNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutRoomTypeNestedInput
    PromotionRoomType?: PromotionRoomTypeUncheckedUpdateManyWithoutRoomTypeNestedInput
  }

  export type HotelUpsertWithoutPricesInput = {
    update: XOR<HotelUpdateWithoutPricesInput, HotelUncheckedUpdateWithoutPricesInput>
    create: XOR<HotelCreateWithoutPricesInput, HotelUncheckedCreateWithoutPricesInput>
    where?: HotelWhereInput
  }

  export type HotelUpdateToOneWithWhereWithoutPricesInput = {
    where?: HotelWhereInput
    data: XOR<HotelUpdateWithoutPricesInput, HotelUncheckedUpdateWithoutPricesInput>
  }

  export type HotelUpdateWithoutPricesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Address?: AddressUpdateOneWithoutHotelNestedInput
    images?: ImageUpdateManyWithoutHotelNestedInput
    amenities?: HotelAmenityUpdateManyWithoutHotelNestedInput
    roomTypes?: RoomTypeUpdateManyWithoutHotelNestedInput
    rooms?: RoomUpdateManyWithoutHotelNestedInput
    bookings?: BookingUpdateManyWithoutHotelNestedInput
    reviews?: ReviewUpdateManyWithoutHotelNestedInput
    inventory?: RoomInventoryUpdateManyWithoutHotelNestedInput
    policies?: CancellationPolicyUpdateManyWithoutHotelNestedInput
    PromotionHotel?: PromotionHotelUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateWithoutPricesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ImageUncheckedUpdateManyWithoutHotelNestedInput
    amenities?: HotelAmenityUncheckedUpdateManyWithoutHotelNestedInput
    roomTypes?: RoomTypeUncheckedUpdateManyWithoutHotelNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutHotelNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutHotelNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutHotelNestedInput
    inventory?: RoomInventoryUncheckedUpdateManyWithoutHotelNestedInput
    policies?: CancellationPolicyUncheckedUpdateManyWithoutHotelNestedInput
    PromotionHotel?: PromotionHotelUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type RoleCreateWithoutUsersInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type BookingCreateWithoutUserInput = {
    numberOfRooms?: number
    checkIn: Date | string
    checkOut: Date | string
    totalAmount?: number | null
    currency?: $Enums.CurrencyCode
    status?: $Enums.BookingStatus
    guestName?: string | null
    guestSurname?: string | null
    guestEmail?: string | null
    guestPhone?: string | null
    guestIdentity?: string | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    RoomType: RoomTypeCreateNestedOneWithoutBookingsInput
    payment?: PaymentCreateNestedOneWithoutBookingInput
    review?: ReviewCreateNestedOneWithoutBookingInput
    Promotion?: PromotionCreateNestedOneWithoutBookingsInput
    CancellationPolicy?: CancellationPolicyCreateNestedOneWithoutBookingsInput
    cancellation?: CancellationCreateNestedOneWithoutBookingInput
    Hotel?: HotelCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateWithoutUserInput = {
    id?: number
    roomTypeId: number
    numberOfRooms?: number
    checkIn: Date | string
    checkOut: Date | string
    totalAmount?: number | null
    currency?: $Enums.CurrencyCode
    status?: $Enums.BookingStatus
    guestName?: string | null
    guestSurname?: string | null
    guestEmail?: string | null
    guestPhone?: string | null
    guestIdentity?: string | null
    promotionId?: number | null
    cancellationPolicyId?: number | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelId?: number | null
    payment?: PaymentUncheckedCreateNestedOneWithoutBookingInput
    review?: ReviewUncheckedCreateNestedOneWithoutBookingInput
    cancellation?: CancellationUncheckedCreateNestedOneWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutUserInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput>
  }

  export type BookingCreateManyUserInputEnvelope = {
    data: BookingCreateManyUserInput | BookingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutUserInput = {
    rating: number
    title?: string | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Booking: BookingCreateNestedOneWithoutReviewInput
    Hotel?: HotelCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutUserInput = {
    id?: number
    bookingId: number
    rating: number
    title?: string | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelId?: number | null
  }

  export type ReviewCreateOrConnectWithoutUserInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewCreateManyUserInputEnvelope = {
    data: ReviewCreateManyUserInput | ReviewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CancellationCreateWithoutUserInput = {
    reason?: string | null
    cancelledAt?: Date | string
    refundAmount?: number | null
    refundStatus?: string | null
    notes?: string | null
    Booking: BookingCreateNestedOneWithoutCancellationInput
  }

  export type CancellationUncheckedCreateWithoutUserInput = {
    id?: number
    bookingId: number
    reason?: string | null
    cancelledAt?: Date | string
    refundAmount?: number | null
    refundStatus?: string | null
    notes?: string | null
  }

  export type CancellationCreateOrConnectWithoutUserInput = {
    where: CancellationWhereUniqueInput
    create: XOR<CancellationCreateWithoutUserInput, CancellationUncheckedCreateWithoutUserInput>
  }

  export type CancellationCreateManyUserInputEnvelope = {
    data: CancellationCreateManyUserInput | CancellationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUsersInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUpsertWithWhereUniqueWithoutUserInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutUserInput, BookingUncheckedUpdateWithoutUserInput>
    create: XOR<BookingCreateWithoutUserInput, BookingUncheckedCreateWithoutUserInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutUserInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutUserInput, BookingUncheckedUpdateWithoutUserInput>
  }

  export type BookingUpdateManyWithWhereWithoutUserInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
  }

  export type ReviewUpdateManyWithWhereWithoutUserInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutUserInput>
  }

  export type CancellationUpsertWithWhereUniqueWithoutUserInput = {
    where: CancellationWhereUniqueInput
    update: XOR<CancellationUpdateWithoutUserInput, CancellationUncheckedUpdateWithoutUserInput>
    create: XOR<CancellationCreateWithoutUserInput, CancellationUncheckedCreateWithoutUserInput>
  }

  export type CancellationUpdateWithWhereUniqueWithoutUserInput = {
    where: CancellationWhereUniqueInput
    data: XOR<CancellationUpdateWithoutUserInput, CancellationUncheckedUpdateWithoutUserInput>
  }

  export type CancellationUpdateManyWithWhereWithoutUserInput = {
    where: CancellationScalarWhereInput
    data: XOR<CancellationUpdateManyMutationInput, CancellationUncheckedUpdateManyWithoutUserInput>
  }

  export type CancellationScalarWhereInput = {
    AND?: CancellationScalarWhereInput | CancellationScalarWhereInput[]
    OR?: CancellationScalarWhereInput[]
    NOT?: CancellationScalarWhereInput | CancellationScalarWhereInput[]
    id?: IntFilter<"Cancellation"> | number
    bookingId?: IntFilter<"Cancellation"> | number
    reason?: StringNullableFilter<"Cancellation"> | string | null
    cancelledAt?: DateTimeFilter<"Cancellation"> | Date | string
    processedByUserId?: IntNullableFilter<"Cancellation"> | number | null
    refundAmount?: FloatNullableFilter<"Cancellation"> | number | null
    refundStatus?: StringNullableFilter<"Cancellation"> | string | null
    notes?: StringNullableFilter<"Cancellation"> | string | null
  }

  export type UserCreateWithoutRoleInput = {
    username: string
    email?: string | null
    password?: string | null
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    cancellations?: CancellationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRoleInput = {
    id?: number
    username: string
    email?: string | null
    password?: string | null
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    cancellations?: CancellationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRoleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserCreateManyRoleInputEnvelope = {
    data: UserCreateManyRoleInput | UserCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
  }

  export type UserUpdateManyWithWhereWithoutRoleInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    phoneNumber?: StringNullableFilter<"User"> | string | null
    roleId?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type UserCreateWithoutBookingsInput = {
    username: string
    email?: string | null
    password?: string | null
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Role: RoleCreateNestedOneWithoutUsersInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    cancellations?: CancellationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBookingsInput = {
    id?: number
    username: string
    email?: string | null
    password?: string | null
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    roleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    cancellations?: CancellationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBookingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
  }

  export type RoomTypeCreateWithoutBookingsInput = {
    name: string
    description?: string | null
    maxGuests: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Hotel: HotelCreateNestedOneWithoutRoomTypesInput
    images?: ImageCreateNestedManyWithoutRoomTypeInput
    amenities?: RoomTypeAmenityCreateNestedManyWithoutRoomTypeInput
    rooms?: RoomCreateNestedManyWithoutRoomTypeInput
    inventory?: RoomInventoryCreateNestedManyWithoutRoomTypeInput
    prices?: RoomPriceCreateNestedManyWithoutRoomTypeInput
    PromotionRoomType?: PromotionRoomTypeCreateNestedManyWithoutRoomTypeInput
  }

  export type RoomTypeUncheckedCreateWithoutBookingsInput = {
    id?: number
    hotelId: number
    name: string
    description?: string | null
    maxGuests: number
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ImageUncheckedCreateNestedManyWithoutRoomTypeInput
    amenities?: RoomTypeAmenityUncheckedCreateNestedManyWithoutRoomTypeInput
    rooms?: RoomUncheckedCreateNestedManyWithoutRoomTypeInput
    inventory?: RoomInventoryUncheckedCreateNestedManyWithoutRoomTypeInput
    prices?: RoomPriceUncheckedCreateNestedManyWithoutRoomTypeInput
    PromotionRoomType?: PromotionRoomTypeUncheckedCreateNestedManyWithoutRoomTypeInput
  }

  export type RoomTypeCreateOrConnectWithoutBookingsInput = {
    where: RoomTypeWhereUniqueInput
    create: XOR<RoomTypeCreateWithoutBookingsInput, RoomTypeUncheckedCreateWithoutBookingsInput>
  }

  export type PaymentCreateWithoutBookingInput = {
    id?: string
    amount: number
    currency?: $Enums.CurrencyCode
    paymentMethod?: $Enums.PaymentMethod | null
    paymentGatewayId?: string | null
    status?: $Enums.PaymentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutBookingInput = {
    id?: string
    amount: number
    currency?: $Enums.CurrencyCode
    paymentMethod?: $Enums.PaymentMethod | null
    paymentGatewayId?: string | null
    status?: $Enums.PaymentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutBookingInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
  }

  export type ReviewCreateWithoutBookingInput = {
    rating: number
    title?: string | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    User: UserCreateNestedOneWithoutReviewsInput
    Hotel?: HotelCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutBookingInput = {
    id?: number
    userId: number
    rating: number
    title?: string | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelId?: number | null
  }

  export type ReviewCreateOrConnectWithoutBookingInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutBookingInput, ReviewUncheckedCreateWithoutBookingInput>
  }

  export type PromotionCreateWithoutBookingsInput = {
    code: string
    description?: string | null
    discountType?: $Enums.DiscountType
    discountValue: number
    validFrom?: Date | string | null
    validUntil?: Date | string | null
    maxUses?: number | null
    usesPerUser?: number | null
    currentUses?: number
    minNights?: number | null
    minAmount?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    PromotionHotel?: PromotionHotelCreateNestedManyWithoutPromotionInput
    PromotionRoomType?: PromotionRoomTypeCreateNestedManyWithoutPromotionInput
  }

  export type PromotionUncheckedCreateWithoutBookingsInput = {
    id?: number
    code: string
    description?: string | null
    discountType?: $Enums.DiscountType
    discountValue: number
    validFrom?: Date | string | null
    validUntil?: Date | string | null
    maxUses?: number | null
    usesPerUser?: number | null
    currentUses?: number
    minNights?: number | null
    minAmount?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    PromotionHotel?: PromotionHotelUncheckedCreateNestedManyWithoutPromotionInput
    PromotionRoomType?: PromotionRoomTypeUncheckedCreateNestedManyWithoutPromotionInput
  }

  export type PromotionCreateOrConnectWithoutBookingsInput = {
    where: PromotionWhereUniqueInput
    create: XOR<PromotionCreateWithoutBookingsInput, PromotionUncheckedCreateWithoutBookingsInput>
  }

  export type CancellationPolicyCreateWithoutBookingsInput = {
    name: string
    description?: string | null
    rules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    Hotel?: HotelCreateNestedOneWithoutPoliciesInput
  }

  export type CancellationPolicyUncheckedCreateWithoutBookingsInput = {
    id?: number
    name: string
    description?: string | null
    rules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelId?: number | null
  }

  export type CancellationPolicyCreateOrConnectWithoutBookingsInput = {
    where: CancellationPolicyWhereUniqueInput
    create: XOR<CancellationPolicyCreateWithoutBookingsInput, CancellationPolicyUncheckedCreateWithoutBookingsInput>
  }

  export type CancellationCreateWithoutBookingInput = {
    reason?: string | null
    cancelledAt?: Date | string
    refundAmount?: number | null
    refundStatus?: string | null
    notes?: string | null
    User?: UserCreateNestedOneWithoutCancellationsInput
  }

  export type CancellationUncheckedCreateWithoutBookingInput = {
    id?: number
    reason?: string | null
    cancelledAt?: Date | string
    processedByUserId?: number | null
    refundAmount?: number | null
    refundStatus?: string | null
    notes?: string | null
  }

  export type CancellationCreateOrConnectWithoutBookingInput = {
    where: CancellationWhereUniqueInput
    create: XOR<CancellationCreateWithoutBookingInput, CancellationUncheckedCreateWithoutBookingInput>
  }

  export type HotelCreateWithoutBookingsInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Address?: AddressCreateNestedOneWithoutHotelInput
    images?: ImageCreateNestedManyWithoutHotelInput
    amenities?: HotelAmenityCreateNestedManyWithoutHotelInput
    roomTypes?: RoomTypeCreateNestedManyWithoutHotelInput
    rooms?: RoomCreateNestedManyWithoutHotelInput
    reviews?: ReviewCreateNestedManyWithoutHotelInput
    inventory?: RoomInventoryCreateNestedManyWithoutHotelInput
    prices?: RoomPriceCreateNestedManyWithoutHotelInput
    policies?: CancellationPolicyCreateNestedManyWithoutHotelInput
    PromotionHotel?: PromotionHotelCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateWithoutBookingsInput = {
    id?: number
    name: string
    description?: string | null
    addressId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ImageUncheckedCreateNestedManyWithoutHotelInput
    amenities?: HotelAmenityUncheckedCreateNestedManyWithoutHotelInput
    roomTypes?: RoomTypeUncheckedCreateNestedManyWithoutHotelInput
    rooms?: RoomUncheckedCreateNestedManyWithoutHotelInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutHotelInput
    inventory?: RoomInventoryUncheckedCreateNestedManyWithoutHotelInput
    prices?: RoomPriceUncheckedCreateNestedManyWithoutHotelInput
    policies?: CancellationPolicyUncheckedCreateNestedManyWithoutHotelInput
    PromotionHotel?: PromotionHotelUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelCreateOrConnectWithoutBookingsInput = {
    where: HotelWhereUniqueInput
    create: XOR<HotelCreateWithoutBookingsInput, HotelUncheckedCreateWithoutBookingsInput>
  }

  export type UserUpsertWithoutBookingsInput = {
    update: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBookingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type UserUpdateWithoutBookingsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    cancellations?: CancellationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    cancellations?: CancellationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RoomTypeUpsertWithoutBookingsInput = {
    update: XOR<RoomTypeUpdateWithoutBookingsInput, RoomTypeUncheckedUpdateWithoutBookingsInput>
    create: XOR<RoomTypeCreateWithoutBookingsInput, RoomTypeUncheckedCreateWithoutBookingsInput>
    where?: RoomTypeWhereInput
  }

  export type RoomTypeUpdateToOneWithWhereWithoutBookingsInput = {
    where?: RoomTypeWhereInput
    data: XOR<RoomTypeUpdateWithoutBookingsInput, RoomTypeUncheckedUpdateWithoutBookingsInput>
  }

  export type RoomTypeUpdateWithoutBookingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Hotel?: HotelUpdateOneRequiredWithoutRoomTypesNestedInput
    images?: ImageUpdateManyWithoutRoomTypeNestedInput
    amenities?: RoomTypeAmenityUpdateManyWithoutRoomTypeNestedInput
    rooms?: RoomUpdateManyWithoutRoomTypeNestedInput
    inventory?: RoomInventoryUpdateManyWithoutRoomTypeNestedInput
    prices?: RoomPriceUpdateManyWithoutRoomTypeNestedInput
    PromotionRoomType?: PromotionRoomTypeUpdateManyWithoutRoomTypeNestedInput
  }

  export type RoomTypeUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ImageUncheckedUpdateManyWithoutRoomTypeNestedInput
    amenities?: RoomTypeAmenityUncheckedUpdateManyWithoutRoomTypeNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutRoomTypeNestedInput
    inventory?: RoomInventoryUncheckedUpdateManyWithoutRoomTypeNestedInput
    prices?: RoomPriceUncheckedUpdateManyWithoutRoomTypeNestedInput
    PromotionRoomType?: PromotionRoomTypeUncheckedUpdateManyWithoutRoomTypeNestedInput
  }

  export type PaymentUpsertWithoutBookingInput = {
    update: XOR<PaymentUpdateWithoutBookingInput, PaymentUncheckedUpdateWithoutBookingInput>
    create: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutBookingInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutBookingInput, PaymentUncheckedUpdateWithoutBookingInput>
  }

  export type PaymentUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    paymentGatewayId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    paymentGatewayId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type ReviewUpsertWithoutBookingInput = {
    update: XOR<ReviewUpdateWithoutBookingInput, ReviewUncheckedUpdateWithoutBookingInput>
    create: XOR<ReviewCreateWithoutBookingInput, ReviewUncheckedCreateWithoutBookingInput>
    where?: ReviewWhereInput
  }

  export type ReviewUpdateToOneWithWhereWithoutBookingInput = {
    where?: ReviewWhereInput
    data: XOR<ReviewUpdateWithoutBookingInput, ReviewUncheckedUpdateWithoutBookingInput>
  }

  export type ReviewUpdateWithoutBookingInput = {
    rating?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutReviewsNestedInput
    Hotel?: HotelUpdateOneWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PromotionUpsertWithoutBookingsInput = {
    update: XOR<PromotionUpdateWithoutBookingsInput, PromotionUncheckedUpdateWithoutBookingsInput>
    create: XOR<PromotionCreateWithoutBookingsInput, PromotionUncheckedCreateWithoutBookingsInput>
    where?: PromotionWhereInput
  }

  export type PromotionUpdateToOneWithWhereWithoutBookingsInput = {
    where?: PromotionWhereInput
    data: XOR<PromotionUpdateWithoutBookingsInput, PromotionUncheckedUpdateWithoutBookingsInput>
  }

  export type PromotionUpdateWithoutBookingsInput = {
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usesPerUser?: NullableIntFieldUpdateOperationsInput | number | null
    currentUses?: IntFieldUpdateOperationsInput | number
    minNights?: NullableIntFieldUpdateOperationsInput | number | null
    minAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PromotionHotel?: PromotionHotelUpdateManyWithoutPromotionNestedInput
    PromotionRoomType?: PromotionRoomTypeUpdateManyWithoutPromotionNestedInput
  }

  export type PromotionUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usesPerUser?: NullableIntFieldUpdateOperationsInput | number | null
    currentUses?: IntFieldUpdateOperationsInput | number
    minNights?: NullableIntFieldUpdateOperationsInput | number | null
    minAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    PromotionHotel?: PromotionHotelUncheckedUpdateManyWithoutPromotionNestedInput
    PromotionRoomType?: PromotionRoomTypeUncheckedUpdateManyWithoutPromotionNestedInput
  }

  export type CancellationPolicyUpsertWithoutBookingsInput = {
    update: XOR<CancellationPolicyUpdateWithoutBookingsInput, CancellationPolicyUncheckedUpdateWithoutBookingsInput>
    create: XOR<CancellationPolicyCreateWithoutBookingsInput, CancellationPolicyUncheckedCreateWithoutBookingsInput>
    where?: CancellationPolicyWhereInput
  }

  export type CancellationPolicyUpdateToOneWithWhereWithoutBookingsInput = {
    where?: CancellationPolicyWhereInput
    data: XOR<CancellationPolicyUpdateWithoutBookingsInput, CancellationPolicyUncheckedUpdateWithoutBookingsInput>
  }

  export type CancellationPolicyUpdateWithoutBookingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Hotel?: HotelUpdateOneWithoutPoliciesNestedInput
  }

  export type CancellationPolicyUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CancellationUpsertWithoutBookingInput = {
    update: XOR<CancellationUpdateWithoutBookingInput, CancellationUncheckedUpdateWithoutBookingInput>
    create: XOR<CancellationCreateWithoutBookingInput, CancellationUncheckedCreateWithoutBookingInput>
    where?: CancellationWhereInput
  }

  export type CancellationUpdateToOneWithWhereWithoutBookingInput = {
    where?: CancellationWhereInput
    data: XOR<CancellationUpdateWithoutBookingInput, CancellationUncheckedUpdateWithoutBookingInput>
  }

  export type CancellationUpdateWithoutBookingInput = {
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundStatus?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    User?: UserUpdateOneWithoutCancellationsNestedInput
  }

  export type CancellationUncheckedUpdateWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedByUserId?: NullableIntFieldUpdateOperationsInput | number | null
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundStatus?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HotelUpsertWithoutBookingsInput = {
    update: XOR<HotelUpdateWithoutBookingsInput, HotelUncheckedUpdateWithoutBookingsInput>
    create: XOR<HotelCreateWithoutBookingsInput, HotelUncheckedCreateWithoutBookingsInput>
    where?: HotelWhereInput
  }

  export type HotelUpdateToOneWithWhereWithoutBookingsInput = {
    where?: HotelWhereInput
    data: XOR<HotelUpdateWithoutBookingsInput, HotelUncheckedUpdateWithoutBookingsInput>
  }

  export type HotelUpdateWithoutBookingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Address?: AddressUpdateOneWithoutHotelNestedInput
    images?: ImageUpdateManyWithoutHotelNestedInput
    amenities?: HotelAmenityUpdateManyWithoutHotelNestedInput
    roomTypes?: RoomTypeUpdateManyWithoutHotelNestedInput
    rooms?: RoomUpdateManyWithoutHotelNestedInput
    reviews?: ReviewUpdateManyWithoutHotelNestedInput
    inventory?: RoomInventoryUpdateManyWithoutHotelNestedInput
    prices?: RoomPriceUpdateManyWithoutHotelNestedInput
    policies?: CancellationPolicyUpdateManyWithoutHotelNestedInput
    PromotionHotel?: PromotionHotelUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ImageUncheckedUpdateManyWithoutHotelNestedInput
    amenities?: HotelAmenityUncheckedUpdateManyWithoutHotelNestedInput
    roomTypes?: RoomTypeUncheckedUpdateManyWithoutHotelNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutHotelNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutHotelNestedInput
    inventory?: RoomInventoryUncheckedUpdateManyWithoutHotelNestedInput
    prices?: RoomPriceUncheckedUpdateManyWithoutHotelNestedInput
    policies?: CancellationPolicyUncheckedUpdateManyWithoutHotelNestedInput
    PromotionHotel?: PromotionHotelUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type BookingCreateWithoutPaymentInput = {
    numberOfRooms?: number
    checkIn: Date | string
    checkOut: Date | string
    totalAmount?: number | null
    currency?: $Enums.CurrencyCode
    status?: $Enums.BookingStatus
    guestName?: string | null
    guestSurname?: string | null
    guestEmail?: string | null
    guestPhone?: string | null
    guestIdentity?: string | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    User?: UserCreateNestedOneWithoutBookingsInput
    RoomType: RoomTypeCreateNestedOneWithoutBookingsInput
    review?: ReviewCreateNestedOneWithoutBookingInput
    Promotion?: PromotionCreateNestedOneWithoutBookingsInput
    CancellationPolicy?: CancellationPolicyCreateNestedOneWithoutBookingsInput
    cancellation?: CancellationCreateNestedOneWithoutBookingInput
    Hotel?: HotelCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateWithoutPaymentInput = {
    id?: number
    userId?: number | null
    roomTypeId: number
    numberOfRooms?: number
    checkIn: Date | string
    checkOut: Date | string
    totalAmount?: number | null
    currency?: $Enums.CurrencyCode
    status?: $Enums.BookingStatus
    guestName?: string | null
    guestSurname?: string | null
    guestEmail?: string | null
    guestPhone?: string | null
    guestIdentity?: string | null
    promotionId?: number | null
    cancellationPolicyId?: number | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelId?: number | null
    review?: ReviewUncheckedCreateNestedOneWithoutBookingInput
    cancellation?: CancellationUncheckedCreateNestedOneWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutPaymentInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutPaymentInput, BookingUncheckedCreateWithoutPaymentInput>
  }

  export type TransactionCreateWithoutPaymentInput = {
    id?: string
    type: $Enums.TransactionType
    amount: number
    currency?: $Enums.CurrencyCode
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    status?: $Enums.TransactionStatus
  }

  export type TransactionUncheckedCreateWithoutPaymentInput = {
    id?: string
    type: $Enums.TransactionType
    amount: number
    currency?: $Enums.CurrencyCode
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    status?: $Enums.TransactionStatus
  }

  export type TransactionCreateOrConnectWithoutPaymentInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutPaymentInput, TransactionUncheckedCreateWithoutPaymentInput>
  }

  export type TransactionCreateManyPaymentInputEnvelope = {
    data: TransactionCreateManyPaymentInput | TransactionCreateManyPaymentInput[]
    skipDuplicates?: boolean
  }

  export type BookingUpsertWithoutPaymentInput = {
    update: XOR<BookingUpdateWithoutPaymentInput, BookingUncheckedUpdateWithoutPaymentInput>
    create: XOR<BookingCreateWithoutPaymentInput, BookingUncheckedCreateWithoutPaymentInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutPaymentInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutPaymentInput, BookingUncheckedUpdateWithoutPaymentInput>
  }

  export type BookingUpdateWithoutPaymentInput = {
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestSurname?: NullableStringFieldUpdateOperationsInput | string | null
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestIdentity?: NullableStringFieldUpdateOperationsInput | string | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneWithoutBookingsNestedInput
    RoomType?: RoomTypeUpdateOneRequiredWithoutBookingsNestedInput
    review?: ReviewUpdateOneWithoutBookingNestedInput
    Promotion?: PromotionUpdateOneWithoutBookingsNestedInput
    CancellationPolicy?: CancellationPolicyUpdateOneWithoutBookingsNestedInput
    cancellation?: CancellationUpdateOneWithoutBookingNestedInput
    Hotel?: HotelUpdateOneWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateWithoutPaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypeId?: IntFieldUpdateOperationsInput | number
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestSurname?: NullableStringFieldUpdateOperationsInput | string | null
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestIdentity?: NullableStringFieldUpdateOperationsInput | string | null
    promotionId?: NullableIntFieldUpdateOperationsInput | number | null
    cancellationPolicyId?: NullableIntFieldUpdateOperationsInput | number | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
    review?: ReviewUncheckedUpdateOneWithoutBookingNestedInput
    cancellation?: CancellationUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type TransactionUpsertWithWhereUniqueWithoutPaymentInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutPaymentInput, TransactionUncheckedUpdateWithoutPaymentInput>
    create: XOR<TransactionCreateWithoutPaymentInput, TransactionUncheckedCreateWithoutPaymentInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutPaymentInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutPaymentInput, TransactionUncheckedUpdateWithoutPaymentInput>
  }

  export type TransactionUpdateManyWithWhereWithoutPaymentInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutPaymentInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    paymentId?: StringFilter<"Transaction"> | string
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    amount?: FloatFilter<"Transaction"> | number
    currency?: EnumCurrencyCodeFilter<"Transaction"> | $Enums.CurrencyCode
    gatewayResponse?: JsonNullableFilter<"Transaction">
    timestamp?: DateTimeFilter<"Transaction"> | Date | string
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
  }

  export type PaymentCreateWithoutTransactionsInput = {
    id?: string
    amount: number
    currency?: $Enums.CurrencyCode
    paymentMethod?: $Enums.PaymentMethod | null
    paymentGatewayId?: string | null
    status?: $Enums.PaymentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    Booking: BookingCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutTransactionsInput = {
    id?: string
    bookingId: number
    amount: number
    currency?: $Enums.CurrencyCode
    paymentMethod?: $Enums.PaymentMethod | null
    paymentGatewayId?: string | null
    status?: $Enums.PaymentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutTransactionsInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutTransactionsInput, PaymentUncheckedCreateWithoutTransactionsInput>
  }

  export type PaymentUpsertWithoutTransactionsInput = {
    update: XOR<PaymentUpdateWithoutTransactionsInput, PaymentUncheckedUpdateWithoutTransactionsInput>
    create: XOR<PaymentCreateWithoutTransactionsInput, PaymentUncheckedCreateWithoutTransactionsInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutTransactionsInput, PaymentUncheckedUpdateWithoutTransactionsInput>
  }

  export type PaymentUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    paymentGatewayId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Booking?: BookingUpdateOneRequiredWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    paymentGatewayId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateWithoutReviewInput = {
    numberOfRooms?: number
    checkIn: Date | string
    checkOut: Date | string
    totalAmount?: number | null
    currency?: $Enums.CurrencyCode
    status?: $Enums.BookingStatus
    guestName?: string | null
    guestSurname?: string | null
    guestEmail?: string | null
    guestPhone?: string | null
    guestIdentity?: string | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    User?: UserCreateNestedOneWithoutBookingsInput
    RoomType: RoomTypeCreateNestedOneWithoutBookingsInput
    payment?: PaymentCreateNestedOneWithoutBookingInput
    Promotion?: PromotionCreateNestedOneWithoutBookingsInput
    CancellationPolicy?: CancellationPolicyCreateNestedOneWithoutBookingsInput
    cancellation?: CancellationCreateNestedOneWithoutBookingInput
    Hotel?: HotelCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateWithoutReviewInput = {
    id?: number
    userId?: number | null
    roomTypeId: number
    numberOfRooms?: number
    checkIn: Date | string
    checkOut: Date | string
    totalAmount?: number | null
    currency?: $Enums.CurrencyCode
    status?: $Enums.BookingStatus
    guestName?: string | null
    guestSurname?: string | null
    guestEmail?: string | null
    guestPhone?: string | null
    guestIdentity?: string | null
    promotionId?: number | null
    cancellationPolicyId?: number | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelId?: number | null
    payment?: PaymentUncheckedCreateNestedOneWithoutBookingInput
    cancellation?: CancellationUncheckedCreateNestedOneWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutReviewInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutReviewInput, BookingUncheckedCreateWithoutReviewInput>
  }

  export type UserCreateWithoutReviewsInput = {
    username: string
    email?: string | null
    password?: string | null
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Role: RoleCreateNestedOneWithoutUsersInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    cancellations?: CancellationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewsInput = {
    id?: number
    username: string
    email?: string | null
    password?: string | null
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    roleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    cancellations?: CancellationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
  }

  export type HotelCreateWithoutReviewsInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Address?: AddressCreateNestedOneWithoutHotelInput
    images?: ImageCreateNestedManyWithoutHotelInput
    amenities?: HotelAmenityCreateNestedManyWithoutHotelInput
    roomTypes?: RoomTypeCreateNestedManyWithoutHotelInput
    rooms?: RoomCreateNestedManyWithoutHotelInput
    bookings?: BookingCreateNestedManyWithoutHotelInput
    inventory?: RoomInventoryCreateNestedManyWithoutHotelInput
    prices?: RoomPriceCreateNestedManyWithoutHotelInput
    policies?: CancellationPolicyCreateNestedManyWithoutHotelInput
    PromotionHotel?: PromotionHotelCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateWithoutReviewsInput = {
    id?: number
    name: string
    description?: string | null
    addressId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ImageUncheckedCreateNestedManyWithoutHotelInput
    amenities?: HotelAmenityUncheckedCreateNestedManyWithoutHotelInput
    roomTypes?: RoomTypeUncheckedCreateNestedManyWithoutHotelInput
    rooms?: RoomUncheckedCreateNestedManyWithoutHotelInput
    bookings?: BookingUncheckedCreateNestedManyWithoutHotelInput
    inventory?: RoomInventoryUncheckedCreateNestedManyWithoutHotelInput
    prices?: RoomPriceUncheckedCreateNestedManyWithoutHotelInput
    policies?: CancellationPolicyUncheckedCreateNestedManyWithoutHotelInput
    PromotionHotel?: PromotionHotelUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelCreateOrConnectWithoutReviewsInput = {
    where: HotelWhereUniqueInput
    create: XOR<HotelCreateWithoutReviewsInput, HotelUncheckedCreateWithoutReviewsInput>
  }

  export type BookingUpsertWithoutReviewInput = {
    update: XOR<BookingUpdateWithoutReviewInput, BookingUncheckedUpdateWithoutReviewInput>
    create: XOR<BookingCreateWithoutReviewInput, BookingUncheckedCreateWithoutReviewInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutReviewInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutReviewInput, BookingUncheckedUpdateWithoutReviewInput>
  }

  export type BookingUpdateWithoutReviewInput = {
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestSurname?: NullableStringFieldUpdateOperationsInput | string | null
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestIdentity?: NullableStringFieldUpdateOperationsInput | string | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneWithoutBookingsNestedInput
    RoomType?: RoomTypeUpdateOneRequiredWithoutBookingsNestedInput
    payment?: PaymentUpdateOneWithoutBookingNestedInput
    Promotion?: PromotionUpdateOneWithoutBookingsNestedInput
    CancellationPolicy?: CancellationPolicyUpdateOneWithoutBookingsNestedInput
    cancellation?: CancellationUpdateOneWithoutBookingNestedInput
    Hotel?: HotelUpdateOneWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateWithoutReviewInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypeId?: IntFieldUpdateOperationsInput | number
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestSurname?: NullableStringFieldUpdateOperationsInput | string | null
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestIdentity?: NullableStringFieldUpdateOperationsInput | string | null
    promotionId?: NullableIntFieldUpdateOperationsInput | number | null
    cancellationPolicyId?: NullableIntFieldUpdateOperationsInput | number | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
    payment?: PaymentUncheckedUpdateOneWithoutBookingNestedInput
    cancellation?: CancellationUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type UserUpsertWithoutReviewsInput = {
    update: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateWithoutReviewsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    cancellations?: CancellationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    cancellations?: CancellationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type HotelUpsertWithoutReviewsInput = {
    update: XOR<HotelUpdateWithoutReviewsInput, HotelUncheckedUpdateWithoutReviewsInput>
    create: XOR<HotelCreateWithoutReviewsInput, HotelUncheckedCreateWithoutReviewsInput>
    where?: HotelWhereInput
  }

  export type HotelUpdateToOneWithWhereWithoutReviewsInput = {
    where?: HotelWhereInput
    data: XOR<HotelUpdateWithoutReviewsInput, HotelUncheckedUpdateWithoutReviewsInput>
  }

  export type HotelUpdateWithoutReviewsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Address?: AddressUpdateOneWithoutHotelNestedInput
    images?: ImageUpdateManyWithoutHotelNestedInput
    amenities?: HotelAmenityUpdateManyWithoutHotelNestedInput
    roomTypes?: RoomTypeUpdateManyWithoutHotelNestedInput
    rooms?: RoomUpdateManyWithoutHotelNestedInput
    bookings?: BookingUpdateManyWithoutHotelNestedInput
    inventory?: RoomInventoryUpdateManyWithoutHotelNestedInput
    prices?: RoomPriceUpdateManyWithoutHotelNestedInput
    policies?: CancellationPolicyUpdateManyWithoutHotelNestedInput
    PromotionHotel?: PromotionHotelUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateWithoutReviewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ImageUncheckedUpdateManyWithoutHotelNestedInput
    amenities?: HotelAmenityUncheckedUpdateManyWithoutHotelNestedInput
    roomTypes?: RoomTypeUncheckedUpdateManyWithoutHotelNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutHotelNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutHotelNestedInput
    inventory?: RoomInventoryUncheckedUpdateManyWithoutHotelNestedInput
    prices?: RoomPriceUncheckedUpdateManyWithoutHotelNestedInput
    policies?: CancellationPolicyUncheckedUpdateManyWithoutHotelNestedInput
    PromotionHotel?: PromotionHotelUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type BookingCreateWithoutPromotionInput = {
    numberOfRooms?: number
    checkIn: Date | string
    checkOut: Date | string
    totalAmount?: number | null
    currency?: $Enums.CurrencyCode
    status?: $Enums.BookingStatus
    guestName?: string | null
    guestSurname?: string | null
    guestEmail?: string | null
    guestPhone?: string | null
    guestIdentity?: string | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    User?: UserCreateNestedOneWithoutBookingsInput
    RoomType: RoomTypeCreateNestedOneWithoutBookingsInput
    payment?: PaymentCreateNestedOneWithoutBookingInput
    review?: ReviewCreateNestedOneWithoutBookingInput
    CancellationPolicy?: CancellationPolicyCreateNestedOneWithoutBookingsInput
    cancellation?: CancellationCreateNestedOneWithoutBookingInput
    Hotel?: HotelCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateWithoutPromotionInput = {
    id?: number
    userId?: number | null
    roomTypeId: number
    numberOfRooms?: number
    checkIn: Date | string
    checkOut: Date | string
    totalAmount?: number | null
    currency?: $Enums.CurrencyCode
    status?: $Enums.BookingStatus
    guestName?: string | null
    guestSurname?: string | null
    guestEmail?: string | null
    guestPhone?: string | null
    guestIdentity?: string | null
    cancellationPolicyId?: number | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelId?: number | null
    payment?: PaymentUncheckedCreateNestedOneWithoutBookingInput
    review?: ReviewUncheckedCreateNestedOneWithoutBookingInput
    cancellation?: CancellationUncheckedCreateNestedOneWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutPromotionInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutPromotionInput, BookingUncheckedCreateWithoutPromotionInput>
  }

  export type BookingCreateManyPromotionInputEnvelope = {
    data: BookingCreateManyPromotionInput | BookingCreateManyPromotionInput[]
    skipDuplicates?: boolean
  }

  export type PromotionHotelCreateWithoutPromotionInput = {
    createdAt?: Date | string
    Hotel: HotelCreateNestedOneWithoutPromotionHotelInput
  }

  export type PromotionHotelUncheckedCreateWithoutPromotionInput = {
    id?: number
    hotelId: number
    createdAt?: Date | string
  }

  export type PromotionHotelCreateOrConnectWithoutPromotionInput = {
    where: PromotionHotelWhereUniqueInput
    create: XOR<PromotionHotelCreateWithoutPromotionInput, PromotionHotelUncheckedCreateWithoutPromotionInput>
  }

  export type PromotionHotelCreateManyPromotionInputEnvelope = {
    data: PromotionHotelCreateManyPromotionInput | PromotionHotelCreateManyPromotionInput[]
    skipDuplicates?: boolean
  }

  export type PromotionRoomTypeCreateWithoutPromotionInput = {
    createdAt?: Date | string
    RoomType: RoomTypeCreateNestedOneWithoutPromotionRoomTypeInput
  }

  export type PromotionRoomTypeUncheckedCreateWithoutPromotionInput = {
    id?: number
    roomTypeId: number
    createdAt?: Date | string
  }

  export type PromotionRoomTypeCreateOrConnectWithoutPromotionInput = {
    where: PromotionRoomTypeWhereUniqueInput
    create: XOR<PromotionRoomTypeCreateWithoutPromotionInput, PromotionRoomTypeUncheckedCreateWithoutPromotionInput>
  }

  export type PromotionRoomTypeCreateManyPromotionInputEnvelope = {
    data: PromotionRoomTypeCreateManyPromotionInput | PromotionRoomTypeCreateManyPromotionInput[]
    skipDuplicates?: boolean
  }

  export type BookingUpsertWithWhereUniqueWithoutPromotionInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutPromotionInput, BookingUncheckedUpdateWithoutPromotionInput>
    create: XOR<BookingCreateWithoutPromotionInput, BookingUncheckedCreateWithoutPromotionInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutPromotionInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutPromotionInput, BookingUncheckedUpdateWithoutPromotionInput>
  }

  export type BookingUpdateManyWithWhereWithoutPromotionInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutPromotionInput>
  }

  export type PromotionHotelUpsertWithWhereUniqueWithoutPromotionInput = {
    where: PromotionHotelWhereUniqueInput
    update: XOR<PromotionHotelUpdateWithoutPromotionInput, PromotionHotelUncheckedUpdateWithoutPromotionInput>
    create: XOR<PromotionHotelCreateWithoutPromotionInput, PromotionHotelUncheckedCreateWithoutPromotionInput>
  }

  export type PromotionHotelUpdateWithWhereUniqueWithoutPromotionInput = {
    where: PromotionHotelWhereUniqueInput
    data: XOR<PromotionHotelUpdateWithoutPromotionInput, PromotionHotelUncheckedUpdateWithoutPromotionInput>
  }

  export type PromotionHotelUpdateManyWithWhereWithoutPromotionInput = {
    where: PromotionHotelScalarWhereInput
    data: XOR<PromotionHotelUpdateManyMutationInput, PromotionHotelUncheckedUpdateManyWithoutPromotionInput>
  }

  export type PromotionRoomTypeUpsertWithWhereUniqueWithoutPromotionInput = {
    where: PromotionRoomTypeWhereUniqueInput
    update: XOR<PromotionRoomTypeUpdateWithoutPromotionInput, PromotionRoomTypeUncheckedUpdateWithoutPromotionInput>
    create: XOR<PromotionRoomTypeCreateWithoutPromotionInput, PromotionRoomTypeUncheckedCreateWithoutPromotionInput>
  }

  export type PromotionRoomTypeUpdateWithWhereUniqueWithoutPromotionInput = {
    where: PromotionRoomTypeWhereUniqueInput
    data: XOR<PromotionRoomTypeUpdateWithoutPromotionInput, PromotionRoomTypeUncheckedUpdateWithoutPromotionInput>
  }

  export type PromotionRoomTypeUpdateManyWithWhereWithoutPromotionInput = {
    where: PromotionRoomTypeScalarWhereInput
    data: XOR<PromotionRoomTypeUpdateManyMutationInput, PromotionRoomTypeUncheckedUpdateManyWithoutPromotionInput>
  }

  export type BookingCreateWithoutCancellationPolicyInput = {
    numberOfRooms?: number
    checkIn: Date | string
    checkOut: Date | string
    totalAmount?: number | null
    currency?: $Enums.CurrencyCode
    status?: $Enums.BookingStatus
    guestName?: string | null
    guestSurname?: string | null
    guestEmail?: string | null
    guestPhone?: string | null
    guestIdentity?: string | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    User?: UserCreateNestedOneWithoutBookingsInput
    RoomType: RoomTypeCreateNestedOneWithoutBookingsInput
    payment?: PaymentCreateNestedOneWithoutBookingInput
    review?: ReviewCreateNestedOneWithoutBookingInput
    Promotion?: PromotionCreateNestedOneWithoutBookingsInput
    cancellation?: CancellationCreateNestedOneWithoutBookingInput
    Hotel?: HotelCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateWithoutCancellationPolicyInput = {
    id?: number
    userId?: number | null
    roomTypeId: number
    numberOfRooms?: number
    checkIn: Date | string
    checkOut: Date | string
    totalAmount?: number | null
    currency?: $Enums.CurrencyCode
    status?: $Enums.BookingStatus
    guestName?: string | null
    guestSurname?: string | null
    guestEmail?: string | null
    guestPhone?: string | null
    guestIdentity?: string | null
    promotionId?: number | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelId?: number | null
    payment?: PaymentUncheckedCreateNestedOneWithoutBookingInput
    review?: ReviewUncheckedCreateNestedOneWithoutBookingInput
    cancellation?: CancellationUncheckedCreateNestedOneWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutCancellationPolicyInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutCancellationPolicyInput, BookingUncheckedCreateWithoutCancellationPolicyInput>
  }

  export type BookingCreateManyCancellationPolicyInputEnvelope = {
    data: BookingCreateManyCancellationPolicyInput | BookingCreateManyCancellationPolicyInput[]
    skipDuplicates?: boolean
  }

  export type HotelCreateWithoutPoliciesInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Address?: AddressCreateNestedOneWithoutHotelInput
    images?: ImageCreateNestedManyWithoutHotelInput
    amenities?: HotelAmenityCreateNestedManyWithoutHotelInput
    roomTypes?: RoomTypeCreateNestedManyWithoutHotelInput
    rooms?: RoomCreateNestedManyWithoutHotelInput
    bookings?: BookingCreateNestedManyWithoutHotelInput
    reviews?: ReviewCreateNestedManyWithoutHotelInput
    inventory?: RoomInventoryCreateNestedManyWithoutHotelInput
    prices?: RoomPriceCreateNestedManyWithoutHotelInput
    PromotionHotel?: PromotionHotelCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateWithoutPoliciesInput = {
    id?: number
    name: string
    description?: string | null
    addressId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ImageUncheckedCreateNestedManyWithoutHotelInput
    amenities?: HotelAmenityUncheckedCreateNestedManyWithoutHotelInput
    roomTypes?: RoomTypeUncheckedCreateNestedManyWithoutHotelInput
    rooms?: RoomUncheckedCreateNestedManyWithoutHotelInput
    bookings?: BookingUncheckedCreateNestedManyWithoutHotelInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutHotelInput
    inventory?: RoomInventoryUncheckedCreateNestedManyWithoutHotelInput
    prices?: RoomPriceUncheckedCreateNestedManyWithoutHotelInput
    PromotionHotel?: PromotionHotelUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelCreateOrConnectWithoutPoliciesInput = {
    where: HotelWhereUniqueInput
    create: XOR<HotelCreateWithoutPoliciesInput, HotelUncheckedCreateWithoutPoliciesInput>
  }

  export type BookingUpsertWithWhereUniqueWithoutCancellationPolicyInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutCancellationPolicyInput, BookingUncheckedUpdateWithoutCancellationPolicyInput>
    create: XOR<BookingCreateWithoutCancellationPolicyInput, BookingUncheckedCreateWithoutCancellationPolicyInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutCancellationPolicyInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutCancellationPolicyInput, BookingUncheckedUpdateWithoutCancellationPolicyInput>
  }

  export type BookingUpdateManyWithWhereWithoutCancellationPolicyInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutCancellationPolicyInput>
  }

  export type HotelUpsertWithoutPoliciesInput = {
    update: XOR<HotelUpdateWithoutPoliciesInput, HotelUncheckedUpdateWithoutPoliciesInput>
    create: XOR<HotelCreateWithoutPoliciesInput, HotelUncheckedCreateWithoutPoliciesInput>
    where?: HotelWhereInput
  }

  export type HotelUpdateToOneWithWhereWithoutPoliciesInput = {
    where?: HotelWhereInput
    data: XOR<HotelUpdateWithoutPoliciesInput, HotelUncheckedUpdateWithoutPoliciesInput>
  }

  export type HotelUpdateWithoutPoliciesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Address?: AddressUpdateOneWithoutHotelNestedInput
    images?: ImageUpdateManyWithoutHotelNestedInput
    amenities?: HotelAmenityUpdateManyWithoutHotelNestedInput
    roomTypes?: RoomTypeUpdateManyWithoutHotelNestedInput
    rooms?: RoomUpdateManyWithoutHotelNestedInput
    bookings?: BookingUpdateManyWithoutHotelNestedInput
    reviews?: ReviewUpdateManyWithoutHotelNestedInput
    inventory?: RoomInventoryUpdateManyWithoutHotelNestedInput
    prices?: RoomPriceUpdateManyWithoutHotelNestedInput
    PromotionHotel?: PromotionHotelUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateWithoutPoliciesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ImageUncheckedUpdateManyWithoutHotelNestedInput
    amenities?: HotelAmenityUncheckedUpdateManyWithoutHotelNestedInput
    roomTypes?: RoomTypeUncheckedUpdateManyWithoutHotelNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutHotelNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutHotelNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutHotelNestedInput
    inventory?: RoomInventoryUncheckedUpdateManyWithoutHotelNestedInput
    prices?: RoomPriceUncheckedUpdateManyWithoutHotelNestedInput
    PromotionHotel?: PromotionHotelUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type BookingCreateWithoutCancellationInput = {
    numberOfRooms?: number
    checkIn: Date | string
    checkOut: Date | string
    totalAmount?: number | null
    currency?: $Enums.CurrencyCode
    status?: $Enums.BookingStatus
    guestName?: string | null
    guestSurname?: string | null
    guestEmail?: string | null
    guestPhone?: string | null
    guestIdentity?: string | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    User?: UserCreateNestedOneWithoutBookingsInput
    RoomType: RoomTypeCreateNestedOneWithoutBookingsInput
    payment?: PaymentCreateNestedOneWithoutBookingInput
    review?: ReviewCreateNestedOneWithoutBookingInput
    Promotion?: PromotionCreateNestedOneWithoutBookingsInput
    CancellationPolicy?: CancellationPolicyCreateNestedOneWithoutBookingsInput
    Hotel?: HotelCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateWithoutCancellationInput = {
    id?: number
    userId?: number | null
    roomTypeId: number
    numberOfRooms?: number
    checkIn: Date | string
    checkOut: Date | string
    totalAmount?: number | null
    currency?: $Enums.CurrencyCode
    status?: $Enums.BookingStatus
    guestName?: string | null
    guestSurname?: string | null
    guestEmail?: string | null
    guestPhone?: string | null
    guestIdentity?: string | null
    promotionId?: number | null
    cancellationPolicyId?: number | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelId?: number | null
    payment?: PaymentUncheckedCreateNestedOneWithoutBookingInput
    review?: ReviewUncheckedCreateNestedOneWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutCancellationInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutCancellationInput, BookingUncheckedCreateWithoutCancellationInput>
  }

  export type UserCreateWithoutCancellationsInput = {
    username: string
    email?: string | null
    password?: string | null
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Role: RoleCreateNestedOneWithoutUsersInput
    bookings?: BookingCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCancellationsInput = {
    id?: number
    username: string
    email?: string | null
    password?: string | null
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    roleId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCancellationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCancellationsInput, UserUncheckedCreateWithoutCancellationsInput>
  }

  export type BookingUpsertWithoutCancellationInput = {
    update: XOR<BookingUpdateWithoutCancellationInput, BookingUncheckedUpdateWithoutCancellationInput>
    create: XOR<BookingCreateWithoutCancellationInput, BookingUncheckedCreateWithoutCancellationInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutCancellationInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutCancellationInput, BookingUncheckedUpdateWithoutCancellationInput>
  }

  export type BookingUpdateWithoutCancellationInput = {
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestSurname?: NullableStringFieldUpdateOperationsInput | string | null
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestIdentity?: NullableStringFieldUpdateOperationsInput | string | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneWithoutBookingsNestedInput
    RoomType?: RoomTypeUpdateOneRequiredWithoutBookingsNestedInput
    payment?: PaymentUpdateOneWithoutBookingNestedInput
    review?: ReviewUpdateOneWithoutBookingNestedInput
    Promotion?: PromotionUpdateOneWithoutBookingsNestedInput
    CancellationPolicy?: CancellationPolicyUpdateOneWithoutBookingsNestedInput
    Hotel?: HotelUpdateOneWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateWithoutCancellationInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypeId?: IntFieldUpdateOperationsInput | number
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestSurname?: NullableStringFieldUpdateOperationsInput | string | null
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestIdentity?: NullableStringFieldUpdateOperationsInput | string | null
    promotionId?: NullableIntFieldUpdateOperationsInput | number | null
    cancellationPolicyId?: NullableIntFieldUpdateOperationsInput | number | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
    payment?: PaymentUncheckedUpdateOneWithoutBookingNestedInput
    review?: ReviewUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type UserUpsertWithoutCancellationsInput = {
    update: XOR<UserUpdateWithoutCancellationsInput, UserUncheckedUpdateWithoutCancellationsInput>
    create: XOR<UserCreateWithoutCancellationsInput, UserUncheckedCreateWithoutCancellationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCancellationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCancellationsInput, UserUncheckedUpdateWithoutCancellationsInput>
  }

  export type UserUpdateWithoutCancellationsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    bookings?: BookingUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCancellationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    roleId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PromotionCreateWithoutPromotionHotelInput = {
    code: string
    description?: string | null
    discountType?: $Enums.DiscountType
    discountValue: number
    validFrom?: Date | string | null
    validUntil?: Date | string | null
    maxUses?: number | null
    usesPerUser?: number | null
    currentUses?: number
    minNights?: number | null
    minAmount?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutPromotionInput
    PromotionRoomType?: PromotionRoomTypeCreateNestedManyWithoutPromotionInput
  }

  export type PromotionUncheckedCreateWithoutPromotionHotelInput = {
    id?: number
    code: string
    description?: string | null
    discountType?: $Enums.DiscountType
    discountValue: number
    validFrom?: Date | string | null
    validUntil?: Date | string | null
    maxUses?: number | null
    usesPerUser?: number | null
    currentUses?: number
    minNights?: number | null
    minAmount?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutPromotionInput
    PromotionRoomType?: PromotionRoomTypeUncheckedCreateNestedManyWithoutPromotionInput
  }

  export type PromotionCreateOrConnectWithoutPromotionHotelInput = {
    where: PromotionWhereUniqueInput
    create: XOR<PromotionCreateWithoutPromotionHotelInput, PromotionUncheckedCreateWithoutPromotionHotelInput>
  }

  export type HotelCreateWithoutPromotionHotelInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Address?: AddressCreateNestedOneWithoutHotelInput
    images?: ImageCreateNestedManyWithoutHotelInput
    amenities?: HotelAmenityCreateNestedManyWithoutHotelInput
    roomTypes?: RoomTypeCreateNestedManyWithoutHotelInput
    rooms?: RoomCreateNestedManyWithoutHotelInput
    bookings?: BookingCreateNestedManyWithoutHotelInput
    reviews?: ReviewCreateNestedManyWithoutHotelInput
    inventory?: RoomInventoryCreateNestedManyWithoutHotelInput
    prices?: RoomPriceCreateNestedManyWithoutHotelInput
    policies?: CancellationPolicyCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateWithoutPromotionHotelInput = {
    id?: number
    name: string
    description?: string | null
    addressId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ImageUncheckedCreateNestedManyWithoutHotelInput
    amenities?: HotelAmenityUncheckedCreateNestedManyWithoutHotelInput
    roomTypes?: RoomTypeUncheckedCreateNestedManyWithoutHotelInput
    rooms?: RoomUncheckedCreateNestedManyWithoutHotelInput
    bookings?: BookingUncheckedCreateNestedManyWithoutHotelInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutHotelInput
    inventory?: RoomInventoryUncheckedCreateNestedManyWithoutHotelInput
    prices?: RoomPriceUncheckedCreateNestedManyWithoutHotelInput
    policies?: CancellationPolicyUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelCreateOrConnectWithoutPromotionHotelInput = {
    where: HotelWhereUniqueInput
    create: XOR<HotelCreateWithoutPromotionHotelInput, HotelUncheckedCreateWithoutPromotionHotelInput>
  }

  export type PromotionUpsertWithoutPromotionHotelInput = {
    update: XOR<PromotionUpdateWithoutPromotionHotelInput, PromotionUncheckedUpdateWithoutPromotionHotelInput>
    create: XOR<PromotionCreateWithoutPromotionHotelInput, PromotionUncheckedCreateWithoutPromotionHotelInput>
    where?: PromotionWhereInput
  }

  export type PromotionUpdateToOneWithWhereWithoutPromotionHotelInput = {
    where?: PromotionWhereInput
    data: XOR<PromotionUpdateWithoutPromotionHotelInput, PromotionUncheckedUpdateWithoutPromotionHotelInput>
  }

  export type PromotionUpdateWithoutPromotionHotelInput = {
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usesPerUser?: NullableIntFieldUpdateOperationsInput | number | null
    currentUses?: IntFieldUpdateOperationsInput | number
    minNights?: NullableIntFieldUpdateOperationsInput | number | null
    minAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutPromotionNestedInput
    PromotionRoomType?: PromotionRoomTypeUpdateManyWithoutPromotionNestedInput
  }

  export type PromotionUncheckedUpdateWithoutPromotionHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usesPerUser?: NullableIntFieldUpdateOperationsInput | number | null
    currentUses?: IntFieldUpdateOperationsInput | number
    minNights?: NullableIntFieldUpdateOperationsInput | number | null
    minAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutPromotionNestedInput
    PromotionRoomType?: PromotionRoomTypeUncheckedUpdateManyWithoutPromotionNestedInput
  }

  export type HotelUpsertWithoutPromotionHotelInput = {
    update: XOR<HotelUpdateWithoutPromotionHotelInput, HotelUncheckedUpdateWithoutPromotionHotelInput>
    create: XOR<HotelCreateWithoutPromotionHotelInput, HotelUncheckedCreateWithoutPromotionHotelInput>
    where?: HotelWhereInput
  }

  export type HotelUpdateToOneWithWhereWithoutPromotionHotelInput = {
    where?: HotelWhereInput
    data: XOR<HotelUpdateWithoutPromotionHotelInput, HotelUncheckedUpdateWithoutPromotionHotelInput>
  }

  export type HotelUpdateWithoutPromotionHotelInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Address?: AddressUpdateOneWithoutHotelNestedInput
    images?: ImageUpdateManyWithoutHotelNestedInput
    amenities?: HotelAmenityUpdateManyWithoutHotelNestedInput
    roomTypes?: RoomTypeUpdateManyWithoutHotelNestedInput
    rooms?: RoomUpdateManyWithoutHotelNestedInput
    bookings?: BookingUpdateManyWithoutHotelNestedInput
    reviews?: ReviewUpdateManyWithoutHotelNestedInput
    inventory?: RoomInventoryUpdateManyWithoutHotelNestedInput
    prices?: RoomPriceUpdateManyWithoutHotelNestedInput
    policies?: CancellationPolicyUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateWithoutPromotionHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    addressId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ImageUncheckedUpdateManyWithoutHotelNestedInput
    amenities?: HotelAmenityUncheckedUpdateManyWithoutHotelNestedInput
    roomTypes?: RoomTypeUncheckedUpdateManyWithoutHotelNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutHotelNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutHotelNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutHotelNestedInput
    inventory?: RoomInventoryUncheckedUpdateManyWithoutHotelNestedInput
    prices?: RoomPriceUncheckedUpdateManyWithoutHotelNestedInput
    policies?: CancellationPolicyUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type PromotionCreateWithoutPromotionRoomTypeInput = {
    code: string
    description?: string | null
    discountType?: $Enums.DiscountType
    discountValue: number
    validFrom?: Date | string | null
    validUntil?: Date | string | null
    maxUses?: number | null
    usesPerUser?: number | null
    currentUses?: number
    minNights?: number | null
    minAmount?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutPromotionInput
    PromotionHotel?: PromotionHotelCreateNestedManyWithoutPromotionInput
  }

  export type PromotionUncheckedCreateWithoutPromotionRoomTypeInput = {
    id?: number
    code: string
    description?: string | null
    discountType?: $Enums.DiscountType
    discountValue: number
    validFrom?: Date | string | null
    validUntil?: Date | string | null
    maxUses?: number | null
    usesPerUser?: number | null
    currentUses?: number
    minNights?: number | null
    minAmount?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutPromotionInput
    PromotionHotel?: PromotionHotelUncheckedCreateNestedManyWithoutPromotionInput
  }

  export type PromotionCreateOrConnectWithoutPromotionRoomTypeInput = {
    where: PromotionWhereUniqueInput
    create: XOR<PromotionCreateWithoutPromotionRoomTypeInput, PromotionUncheckedCreateWithoutPromotionRoomTypeInput>
  }

  export type RoomTypeCreateWithoutPromotionRoomTypeInput = {
    name: string
    description?: string | null
    maxGuests: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Hotel: HotelCreateNestedOneWithoutRoomTypesInput
    images?: ImageCreateNestedManyWithoutRoomTypeInput
    amenities?: RoomTypeAmenityCreateNestedManyWithoutRoomTypeInput
    rooms?: RoomCreateNestedManyWithoutRoomTypeInput
    inventory?: RoomInventoryCreateNestedManyWithoutRoomTypeInput
    prices?: RoomPriceCreateNestedManyWithoutRoomTypeInput
    bookings?: BookingCreateNestedManyWithoutRoomTypeInput
  }

  export type RoomTypeUncheckedCreateWithoutPromotionRoomTypeInput = {
    id?: number
    hotelId: number
    name: string
    description?: string | null
    maxGuests: number
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ImageUncheckedCreateNestedManyWithoutRoomTypeInput
    amenities?: RoomTypeAmenityUncheckedCreateNestedManyWithoutRoomTypeInput
    rooms?: RoomUncheckedCreateNestedManyWithoutRoomTypeInput
    inventory?: RoomInventoryUncheckedCreateNestedManyWithoutRoomTypeInput
    prices?: RoomPriceUncheckedCreateNestedManyWithoutRoomTypeInput
    bookings?: BookingUncheckedCreateNestedManyWithoutRoomTypeInput
  }

  export type RoomTypeCreateOrConnectWithoutPromotionRoomTypeInput = {
    where: RoomTypeWhereUniqueInput
    create: XOR<RoomTypeCreateWithoutPromotionRoomTypeInput, RoomTypeUncheckedCreateWithoutPromotionRoomTypeInput>
  }

  export type PromotionUpsertWithoutPromotionRoomTypeInput = {
    update: XOR<PromotionUpdateWithoutPromotionRoomTypeInput, PromotionUncheckedUpdateWithoutPromotionRoomTypeInput>
    create: XOR<PromotionCreateWithoutPromotionRoomTypeInput, PromotionUncheckedCreateWithoutPromotionRoomTypeInput>
    where?: PromotionWhereInput
  }

  export type PromotionUpdateToOneWithWhereWithoutPromotionRoomTypeInput = {
    where?: PromotionWhereInput
    data: XOR<PromotionUpdateWithoutPromotionRoomTypeInput, PromotionUncheckedUpdateWithoutPromotionRoomTypeInput>
  }

  export type PromotionUpdateWithoutPromotionRoomTypeInput = {
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usesPerUser?: NullableIntFieldUpdateOperationsInput | number | null
    currentUses?: IntFieldUpdateOperationsInput | number
    minNights?: NullableIntFieldUpdateOperationsInput | number | null
    minAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutPromotionNestedInput
    PromotionHotel?: PromotionHotelUpdateManyWithoutPromotionNestedInput
  }

  export type PromotionUncheckedUpdateWithoutPromotionRoomTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usesPerUser?: NullableIntFieldUpdateOperationsInput | number | null
    currentUses?: IntFieldUpdateOperationsInput | number
    minNights?: NullableIntFieldUpdateOperationsInput | number | null
    minAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutPromotionNestedInput
    PromotionHotel?: PromotionHotelUncheckedUpdateManyWithoutPromotionNestedInput
  }

  export type RoomTypeUpsertWithoutPromotionRoomTypeInput = {
    update: XOR<RoomTypeUpdateWithoutPromotionRoomTypeInput, RoomTypeUncheckedUpdateWithoutPromotionRoomTypeInput>
    create: XOR<RoomTypeCreateWithoutPromotionRoomTypeInput, RoomTypeUncheckedCreateWithoutPromotionRoomTypeInput>
    where?: RoomTypeWhereInput
  }

  export type RoomTypeUpdateToOneWithWhereWithoutPromotionRoomTypeInput = {
    where?: RoomTypeWhereInput
    data: XOR<RoomTypeUpdateWithoutPromotionRoomTypeInput, RoomTypeUncheckedUpdateWithoutPromotionRoomTypeInput>
  }

  export type RoomTypeUpdateWithoutPromotionRoomTypeInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Hotel?: HotelUpdateOneRequiredWithoutRoomTypesNestedInput
    images?: ImageUpdateManyWithoutRoomTypeNestedInput
    amenities?: RoomTypeAmenityUpdateManyWithoutRoomTypeNestedInput
    rooms?: RoomUpdateManyWithoutRoomTypeNestedInput
    inventory?: RoomInventoryUpdateManyWithoutRoomTypeNestedInput
    prices?: RoomPriceUpdateManyWithoutRoomTypeNestedInput
    bookings?: BookingUpdateManyWithoutRoomTypeNestedInput
  }

  export type RoomTypeUncheckedUpdateWithoutPromotionRoomTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ImageUncheckedUpdateManyWithoutRoomTypeNestedInput
    amenities?: RoomTypeAmenityUncheckedUpdateManyWithoutRoomTypeNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutRoomTypeNestedInput
    inventory?: RoomInventoryUncheckedUpdateManyWithoutRoomTypeNestedInput
    prices?: RoomPriceUncheckedUpdateManyWithoutRoomTypeNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutRoomTypeNestedInput
  }

  export type ImageCreateManyHotelInput = {
    id?: number
    url: string
    altText?: string | null
    order?: number | null
    roomTypeId?: number | null
    createdAt?: Date | string
  }

  export type HotelAmenityCreateManyHotelInput = {
    amenityId: number
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type RoomTypeCreateManyHotelInput = {
    id?: number
    name: string
    description?: string | null
    maxGuests: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomCreateManyHotelInput = {
    id?: number
    roomTypeId: number
    roomNumber: string
    floor?: string | null
    status?: $Enums.RoomStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingCreateManyHotelInput = {
    id?: number
    userId?: number | null
    roomTypeId: number
    numberOfRooms?: number
    checkIn: Date | string
    checkOut: Date | string
    totalAmount?: number | null
    currency?: $Enums.CurrencyCode
    status?: $Enums.BookingStatus
    guestName?: string | null
    guestSurname?: string | null
    guestEmail?: string | null
    guestPhone?: string | null
    guestIdentity?: string | null
    promotionId?: number | null
    cancellationPolicyId?: number | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateManyHotelInput = {
    id?: number
    bookingId: number
    userId: number
    rating: number
    title?: string | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomInventoryCreateManyHotelInput = {
    id?: number
    roomTypeId: number
    date: Date | string
    totalInventory: number
    bookedCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomPriceCreateManyHotelInput = {
    id?: number
    roomTypeId: number
    date: Date | string
    price: number
    currency?: $Enums.CurrencyCode
    priceType?: $Enums.PriceType | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CancellationPolicyCreateManyHotelInput = {
    id?: number
    name: string
    description?: string | null
    rules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromotionHotelCreateManyHotelInput = {
    id?: number
    promotionId: number
    createdAt?: Date | string
  }

  export type ImageUpdateWithoutHotelInput = {
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RoomType?: RoomTypeUpdateOneWithoutImagesNestedInput
  }

  export type ImageUncheckedUpdateWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageUncheckedUpdateManyWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelAmenityUpdateWithoutHotelInput = {
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Amenity?: AmenityUpdateOneRequiredWithoutHotelsNestedInput
  }

  export type HotelAmenityUncheckedUpdateWithoutHotelInput = {
    amenityId?: IntFieldUpdateOperationsInput | number
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelAmenityUncheckedUpdateManyWithoutHotelInput = {
    amenityId?: IntFieldUpdateOperationsInput | number
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomTypeUpdateWithoutHotelInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ImageUpdateManyWithoutRoomTypeNestedInput
    amenities?: RoomTypeAmenityUpdateManyWithoutRoomTypeNestedInput
    rooms?: RoomUpdateManyWithoutRoomTypeNestedInput
    inventory?: RoomInventoryUpdateManyWithoutRoomTypeNestedInput
    prices?: RoomPriceUpdateManyWithoutRoomTypeNestedInput
    bookings?: BookingUpdateManyWithoutRoomTypeNestedInput
    PromotionRoomType?: PromotionRoomTypeUpdateManyWithoutRoomTypeNestedInput
  }

  export type RoomTypeUncheckedUpdateWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ImageUncheckedUpdateManyWithoutRoomTypeNestedInput
    amenities?: RoomTypeAmenityUncheckedUpdateManyWithoutRoomTypeNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutRoomTypeNestedInput
    inventory?: RoomInventoryUncheckedUpdateManyWithoutRoomTypeNestedInput
    prices?: RoomPriceUncheckedUpdateManyWithoutRoomTypeNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutRoomTypeNestedInput
    PromotionRoomType?: PromotionRoomTypeUncheckedUpdateManyWithoutRoomTypeNestedInput
  }

  export type RoomTypeUncheckedUpdateManyWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomUpdateWithoutHotelInput = {
    roomNumber?: StringFieldUpdateOperationsInput | string
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RoomType?: RoomTypeUpdateOneRequiredWithoutRoomsNestedInput
  }

  export type RoomUncheckedUpdateWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomTypeId?: IntFieldUpdateOperationsInput | number
    roomNumber?: StringFieldUpdateOperationsInput | string
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomUncheckedUpdateManyWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomTypeId?: IntFieldUpdateOperationsInput | number
    roomNumber?: StringFieldUpdateOperationsInput | string
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUpdateWithoutHotelInput = {
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestSurname?: NullableStringFieldUpdateOperationsInput | string | null
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestIdentity?: NullableStringFieldUpdateOperationsInput | string | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneWithoutBookingsNestedInput
    RoomType?: RoomTypeUpdateOneRequiredWithoutBookingsNestedInput
    payment?: PaymentUpdateOneWithoutBookingNestedInput
    review?: ReviewUpdateOneWithoutBookingNestedInput
    Promotion?: PromotionUpdateOneWithoutBookingsNestedInput
    CancellationPolicy?: CancellationPolicyUpdateOneWithoutBookingsNestedInput
    cancellation?: CancellationUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypeId?: IntFieldUpdateOperationsInput | number
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestSurname?: NullableStringFieldUpdateOperationsInput | string | null
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestIdentity?: NullableStringFieldUpdateOperationsInput | string | null
    promotionId?: NullableIntFieldUpdateOperationsInput | number | null
    cancellationPolicyId?: NullableIntFieldUpdateOperationsInput | number | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUncheckedUpdateOneWithoutBookingNestedInput
    review?: ReviewUncheckedUpdateOneWithoutBookingNestedInput
    cancellation?: CancellationUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypeId?: IntFieldUpdateOperationsInput | number
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestSurname?: NullableStringFieldUpdateOperationsInput | string | null
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestIdentity?: NullableStringFieldUpdateOperationsInput | string | null
    promotionId?: NullableIntFieldUpdateOperationsInput | number | null
    cancellationPolicyId?: NullableIntFieldUpdateOperationsInput | number | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutHotelInput = {
    rating?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Booking?: BookingUpdateOneRequiredWithoutReviewNestedInput
    User?: UserUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomInventoryUpdateWithoutHotelInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalInventory?: IntFieldUpdateOperationsInput | number
    bookedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RoomType?: RoomTypeUpdateOneRequiredWithoutInventoryNestedInput
  }

  export type RoomInventoryUncheckedUpdateWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomTypeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalInventory?: IntFieldUpdateOperationsInput | number
    bookedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomInventoryUncheckedUpdateManyWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomTypeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalInventory?: IntFieldUpdateOperationsInput | number
    bookedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomPriceUpdateWithoutHotelInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    priceType?: NullableEnumPriceTypeFieldUpdateOperationsInput | $Enums.PriceType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RoomType?: RoomTypeUpdateOneRequiredWithoutPricesNestedInput
  }

  export type RoomPriceUncheckedUpdateWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomTypeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    priceType?: NullableEnumPriceTypeFieldUpdateOperationsInput | $Enums.PriceType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomPriceUncheckedUpdateManyWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomTypeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    priceType?: NullableEnumPriceTypeFieldUpdateOperationsInput | $Enums.PriceType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CancellationPolicyUpdateWithoutHotelInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutCancellationPolicyNestedInput
  }

  export type CancellationPolicyUncheckedUpdateWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutCancellationPolicyNestedInput
  }

  export type CancellationPolicyUncheckedUpdateManyWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionHotelUpdateWithoutHotelInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Promotion?: PromotionUpdateOneRequiredWithoutPromotionHotelNestedInput
  }

  export type PromotionHotelUncheckedUpdateWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    promotionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionHotelUncheckedUpdateManyWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    promotionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelAmenityCreateManyAmenityInput = {
    hotelId: number
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type RoomTypeAmenityCreateManyAmenityInput = {
    roomTypeId: number
    createdAt?: Date | string
  }

  export type HotelAmenityUpdateWithoutAmenityInput = {
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Hotel?: HotelUpdateOneRequiredWithoutAmenitiesNestedInput
  }

  export type HotelAmenityUncheckedUpdateWithoutAmenityInput = {
    hotelId?: IntFieldUpdateOperationsInput | number
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HotelAmenityUncheckedUpdateManyWithoutAmenityInput = {
    hotelId?: IntFieldUpdateOperationsInput | number
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomTypeAmenityUpdateWithoutAmenityInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RoomType?: RoomTypeUpdateOneRequiredWithoutAmenitiesNestedInput
  }

  export type RoomTypeAmenityUncheckedUpdateWithoutAmenityInput = {
    roomTypeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomTypeAmenityUncheckedUpdateManyWithoutAmenityInput = {
    roomTypeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageCreateManyRoomTypeInput = {
    id?: number
    url: string
    altText?: string | null
    order?: number | null
    hotelId?: number | null
    createdAt?: Date | string
  }

  export type RoomTypeAmenityCreateManyRoomTypeInput = {
    amenityId: number
    createdAt?: Date | string
  }

  export type RoomCreateManyRoomTypeInput = {
    id?: number
    roomNumber: string
    floor?: string | null
    status?: $Enums.RoomStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelId?: number | null
  }

  export type RoomInventoryCreateManyRoomTypeInput = {
    id?: number
    date: Date | string
    totalInventory: number
    bookedCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelId?: number | null
  }

  export type RoomPriceCreateManyRoomTypeInput = {
    id?: number
    date: Date | string
    price: number
    currency?: $Enums.CurrencyCode
    priceType?: $Enums.PriceType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelId?: number | null
  }

  export type BookingCreateManyRoomTypeInput = {
    id?: number
    userId?: number | null
    numberOfRooms?: number
    checkIn: Date | string
    checkOut: Date | string
    totalAmount?: number | null
    currency?: $Enums.CurrencyCode
    status?: $Enums.BookingStatus
    guestName?: string | null
    guestSurname?: string | null
    guestEmail?: string | null
    guestPhone?: string | null
    guestIdentity?: string | null
    promotionId?: number | null
    cancellationPolicyId?: number | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelId?: number | null
  }

  export type PromotionRoomTypeCreateManyRoomTypeInput = {
    id?: number
    promotionId: number
    createdAt?: Date | string
  }

  export type ImageUpdateWithoutRoomTypeInput = {
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Hotel?: HotelUpdateOneWithoutImagesNestedInput
  }

  export type ImageUncheckedUpdateWithoutRoomTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageUncheckedUpdateManyWithoutRoomTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomTypeAmenityUpdateWithoutRoomTypeInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Amenity?: AmenityUpdateOneRequiredWithoutRoomTypesNestedInput
  }

  export type RoomTypeAmenityUncheckedUpdateWithoutRoomTypeInput = {
    amenityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomTypeAmenityUncheckedUpdateManyWithoutRoomTypeInput = {
    amenityId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomUpdateWithoutRoomTypeInput = {
    roomNumber?: StringFieldUpdateOperationsInput | string
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Hotel?: HotelUpdateOneWithoutRoomsNestedInput
  }

  export type RoomUncheckedUpdateWithoutRoomTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomNumber?: StringFieldUpdateOperationsInput | string
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RoomUncheckedUpdateManyWithoutRoomTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomNumber?: StringFieldUpdateOperationsInput | string
    floor?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RoomInventoryUpdateWithoutRoomTypeInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalInventory?: IntFieldUpdateOperationsInput | number
    bookedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Hotel?: HotelUpdateOneWithoutInventoryNestedInput
  }

  export type RoomInventoryUncheckedUpdateWithoutRoomTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalInventory?: IntFieldUpdateOperationsInput | number
    bookedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RoomInventoryUncheckedUpdateManyWithoutRoomTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalInventory?: IntFieldUpdateOperationsInput | number
    bookedCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RoomPriceUpdateWithoutRoomTypeInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    priceType?: NullableEnumPriceTypeFieldUpdateOperationsInput | $Enums.PriceType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Hotel?: HotelUpdateOneWithoutPricesNestedInput
  }

  export type RoomPriceUncheckedUpdateWithoutRoomTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    priceType?: NullableEnumPriceTypeFieldUpdateOperationsInput | $Enums.PriceType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RoomPriceUncheckedUpdateManyWithoutRoomTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    priceType?: NullableEnumPriceTypeFieldUpdateOperationsInput | $Enums.PriceType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BookingUpdateWithoutRoomTypeInput = {
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestSurname?: NullableStringFieldUpdateOperationsInput | string | null
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestIdentity?: NullableStringFieldUpdateOperationsInput | string | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneWithoutBookingsNestedInput
    payment?: PaymentUpdateOneWithoutBookingNestedInput
    review?: ReviewUpdateOneWithoutBookingNestedInput
    Promotion?: PromotionUpdateOneWithoutBookingsNestedInput
    CancellationPolicy?: CancellationPolicyUpdateOneWithoutBookingsNestedInput
    cancellation?: CancellationUpdateOneWithoutBookingNestedInput
    Hotel?: HotelUpdateOneWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateWithoutRoomTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestSurname?: NullableStringFieldUpdateOperationsInput | string | null
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestIdentity?: NullableStringFieldUpdateOperationsInput | string | null
    promotionId?: NullableIntFieldUpdateOperationsInput | number | null
    cancellationPolicyId?: NullableIntFieldUpdateOperationsInput | number | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
    payment?: PaymentUncheckedUpdateOneWithoutBookingNestedInput
    review?: ReviewUncheckedUpdateOneWithoutBookingNestedInput
    cancellation?: CancellationUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutRoomTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestSurname?: NullableStringFieldUpdateOperationsInput | string | null
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestIdentity?: NullableStringFieldUpdateOperationsInput | string | null
    promotionId?: NullableIntFieldUpdateOperationsInput | number | null
    cancellationPolicyId?: NullableIntFieldUpdateOperationsInput | number | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PromotionRoomTypeUpdateWithoutRoomTypeInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Promotion?: PromotionUpdateOneRequiredWithoutPromotionRoomTypeNestedInput
  }

  export type PromotionRoomTypeUncheckedUpdateWithoutRoomTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    promotionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionRoomTypeUncheckedUpdateManyWithoutRoomTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    promotionId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateManyUserInput = {
    id?: number
    roomTypeId: number
    numberOfRooms?: number
    checkIn: Date | string
    checkOut: Date | string
    totalAmount?: number | null
    currency?: $Enums.CurrencyCode
    status?: $Enums.BookingStatus
    guestName?: string | null
    guestSurname?: string | null
    guestEmail?: string | null
    guestPhone?: string | null
    guestIdentity?: string | null
    promotionId?: number | null
    cancellationPolicyId?: number | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelId?: number | null
  }

  export type ReviewCreateManyUserInput = {
    id?: number
    bookingId: number
    rating: number
    title?: string | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelId?: number | null
  }

  export type CancellationCreateManyUserInput = {
    id?: number
    bookingId: number
    reason?: string | null
    cancelledAt?: Date | string
    refundAmount?: number | null
    refundStatus?: string | null
    notes?: string | null
  }

  export type BookingUpdateWithoutUserInput = {
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestSurname?: NullableStringFieldUpdateOperationsInput | string | null
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestIdentity?: NullableStringFieldUpdateOperationsInput | string | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RoomType?: RoomTypeUpdateOneRequiredWithoutBookingsNestedInput
    payment?: PaymentUpdateOneWithoutBookingNestedInput
    review?: ReviewUpdateOneWithoutBookingNestedInput
    Promotion?: PromotionUpdateOneWithoutBookingsNestedInput
    CancellationPolicy?: CancellationPolicyUpdateOneWithoutBookingsNestedInput
    cancellation?: CancellationUpdateOneWithoutBookingNestedInput
    Hotel?: HotelUpdateOneWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomTypeId?: IntFieldUpdateOperationsInput | number
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestSurname?: NullableStringFieldUpdateOperationsInput | string | null
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestIdentity?: NullableStringFieldUpdateOperationsInput | string | null
    promotionId?: NullableIntFieldUpdateOperationsInput | number | null
    cancellationPolicyId?: NullableIntFieldUpdateOperationsInput | number | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
    payment?: PaymentUncheckedUpdateOneWithoutBookingNestedInput
    review?: ReviewUncheckedUpdateOneWithoutBookingNestedInput
    cancellation?: CancellationUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomTypeId?: IntFieldUpdateOperationsInput | number
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestSurname?: NullableStringFieldUpdateOperationsInput | string | null
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestIdentity?: NullableStringFieldUpdateOperationsInput | string | null
    promotionId?: NullableIntFieldUpdateOperationsInput | number | null
    cancellationPolicyId?: NullableIntFieldUpdateOperationsInput | number | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReviewUpdateWithoutUserInput = {
    rating?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Booking?: BookingUpdateOneRequiredWithoutReviewNestedInput
    Hotel?: HotelUpdateOneWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReviewUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CancellationUpdateWithoutUserInput = {
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundStatus?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    Booking?: BookingUpdateOneRequiredWithoutCancellationNestedInput
  }

  export type CancellationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundStatus?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CancellationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundStatus?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateManyRoleInput = {
    id?: number
    username: string
    email?: string | null
    password?: string | null
    firstName?: string | null
    lastName?: string | null
    phoneNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutRoleInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    cancellations?: CancellationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    cancellations?: CancellationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyPaymentInput = {
    id?: string
    type: $Enums.TransactionType
    amount: number
    currency?: $Enums.CurrencyCode
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    status?: $Enums.TransactionStatus
  }

  export type TransactionUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
  }

  export type TransactionUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
  }

  export type TransactionUncheckedUpdateManyWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
  }

  export type BookingCreateManyPromotionInput = {
    id?: number
    userId?: number | null
    roomTypeId: number
    numberOfRooms?: number
    checkIn: Date | string
    checkOut: Date | string
    totalAmount?: number | null
    currency?: $Enums.CurrencyCode
    status?: $Enums.BookingStatus
    guestName?: string | null
    guestSurname?: string | null
    guestEmail?: string | null
    guestPhone?: string | null
    guestIdentity?: string | null
    cancellationPolicyId?: number | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelId?: number | null
  }

  export type PromotionHotelCreateManyPromotionInput = {
    id?: number
    hotelId: number
    createdAt?: Date | string
  }

  export type PromotionRoomTypeCreateManyPromotionInput = {
    id?: number
    roomTypeId: number
    createdAt?: Date | string
  }

  export type BookingUpdateWithoutPromotionInput = {
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestSurname?: NullableStringFieldUpdateOperationsInput | string | null
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestIdentity?: NullableStringFieldUpdateOperationsInput | string | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneWithoutBookingsNestedInput
    RoomType?: RoomTypeUpdateOneRequiredWithoutBookingsNestedInput
    payment?: PaymentUpdateOneWithoutBookingNestedInput
    review?: ReviewUpdateOneWithoutBookingNestedInput
    CancellationPolicy?: CancellationPolicyUpdateOneWithoutBookingsNestedInput
    cancellation?: CancellationUpdateOneWithoutBookingNestedInput
    Hotel?: HotelUpdateOneWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateWithoutPromotionInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypeId?: IntFieldUpdateOperationsInput | number
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestSurname?: NullableStringFieldUpdateOperationsInput | string | null
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestIdentity?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicyId?: NullableIntFieldUpdateOperationsInput | number | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
    payment?: PaymentUncheckedUpdateOneWithoutBookingNestedInput
    review?: ReviewUncheckedUpdateOneWithoutBookingNestedInput
    cancellation?: CancellationUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutPromotionInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypeId?: IntFieldUpdateOperationsInput | number
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestSurname?: NullableStringFieldUpdateOperationsInput | string | null
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestIdentity?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicyId?: NullableIntFieldUpdateOperationsInput | number | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PromotionHotelUpdateWithoutPromotionInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Hotel?: HotelUpdateOneRequiredWithoutPromotionHotelNestedInput
  }

  export type PromotionHotelUncheckedUpdateWithoutPromotionInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionHotelUncheckedUpdateManyWithoutPromotionInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionRoomTypeUpdateWithoutPromotionInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RoomType?: RoomTypeUpdateOneRequiredWithoutPromotionRoomTypeNestedInput
  }

  export type PromotionRoomTypeUncheckedUpdateWithoutPromotionInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomTypeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromotionRoomTypeUncheckedUpdateManyWithoutPromotionInput = {
    id?: IntFieldUpdateOperationsInput | number
    roomTypeId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateManyCancellationPolicyInput = {
    id?: number
    userId?: number | null
    roomTypeId: number
    numberOfRooms?: number
    checkIn: Date | string
    checkOut: Date | string
    totalAmount?: number | null
    currency?: $Enums.CurrencyCode
    status?: $Enums.BookingStatus
    guestName?: string | null
    guestSurname?: string | null
    guestEmail?: string | null
    guestPhone?: string | null
    guestIdentity?: string | null
    promotionId?: number | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    hotelId?: number | null
  }

  export type BookingUpdateWithoutCancellationPolicyInput = {
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestSurname?: NullableStringFieldUpdateOperationsInput | string | null
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestIdentity?: NullableStringFieldUpdateOperationsInput | string | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneWithoutBookingsNestedInput
    RoomType?: RoomTypeUpdateOneRequiredWithoutBookingsNestedInput
    payment?: PaymentUpdateOneWithoutBookingNestedInput
    review?: ReviewUpdateOneWithoutBookingNestedInput
    Promotion?: PromotionUpdateOneWithoutBookingsNestedInput
    cancellation?: CancellationUpdateOneWithoutBookingNestedInput
    Hotel?: HotelUpdateOneWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateWithoutCancellationPolicyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypeId?: IntFieldUpdateOperationsInput | number
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestSurname?: NullableStringFieldUpdateOperationsInput | string | null
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestIdentity?: NullableStringFieldUpdateOperationsInput | string | null
    promotionId?: NullableIntFieldUpdateOperationsInput | number | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
    payment?: PaymentUncheckedUpdateOneWithoutBookingNestedInput
    review?: ReviewUncheckedUpdateOneWithoutBookingNestedInput
    cancellation?: CancellationUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutCancellationPolicyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    roomTypeId?: IntFieldUpdateOperationsInput | number
    numberOfRooms?: IntFieldUpdateOperationsInput | number
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: EnumCurrencyCodeFieldUpdateOperationsInput | $Enums.CurrencyCode
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    guestName?: NullableStringFieldUpdateOperationsInput | string | null
    guestSurname?: NullableStringFieldUpdateOperationsInput | string | null
    guestEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    guestIdentity?: NullableStringFieldUpdateOperationsInput | string | null
    promotionId?: NullableIntFieldUpdateOperationsInput | number | null
    promotionSnapshot?: NullableJsonNullValueInput | InputJsonValue
    policySnapshot?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hotelId?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}